<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>鑫宇的个人博客</title>
  
  
  <link href="http://yoursite.com/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2020-10-02T03:11:43.962Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>rain</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>计算机网络学习笔记（一）</title>
    <link href="http://yoursite.com/2020/10/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89/"/>
    <id>http://yoursite.com/2020/10/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89/</id>
    <published>2020-10-01T02:00:00.000Z</published>
    <updated>2020-10-02T03:11:43.962Z</updated>
    
    <content type="html"><![CDATA[<h1 id="计算机网络概述"><a href="#计算机网络概述" class="headerlink" title="计算机网络概述"></a>计算机网络概述</h1><h2 id="1、计算机网络在信息时代中的作用"><a href="#1、计算机网络在信息时代中的作用" class="headerlink" title="1、计算机网络在信息时代中的作用"></a>1、计算机网络在信息时代中的作用</h2><p>1.21 世纪的一些重要特征就是数字化、网络化和信息化，它是一个以网络为核心的信息时代。<br>2.网络现已成为信息社会的命脉和发展知识经济的重要基础。<br>3.网络是指“三网”，即电信网络、有线电视网络和计算机网络。<br>4.发展最快的并起到核心作用的是计算机网络。<br>5.因特网(Internet)的发展<br>进入 20 世纪 90 年代以后，以因特网为代表的计算机网络得到了飞速的发展。</p><p>已从最初的教育科研网络逐步发展成为商业网络。  </p><p>已成为仅次于全球电话网的世界第二大网络。  </p><a id="more"></a><p>6.因特网的意义<br>因特网是自印刷术以来人类通信方面最大的变革。  </p><p>现在人们的生活、工作、学习和交往都已离不开因特网。  </p><h2 id="2、因特网概述"><a href="#2、因特网概述" class="headerlink" title="2、因特网概述"></a>2、因特网概述</h2><h3 id="2-1-网络的网络"><a href="#2-1-网络的网络" class="headerlink" title="2.1 网络的网络"></a>2.1 网络的网络</h3><p>1.起源于美国的因特网现已发展成为世界上最大的国际性计算机互联网<br>2.网络(network)由若干结点(node)和连接这些结点的链路(link)组成。<br>3.互联网是“网络的网络”(network of networks)。<br>4.连接在因特网上的计算机都称为主机(host)。<br>5.网络与因特网<br>网络把许多计算机连接在一起。<br><img src="/2020/10/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89/1.png" alt="alt"><br>因特网则把许多网络连接在一起。<br><img src="/2020/10/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89/2.png" alt="alt">  </p><h3 id="2-2-因特网发展的三个阶段"><a href="#2-2-因特网发展的三个阶段" class="headerlink" title="2.2 因特网发展的三个阶段"></a>2.2 因特网发展的三个阶段</h3><p>1.第一阶段是从单个网络 ARPANET 向互联网发展的过程。<br>1983 年 TCP/IP 协议成为 ARPANET 上的标准协议。  </p><p>人们把 1983 年作为因特网的诞生时间。  </p><p>2.第二阶段的特点是建成了三级结构的因特网。<br>三级计算机网络，分为主干网、地区网和校园网（或企业网）。  </p><p>3.第三阶段的特点是逐渐形成了多层次 ISP 结构的因特网。<br>出现了因特网服务提供者 ISP (Internet Service Provider)。  </p><p><img src="/2020/10/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89/3.png" alt="alt"><br>根据提供服务的覆盖面积大小以及所拥有的IP 地址数目的不同，ISP 也分成为不同的层次。<br><img src="/2020/10/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89/4.png" alt="alt">  </p><h3 id="2-3因特网的标准化工作"><a href="#2-3因特网的标准化工作" class="headerlink" title="2.3因特网的标准化工作"></a>2.3因特网的标准化工作</h3><p><img src="/2020/10/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89/5.png" alt="alt"><br>1.制订因特网的正式标准要经过以下的四个阶段<br>因特网草案(Internet Draft) ——在这个阶段还不是 RFC 文档。<br>建议标准(Proposed Standard) ——从这个阶段开始就成为 RFC 文档。<br>草案标准(Draft Standard)<br>因特网标准(Internet Standard)<br>2.各种RFC之间的关系<br><img src="/2020/10/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89/6.png" alt="alt">  </p><h3 id="2-4计算机网络在我国的发展"><a href="#2-4计算机网络在我国的发展" class="headerlink" title="2.4计算机网络在我国的发展"></a>2.4计算机网络在我国的发展</h3><p>1.中国公用计算机互联网 CHINANET<br>2.中国教育和科研计算机网 CERNET<br>3.中国科学技术网 CSTNET<br>4.中国联通互联网 UNINET<br>5.中国网通公用互联网 CNCNET<br>6.中国国际经济贸易互联网 CIETNET<br>7.中国移动互联网 CMNET<br>8.中国长城互联网 CGWNET（建设中）<br>9.中国卫星集团互联网 CSNET（建设中）  </p><h2 id="3、计算机网络的类别"><a href="#3、计算机网络的类别" class="headerlink" title="3、计算机网络的类别"></a>3、计算机网络的类别</h2><h3 id="3-1计算机网络的定义"><a href="#3-1计算机网络的定义" class="headerlink" title="3.1计算机网络的定义"></a>3.1计算机网络的定义</h3><p>最简单的定义：计算机网络是一些互相连接的、自治的计算机的集合。  </p><p>因特网(Internet)是“网络的网络”。  </p><h3 id="3-2几种不同类别的网络"><a href="#3-2几种不同类别的网络" class="headerlink" title="3.2几种不同类别的网络"></a>3.2几种不同类别的网络</h3><p>1.不同作用范围的网络<br>广域网 WAN (Wide Area Network)<br>局域网 LAN (Local Area Network)<br>城域网 MAN (Metropolitan Area Network)<br>个人区域网 PAN (Personal Area Network)<br>2.从网络的使用者进行分类<br>公用网 (public network)<br>专用网 (private network)  </p><h2 id="4、因特网的组成"><a href="#4、因特网的组成" class="headerlink" title="4、因特网的组成"></a>4、因特网的组成</h2><p><img src="/2020/10/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89/22.png" alt="alt">  </p><h3 id="4-1因特网的边缘部分"><a href="#4-1因特网的边缘部分" class="headerlink" title="4.1因特网的边缘部分"></a>4.1因特网的边缘部分</h3><p>1.由所有连接在因特网上的主机组成。这部分是用户直接使用的，用来进行通信（传送数据、音频或视频）和资源共享。<br>2.处在因特网边缘的部分就是连接在因特网上的所有的主机。这些主机又称为端系统(end system)。<br>3.“主机 A 和主机 B 进行通信”，实际上是指：“运行在主机 A 上的某个程序和运行在主机 B 上的另一个程序进行通信”.<br>4.即“主机 A 的某个进程和主机 B 上的另一个进程进行通信”。或简称为“计算机之间通信”.  </p><h4 id="4-1-1两种通信方式"><a href="#4-1-1两种通信方式" class="headerlink" title="4.1.1两种通信方式"></a>4.1.1两种通信方式</h4><p>1.客户服务器方式（C/S 方式）   即Client/Server方式<br><img src="/2020/10/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89/11.png" alt="alt">  </p><ul><li>客户(client)和服务器(server)都是指通信中所涉及的两个应用进程。  </li><li>客户服务器方式所描述的是进程之间服务和被服务的关系。  </li><li>客户是服务的请求方，服务器是服务的提供方。  </li></ul><blockquote><p>客户软件的特点<br>被用户调用后运行，在打算通信时主动向远地服务器发起通信（请求服务）。因此，客户程序必须知道服务器程序的地址。<br>不需要特殊的硬件和很复杂的操作系统。<br>服务器软件的特点<br>一种专门用来提供某种服务的程序，可同时处理多个远地或本地客户的请求。<br>系统启动后即自动调用并一直不断地运行着，被动地等待并接受来自各地的客户的通信请求。因此，服务器程序不需要知道客户程序的地址。<br>一般需要强大的硬件和高级的操作系统支持。  </p></blockquote><p>2.对等方式（P2P 方式）   即 Peer-to-Peer方式<br><img src="/2020/10/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89/12.png" alt="alt">  </p><ul><li>对等连接(peer-to-peer，简写为 P2P)是指两个主机在通信时并不区分哪一个是服务请求方还是服务提供方。  </li><li>只要两个主机都运行了对等连接软件（P2P 软件），它们就可以进行平等的、对等连接通信。  </li><li>双方都可以下载对方已经存储在硬盘中的共享文档。  </li><li>对等连接方式的特点  </li></ul><blockquote><p>对等连接方式从本质上看仍然是使用客户服务器方式，只是对等连接中的每一个主机既是客户又同时是服务器。<br>例如主机 C 请求 D 的服务时，C 是客户，D 是服务器。但如果 C 又同时向 F提供服务，那么 C 又同时起着服务器的作用。  </p></blockquote><h3 id="4-2因特网的核心部分"><a href="#4-2因特网的核心部分" class="headerlink" title="4.2因特网的核心部分"></a>4.2因特网的核心部分</h3><p>1.由大量网络和连接这些网络的路由器组成。这部分是为边缘部分提供服务的（提供连通性和交换）<br>2.网络核心部分是因特网中最复杂的部分。<br>3.网络中的核心部分要向网络边缘中的大量主机提供连通性，使边缘部分中的任何一个主机都能够向其他主机通信（即传送或接收各种形式的数据）。<br>4.路由器是实现分组交换(packet switching)的关键构件，其任务是转发收到的分组，这是网络核心部分最重要的功能。<br>5.在网络核心部分起特殊作用的是路由器(router)。<br>路由器是实现分组交换(packet switching)的关键构件，其任务是转发收到的分组，这是网络核心部分最重要的功能  </p><ul><li>在路由器中的输入和输出端口之间没有直接连线  </li><li>路由器处理分组的过程是：  </li></ul><blockquote><p>把收到的分组先放入缓存（暂时存储）<br>查找转发表，找出到某个目的地址应从哪个端口转发；<br>把分组送到适当的端口转发出去。  </p></blockquote><h4 id="4-2-1-电路交换"><a href="#4-2-1-电路交换" class="headerlink" title="4.2.1  电路交换"></a>4.2.1  电路交换</h4><p>1.两部电话机只需要用一对电线就能够互相连接起来。<br>2.更多的电话机互相连通<br><img src="/2020/10/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89/7.png" alt="alt"></p><ul><li>5 部电话机两两相连，需 10 对电线。  </li><li>N 部电话机两两相连，需 N(N – 1)/2 对电线。  </li><li>当电话机的数量很大时，这种连接方法需要的电线对的数量与电话机数的平方成正比。  </li></ul><p>3.使用交换机<br><img src="/2020/10/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89/8.png" alt="alt"><br>当电话机的数量增多时，就要使用交换机来完成全网的交换任务。  </p><p>4.电路交换的特点<br>电路交换必定是面向连接的。<br>电路交换的三个阶段：  </p><ul><li>建立连接  </li><li>通信  </li><li>释放连接  </li></ul><p>电路交换传送计算机数据效率低  </p><ul><li>计算机数据具有突发性。  </li><li>这导致通信线路的利用率很低。  </li></ul><h4 id="4-2-2-分组交换"><a href="#4-2-2-分组交换" class="headerlink" title="4.2.2 分组交换"></a>4.2.2 分组交换</h4><p>1.在发送端，先把较长的报文划分成较短的、固定长度的数据段。<br><img src="/2020/10/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89/9.png" alt="alt"><br>2.添加首部构成分组  </p><ul><li>每一个数据段前面添加上首部构成分组  </li></ul><p>3.分组交换的传输单元  </p><ul><li>分组交换网以“分组”作为数据传输单元。  </li><li>依次把各分组发送到接收端（假定接收端在左边）  </li></ul><p>4.分组首部的重要性  </p><ul><li>每一个分组的首部都含有地址等控制信息。  </li><li>分组交换网中的结点交换机根据收到的分组的首部中的地址信息，把分组转发到下一个结点交换机。  </li><li>用这样的存储转发方式，最后分组就能到达最终目的地。  </li></ul><p>5.收到分组后剥去首部  </p><ul><li>接收端收到分组后剥去首部还原成报文  </li></ul><p>6.分组交换的优点  </p><ul><li>高效    动态分配传输带宽，对通信链路是逐段占用。  </li><li>灵活    以分组为传送单位和查找路由。  </li><li>迅速    不必先建立连接就能向其他主机发送分组。  </li><li>可靠    保证可靠性的网络协议；分布式的路由选择协议使网络有很好的生存性。  </li></ul><p>7.分组交换带来的问题  </p><ul><li>分组在各结点存储转发时需要排队，这就会造成一定的时延。  </li><li>分组必须携带的首部（里面有必不可少的控制信息）也造成了一定的开销。  </li></ul><h4 id="4-2-3-三种交换的比较"><a href="#4-2-3-三种交换的比较" class="headerlink" title="4.2.3 三种交换的比较"></a>4.2.3 三种交换的比较</h4><p><img src="/2020/10/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89/10.png" alt="alt">  </p><h2 id="5、计算机网络的性能"><a href="#5、计算机网络的性能" class="headerlink" title="5、计算机网络的性能"></a>5、计算机网络的性能</h2><h3 id="5-1-计算机网络的性能指标"><a href="#5-1-计算机网络的性能指标" class="headerlink" title="5.1 计算机网络的性能指标"></a>5.1 计算机网络的性能指标</h3><p>1.速率  </p><ul><li>比特（bit）是计算机中数据量的单位，也是信息论中使用的信息量的单位。  </li><li>Bit 来源于 binary digit，意思是一个“二进制数字”，因此一个比特就是二进制数字中的一个 1 或 0。  </li><li>速率即数据率(data rate)或比特率(bit rate)是计算机网络中最重要的一个性能指标。速率的单位是 b/s，或kb/s, Mb/s, Gb/s 等  </li><li>速率往往是指额定速率或标称速率。  </li></ul><p>2.带宽</p><ul><li>“带宽”(bandwidth)本来是指信号具有的频带宽度，单位是赫（或千赫、兆赫、吉赫等）。  </li><li>现在“带宽”是数字信道所能传送的“最高数据率”的同义语，单位是“比特每秒”，或 b/s (bit/s)。  </li><li>常用的带宽单位  </li></ul><blockquote><p>更常用的带宽单位是<br>千比每秒，即 kb/s （103 b/s）<br>兆比每秒，即 Mb/s（106 b/s）<br>吉比每秒，即 Gb/s（109 b/s）<br>太比每秒，即 Tb/s（1012 b/s）<br>请注意：在计算机界，K = 210 = 1024    M = 220, G = 230, T = 240。  </p></blockquote><p>3.数字信号流随时间的变化  </p><ul><li>在时间轴上信号的宽度随带宽的增大而变窄。  </li></ul><p><img src="/2020/10/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89/13.png" alt="alt">  </p><p>4.吞吐量  </p><ul><li>吞吐量(throughput)表示在单位时间内通过某个网络（或信道、接口）的数据量。  </li><li>吞吐量更经常地用于对现实世界中的网络的一种测量，以便知道实际上到底有多少数据量能够通过网络。  </li><li>吞吐量受网络的带宽或网络的额定速率的限制。  </li></ul><p>5.时延(delay 或 latency)  </p><ul><li><p>传输时延（发送时延 ）    发送数据时，数据块从结点进入到传输媒体所需要的时间。  </p></li><li><p>发送时延也就是从发送数据帧的第一个比特算起，到该帧的最后一个比特发送完毕所需的时间。<br><img src="/2020/10/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89/14.png" alt="alt">  </p></li><li><p>传播时延    电磁波在信道中需要传播一定的距离而花费的时间。<br><img src="/2020/10/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89/15.png" alt="alt">  </p></li><li><p>信号传输速率（即发送速率）和信号在信道上的传播速率是完全不同的概念。  </p></li><li><p>处理时延    交换结点为存储转发而进行一些必要的处理所花费的时间。  </p></li><li><p>排队时延    结点缓存队列中分组排队所经历的时延。  </p></li><li><p>排队时延的长短往往取决于网络中当时的通信量。  </p></li><li><p>数据经历的总时延就是发送时延、传播时延、处理时延和排队时延之和：  </p></li></ul><p>6.时延带宽积<br><img src="/2020/10/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89/16.png" alt="alt">  </p><ul><li>链路的时延带宽积又称为以比特为单位的链路长度。  </li></ul><p>7.利用率  </p><ul><li>信道利用率指出某信道有百分之几的时间是被利用的（有数据通过）。完全空闲的信道的利用率是零。  </li><li>网络利用率则是全网络的信道利用率的加权平均值。  </li><li>信道利用率并非越高越好。  </li></ul><p>8.时延与网络利用率的关系<br><img src="/2020/10/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89/17.png" alt="alt">  </p><ul><li>根据排队论的理论，当某信道的利用率增大时，该信道引起的时延也就迅速增加。  </li><li>若令 D0 表示网络空闲时的时延，D 表示网络当前的时延，则在适当的假定条件下，可以用下面的简单公式表示 D 和 D0之间的关系：（U 是网络的利用率，数值在 0 到 1 之间。 ）<br><img src="/2020/10/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89/18.png" alt="alt">  </li></ul><h3 id="5-2-计算机网络的非性能特征"><a href="#5-2-计算机网络的非性能特征" class="headerlink" title="5.2 计算机网络的非性能特征"></a>5.2 计算机网络的非性能特征</h3><ul><li>费用  </li><li>质量  </li><li>标准化  </li><li>可靠性  </li><li>可扩展性和可升级性  </li><li>易于管理和维护  </li></ul><h2 id="6、计算机网络的体系结构"><a href="#6、计算机网络的体系结构" class="headerlink" title="6、计算机网络的体系结构"></a>6、计算机网络的体系结构</h2><p><img src="/2020/10/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89/19.png" alt="alt">  </p><p>1.计算机网络体系结构的形成  </p><ul><li>相互通信的两个计算机系统必须高度协调工作才行，而这种“协调”是相当复杂的。  </li><li>“分层”可将庞大而复杂的问题，转化为若干较小的局部问题，而这些较小的局部问题就比较易于研究和处理。  </li><li>两种国际标准  </li></ul><blockquote><p>法律上的(de jure)国际标准 OSI 并没有得到市场的认可。<br>是非国际标准 TCP/IP 现在获得了最广泛的应用。<br>TCP/IP 常被称为事实上的(de facto) 国际标准。  </p></blockquote><ul><li>关于开放系统互连参考模型OSI/RM  </li></ul><blockquote><p>只要遵循 OSI 标准，一个系统就可以和位于世界上任何地方的、也遵循这同一标准的其他任何系统进行通信。<br>在市场化方面 OSI 却失败了。<br>OSI 的专家们在完成 OSI 标准时没有商业驱动力；<br>OSI 的协议实现起来过分复杂，且运行效率很低；<br>OSI 标准的制定周期太长，因而使得按 OSI 标准生产的设备无法及时进入市场；<br>OSI 的层次划分并也不太合理，有些功能在多个层次中重复出现。  </p></blockquote><p>2.协议与划分层次  </p><ul><li>划分层次的必要性  </li></ul><blockquote><p>计算机网络中的数据交换必须遵守事先约定好的规则。<br>这些规则明确规定了所交换的数据的格式以及有关的同步问题（同步含有时序的意思）<br>网络协议(network protocol)，简称为协议，是为进行网络中的数据交换而建立的规则、标准或约定。  </p></blockquote><ul><li>网络协议的组成要素  </li></ul><blockquote><p>语法     数据与控制信息的结构或格式 。<br>语义     需要发出何种控制信息，完成何种动作以及做出何种响应。<br>同步    事件实现顺序的详细说明。  </p></blockquote><ul><li>分层的好处  </li></ul><blockquote><p>各层之间是独立的。<br>灵活性好。<br>结构上可分割开。<br>易于实现和维护。<br>能促进标准化工作。</p></blockquote><p>3.具有五层协议的体系结构  </p><p><img src="/2020/10/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89/20.png" alt="alt">  </p><ul><li>TCP/IP 是四层的体系结构：应用层、运输层、网际层和网络接口层。但最下面的网络接口层并没有具体内容。  </li><li>因此往往采取折中的办法，即综合 OSI 和 TCP/IP 的优点，采用一种只有五层协议的体系结构 。  </li></ul><p><img src="/2020/10/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89/21.png" alt="alt">  </p><p>4.实体、协议、服务和服务访问点  </p><ul><li>实体(entity) 表示任何可发送或接收信息的硬件或软件进程。  </li><li>协议是控制两个对等实体进行通信的规则的集合。  </li><li>在协议的控制下，两个对等实体间的通信使得本层能够向上一层提供服务。  </li><li>要实现本层协议，还需要使用下层所提供的服务。  </li><li>本层的服务用户只能看见服务而无法看见下面的协议。  </li><li>下面的协议对上面的服务用户是透明的。  </li><li>协议是“水平的”，即协议是控制对等实体之间通信的规则。  </li><li>服务是“垂直的”，即服务是由下层向上层通过层间接口提供的。  </li><li>同一系统相邻两层的实体进行交互的地方，称为服务访问点 SAP (Service Access Point)。  </li><li>协议必须把所有不利的条件事先都估计到，而不能假定一切都是正常的和非常理想的。  </li><li>看一个计算机网络协议是否正确，不能光看在正常情况下是否正确，而且还必须非常仔细地检查这个协议能否应付各种异常情况。 </li></ul>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;计算机网络概述&quot;&gt;&lt;a href=&quot;#计算机网络概述&quot; class=&quot;headerlink&quot; title=&quot;计算机网络概述&quot;&gt;&lt;/a&gt;计算机网络概述&lt;/h1&gt;&lt;h2 id=&quot;1、计算机网络在信息时代中的作用&quot;&gt;&lt;a href=&quot;#1、计算机网络在信息时代中的作用&quot; class=&quot;headerlink&quot; title=&quot;1、计算机网络在信息时代中的作用&quot;&gt;&lt;/a&gt;1、计算机网络在信息时代中的作用&lt;/h2&gt;&lt;p&gt;1.21 世纪的一些重要特征就是数字化、网络化和信息化，它是一个以网络为核心的信息时代。&lt;br&gt;2.网络现已成为信息社会的命脉和发展知识经济的重要基础。&lt;br&gt;3.网络是指“三网”，即电信网络、有线电视网络和计算机网络。&lt;br&gt;4.发展最快的并起到核心作用的是计算机网络。&lt;br&gt;5.因特网(Internet)的发展&lt;br&gt;进入 20 世纪 90 年代以后，以因特网为代表的计算机网络得到了飞速的发展。&lt;/p&gt;
&lt;p&gt;已从最初的教育科研网络逐步发展成为商业网络。  &lt;/p&gt;
&lt;p&gt;已成为仅次于全球电话网的世界第二大网络。  &lt;/p&gt;</summary>
    
    
    
    
    <category term="计算机网络" scheme="http://yoursite.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>数据库学习笔记(一)</title>
    <link href="http://yoursite.com/2020/09/29/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E7%AC%AC%E4%B8%80%E7%AF%87/"/>
    <id>http://yoursite.com/2020/09/29/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E7%AC%AC%E4%B8%80%E7%AF%87/</id>
    <published>2020-09-29T10:59:59.725Z</published>
    <updated>2020-09-29T12:14:54.431Z</updated>
    
    <content type="html"><![CDATA[<h1 id="数据库管理三个阶段"><a href="#数据库管理三个阶段" class="headerlink" title="数据库管理三个阶段"></a>数据库管理三个阶段</h1><ul><li>人工管理阶段  </li><li>文件系统阶段</li><li>数据库系统阶段   </li></ul><a id="more"></a>    <h1 id="基本术语"><a href="#基本术语" class="headerlink" title="基本术语"></a>基本术语</h1><ul><li>数据（Data）<blockquote><p>计算机用来描述事物的记录（文字、图形、图像、声音）<br>数据的形式本身并不能完全表达其内容，需要经过语义解释。数据与其语义是不可分的  </p></blockquote></li><li>数据库（Database，简称DB）  <blockquote><p>数据库是长期存储在计算机内，有结构的大量的可共享的数据集合  </p></blockquote></li><li>数据库管理系统（DBMS）  <blockquote><p>数据库管理系统是位于用户与操作系统之间的一层数据管理软件。<br>数据库在建立、运用和维护时由数据库管理系统统一管理、统一控制。  </p></blockquote></li><li>数据库系统（DBS）  <blockquote><p>数据库系统是指在计算机系统中引入数据库后的系统构成，一般由数据库、数据库管理系统（及其开发工具）、应用系统、数据库管理员和用户构成。  </p></blockquote></li><li>数据冗余度  <blockquote><p>指同一数据重复存储时的重复程度。   </p></blockquote></li><li>数据的安全性（Security）  <blockquote><p>数据的安全性是指保护数据，防止不合法使用数据造成数据的泄密和破坏，使每个用户只能按规定，对某些数据以某些方式进行访问和处理。   </p></blockquote></li><li>数据的完整性（Integrity）  <blockquote><p>数据的完整性指数据的正确性、有效性和相容性。即将数据控制在有效的范围内，或要求数据之间满足一定的关系  </p></blockquote></li><li>并发控制（Concurrency）   <blockquote><p>当多个用户的并发进程同时存取、修改数据库时，可能会发生相互干扰而得到错误的结果并使得数据库的完整性遭到破坏，因此必须对多用户的并发操作加以控制和协调。  </p></blockquote></li><li>数据库恢复（Recovery）  <blockquote><p>当多个用户的并发进程同时存取、修改数据库时，可能会发生相互干扰而得到错误的结果并使得数据库的完整性遭到破坏，因此必须对多用户的并发操作加以控制和协调。  </p></blockquote><h1 id="数据库的三要素"><a href="#数据库的三要素" class="headerlink" title="数据库的三要素"></a>数据库的三要素</h1></li><li>数据（描述事物的符号记录，数据库里面存储的内容）   </li><li>存储器（外存，一般是硬盘，数据库的载体）  </li><li>数据库管理系统（DBMS，数据库的管理软件）  </li></ul><h1 id="数据模型"><a href="#数据模型" class="headerlink" title="数据模型"></a>数据模型</h1><ul><li>模型  <blockquote><p>是现实世界特征的模拟和抽象  </p></blockquote></li><li>数据模型  <blockquote><p>也是一种模型，它是现实世界数据特征的抽象，表示实体以及实体间的联系<br>一个用于描述数据、数据间关系、数据语义和数据约束的概念工具的集合  </p></blockquote></li><li>两级模型的抽象  <blockquote><p>概念模型  </p><blockquote><p>（也称信息模型，用于信息世界的建模），它是按用户的观点来对数据和信息建模，主要用于数据库设计。这类模型强调其语义表达能力，要能够较方便、直接地表达应用中的各种语义知识，这类模型应为概念简单、清晰、易于用户理解，是用户和数据库设计人员之间进行交流的语言  </p></blockquote></blockquote></li></ul><blockquote><p>数据模型  </p><blockquote><p>（如层次、网状、关系模型，用于机器世界），它是按计算机系统的观点对数据建模，主要用于DBMS的实现。这类模型通常需要有严格的形式化定义，而且常常会加上一些限制或规定，以便于机器上的实现。还通常有一组严格定义了语法和语义的语言，人们可以使用它来定义、操纵数据库中的数据。  </p></blockquote></blockquote><ul><li>数据模型的三要素  <blockquote><p>（1） 数据结构  </p><blockquote><p>数据结构是所研究的对象类型（Object Type）的集合。这些对象是数据库的组成部分。一般可分为两类：一类是与数据类型、内容、性质有关的对象，如网状模型中的数据项、记录，关系模型中的属性、关系等；一类是与数据之间联系有关的对象，如网状模型中的系型（Set Type）等。  </p></blockquote></blockquote></li></ul><blockquote><p>（2） 数据操作  </p><blockquote><p>数据操作是指对数据库中各种对象（型）的实例（值）允许执行的操作的集合。数据库主要有检索和更新（插入、删除、修改）两大类操作。<br> 数据结构是对系统静态特性的描述，数据操作是对系统动态特性的描述。  </p></blockquote></blockquote><blockquote><p>（3） 数据的约束条件  </p><blockquote><p>数据的约束条件是完整性规则的集合。完整性规则是给定的数据模型中数据及其联系所具有的制约和依存规则，用以限定符合数据模型的数据状态以及状态的变化，以保证数据的正确、有效、相容。  </p></blockquote></blockquote><ul><li>概念模型  <blockquote><p>实体（Entity）  </p><blockquote><p>客观存在并可相互区别的事物称为实体。实体可以是具体的人、事、物，也可以是抽象的概念或联系，如学生、部门、课程、银行帐户、选课、订货、演出、比赛等。  </p></blockquote></blockquote></li></ul><blockquote><p>属性（Attribute）  </p><blockquote><p>实体所具有的某一特性称为属性。如学生实体可以由学号、姓名、性别、出生年月、系、入学时间等属性组成  </p></blockquote></blockquote><blockquote><p>码（关键字，Key）  </p><blockquote><p>唯一标识实体的（最小的）属性集称为码。例如学号学生实体的码  </p></blockquote></blockquote><blockquote><p>域（Domain）  </p><blockquote><p>属性的取值范围称为该属性的域。例如学号的域为8位整数，姓名的域为字符串集合，，性别的域为（男，女）。  </p></blockquote></blockquote><blockquote><p>实体型（Entity Type）  </p><blockquote><p>具有相同属性的实体必然具有共同的特征和性质。用实体名及其属性名集合来抽象和刻划同类实体，称为实体型。例如：学生（学号，姓名，性别，出生年月，系，入学时间）  </p></blockquote></blockquote><blockquote><p>实体集（Entity Set）  </p><blockquote><p>同型实体的集合称为实体集。例如，全体学生就是一个实体集。  </p></blockquote></blockquote><blockquote><p>联系（Relationship）  </p><blockquote><p>在现实世界中，事物内部以及事物之间是有联系的，这些联系在信息世界中反映为实体（型）内部的联系和实体（型）之间的联系。〖组成实体的各属性之间以及不同实体集之间的联系〗  </p></blockquote></blockquote><h1 id="联系的种类"><a href="#联系的种类" class="headerlink" title="联系的种类"></a>联系的种类</h1><ul><li>1对1联系  <blockquote><p>定义：若对于实体集A中的每一个实体，实体集B中至多有一个实体与之联系，反之亦然，则称实体集A与实体集B具有一对一联系，记为1:1。  </p></blockquote></li><li>1对多联系  <blockquote><p>定义：若对于实体集A中的每一个实体，实体集B中有n个实体(n≥0)与之联系，反之，对于对于实体集B中的每一个实体，实体集A中至多只有一个实体与之联系，则称实体集A与实体集B具有一对多联系，记为1:n  </p></blockquote></li><li>多对多联系  <blockquote><p>定义：若对于实体集A中的每一个实体，实体集B中有n个实体(n≥0)与之联系，反之，对于对于实体集B中的每一个实体，实体集A中也有m个实体(m≥0)与之联系，则称实体集A与实体集B具有多对多联系，记为m:n  </p></blockquote></li></ul><h1 id="概念模型的表示方法"><a href="#概念模型的表示方法" class="headerlink" title="概念模型的表示方法"></a>概念模型的表示方法</h1><ul><li>E-R图  <blockquote><p>使用长方形来表示实体型，框内写上实体名<br>椭圆型表示实体的属性，并用无向边把实体和属性连接起来<br>用菱形表示实体间的联系，菱形框内写上联系名，用无向边把菱形分别与有关实体相连接，在无向边旁标上联系的类型，若实体之间联系也具有属性，则把属性和菱形也用无向边连接上  </p></blockquote></li></ul><h1 id="基本数据模型"><a href="#基本数据模型" class="headerlink" title="基本数据模型"></a>基本数据模型</h1><ul><li><p>层次模型(Hierarchical Model)  </p><blockquote><p>最早使用的一种模型<br>数据结构是一棵有向树<br>特点  </p><blockquote><p>(1) 有且仅有一个结点无双亲，该结点称为根结点。<br>(2) 其他结点有且只有一个双亲  </p></blockquote></blockquote></li><li><p>网状模型(Network Model)  </p><blockquote><p>数据结构是一个有向图<br>能表示实体之间的多种复杂联系<br>特点  </p><blockquote><p>（1）有一个以上的结点没有双亲<br>（2）结点可以有多于一个的双亲  </p></blockquote></blockquote></li><li><p>关系模型(Relational Model)  </p><blockquote><p>关系模型是用二维表格结构来表示实体及实体之间的联系的模型<br>数据结构是一个“二维表框架”组成的集合<br>关系模型概念简单,清晰,用户易懂易用,有严格的数学基础<br>大多数数据库系统都是关系型的<br>主要术语  </p><blockquote><p>关系：一个关系对应于我们平常讲的一张表<br>元组：表中的一行称为一个元组<br>属性：表中的一列称为属性，每列的名称为属性名<br>主码：表中的某个属性组，它们的值唯一的标识一个元组<br>域：属性的取值范围<br>分量：元组中的一个属性值<br>关系模式：对关系的描述，用关系名（属性名1，属性名2，…，属性名n）来表示  </p></blockquote></blockquote></li></ul><blockquote><p>特点  </p><blockquote><ol><li>概念单一：<br>实体或实体之间的联系都用关系表示<br>用户的观点里，数据的逻辑结构就是表  </li><li>关系必须是规范化的关系<br>指在关系模型中，每一个关系模式要满足一定的要求或者称为规范条件<br>其最基本的要求是每一个分量是一个不可分的数据项，也就是说，不允许表中还有表。  </li><li>用户对数据的检索操作不过是从原来的表中得到一张新的表<br>在用户眼中，无论是原始数据还是结果数据，都是同一种数据结构——二维表。<br>数据操作是集合操作，即操作对象和操作结果都是若干元组的集合，而不象非关系模型中那样单记录的操作方式。<br>把存取路径向用户隐藏起来，提高了数据的独立性。 </li></ol></blockquote></blockquote><h1 id="数据库系统的体系结构"><a href="#数据库系统的体系结构" class="headerlink" title="数据库系统的体系结构"></a>数据库系统的体系结构</h1><ul><li>三层模式：外模式、模式、内模式   <blockquote><p>外模式  </p><blockquote><p>又称为用户模式，是数据库用户和数据库系统的接口，是数据库用户的数据视图，是数据库用户可以看见和使用的局部数据的逻辑结构和特征的描述<br>一个数据库通常都有多个外模式。一个应用程序只能使用一个外模式，但同一外模式可为多个应用程序所用  </p></blockquote></blockquote></li></ul><blockquote><p>模式</p><blockquote><p>可细分为概念模式和逻辑模式，是所有数据库用户的公共数据视图，是数据库中全部数据的逻辑结构和特征的描述。<br>一个数据库只有一个模式。模式不但要描述数据的逻辑结构，还要描述数据之间的联系、数据的完整性、安全性要求  </p></blockquote></blockquote><blockquote><p>内模式  </p><blockquote><p>又称为存储模式，是数据库物理结构和存储方式的描述，是数据在数据库内部的表示方式。<br>一个数据库只有一个内模式。内模式并不涉及物理记录，也不涉及硬件设备。  </p></blockquote></blockquote><ul><li>二层映象功能：外模式/模式映象和模式/内模式映象   <blockquote><p>三层模式关系  </p><blockquote><p>数据库模式是数据库的核心和关键，外模式通常是模式的子集。数据按外模式的描述提供给用户，按内模式的描述存储在硬盘上，而模式介于外、内模式之间，既不涉及外部的访问，也不涉及内部的存储，从而起到隔离作用，有利于保持数据的独立性，内模式依赖于全局逻辑结构，但可以独立于具体的存储设备  </p></blockquote></blockquote></li></ul><blockquote><p>映象  </p><blockquote><p>是一种对应规则，说明映象双方如何进行转换。   </p></blockquote></blockquote><blockquote><p>外模式/模式映象  </p><blockquote><p>作用：把描述局部逻辑结构的外模式与描述全局逻辑结构的模式联系趣来<br>当模式改变时，只要对外模式/模式映象做相应的改变，使外模式保持不变，则以外模式为依据的应用程序不受影响，从而保证了数据与程序之间的逻辑独立性，也就是数据的逻辑独立性   </p></blockquote></blockquote><blockquote><p>模式/内模式映象  </p><blockquote><p>作用：把描述全局逻辑结构的模式与描述物理结构的内模式联系起来<br>当内模式改变时，比如存储设备或存储方式有所改变，只要模式/内模式映象做相应的改变，使模式保持不变，则应用程序就不受影响，从而保证了数据与程序之的物理独立性。</p></blockquote></blockquote>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;数据库管理三个阶段&quot;&gt;&lt;a href=&quot;#数据库管理三个阶段&quot; class=&quot;headerlink&quot; title=&quot;数据库管理三个阶段&quot;&gt;&lt;/a&gt;数据库管理三个阶段&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;人工管理阶段  &lt;/li&gt;
&lt;li&gt;文件系统阶段&lt;/li&gt;
&lt;li&gt;数据库系统阶段   &lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    
    <category term="数据库" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>java 基础库类</title>
    <link href="http://yoursite.com/2020/09/17/java%E5%9F%BA%E7%A1%80%E5%BA%93%E7%B1%BB/"/>
    <id>http://yoursite.com/2020/09/17/java%E5%9F%BA%E7%A1%80%E5%BA%93%E7%B1%BB/</id>
    <published>2020-09-17T13:15:21.168Z</published>
    <updated>2020-09-22T12:14:12.085Z</updated>
    
    <content type="html"><![CDATA[<h1 id="java基础库类"><a href="#java基础库类" class="headerlink" title="java基础库类"></a>java基础库类</h1><h2 id="Main类"><a href="#Main类" class="headerlink" title="Main类"></a>Main类</h2><blockquote><p> JVM运行Java应用程序的时候，首先会调用main方法<br>  调用时不实例化这个类的对象,而是通过类名直接调用<br>  因此需要是限制为public static<br> main()方法定义：“public static void main(String[]  字符串数组参数名)”<br>  jvm有限制，不能有返回值，因此返回值类型为void</p></blockquote><hr><a id="more"></a>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public class Main  &#123;</span><br><span class="line">&#x2F;&#x2F;主方法入口</span><br><span class="line">public static void main(String[] args)&#123;</span><br><span class="line">    </span><br><span class="line">&#x2F;&#x2F;输出args数组的长度</span><br><span class="line">    System.out.println(args.length);</span><br><span class="line">    System.out.println(&quot;打印main方法中的输出参数&quot;);</span><br><span class="line"></span><br><span class="line">    for (int i&#x3D;0;i&lt;args.length;i++)&#123;</span><br><span class="line">    System.out.println(args[i]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Object类"><a href="#Object类" class="headerlink" title="Object类"></a>Object类</h2><blockquote><p>  Object类在java.lang包中<br>    所有Java类都直接或间接扩展Object类<br>     所有Java类都是Object类的子类Object类是所有类的超类<br>       Object类本身没有超类<br>        Object类的引用变量可以保存任何类的对象的引用</p></blockquote><h3 id="Object类方法"><a href="#Object类方法" class="headerlink" title="Object类方法"></a>Object类方法</h3><ul><li>public String toString()<br>我们可以自定义它， 它返回对象的字符串表示形式 通常它用于调试目的<br>如果类中未重写该方法，则输出：”类名@十六进制的hashcode值”，若重写，则输出表述该对象信息的字符串</li><li>System.out.println(xx)<br>括号里面的“xx”对象如果不是String类型的话，就自动调用xx的toString()方法</li><li>public boolean equals(Object obj)<br> 它用于比较两个对象的相等性</li><li>public int hashCode()<br>它返回对象的哈希码（整数）值, 根据一定的规则将与对象相关的信息（比如对象的存储地址，对象的字段等）映射成一个数值，这个数值称作为散列值</li><li>protected void finalize() throws Throwable<br>它不是在Object类中实现 它在对象被销毁之前被垃圾收集器调用。</li><li>public final Class getClass()<br>它返回对象的Class对象的引用即可以返回对象的父类等相关信息</li></ul><hr><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">public class ObjectTest &#123;</span><br><span class="line"></span><br><span class="line">    public static void main (String[] args)&#123;</span><br><span class="line"></span><br><span class="line">        String strObj &#x3D; new String();</span><br><span class="line">        ObjectTest obj &#x3D; new ObjectTest();</span><br><span class="line"></span><br><span class="line">        printClassInfo(strObj);</span><br><span class="line">        printClassInfo(obj);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        String str1 &#x3D;new String(&quot;123456&quot;);</span><br><span class="line">        &#x2F;&#x2F;调用hasCode方法输出对象的哈希值</span><br><span class="line">        System.out.println(&quot;str字符串的哈希值为：&quot;+str1.hashCode());</span><br><span class="line">        equalsTest(str1);</span><br><span class="line">        &#x2F;&#x2F;调用toString方法返回str对象的字符串形式</span><br><span class="line">        System.out.println(&quot;返回str对象的字符串形式：&quot;+str1.toString());</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;定义一个printClassInfo()方法来描述getClass()方法</span><br><span class="line">    private static void printClassInfo(Object obj) &#123;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;获取类名</span><br><span class="line">        System.out.println(&quot;类名：&quot; + obj.getClass().getName());</span><br><span class="line">        &#x2F;&#x2F;获取父类名</span><br><span class="line">        System.out.println(&quot;父类：&quot;+obj.getClass().getSuperclass().getName());</span><br><span class="line">        &#x2F;&#x2F;获取接口信息并输出</span><br><span class="line">        for (int i &#x3D; 0; i &lt; obj.getClass().getInterfaces().length; i++) &#123;</span><br><span class="line">            System.out.println(obj.getClass().getInterfaces()[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;定义一个equalsTest方法来描述equals()方法</span><br><span class="line">    public static boolean equalsTest(String str)&#123;</span><br><span class="line">        String passworld &#x3D; &quot;123456&quot;;</span><br><span class="line">        boolean con;</span><br><span class="line">        if (str.equals(passworld)) con &#x3D; true;</span><br><span class="line">        else&#123;</span><br><span class="line">            con&#x3D;false;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(con);</span><br><span class="line">        return  con;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="String-StringBuffer-StringBuilder类"><a href="#String-StringBuffer-StringBuilder类" class="headerlink" title="String StringBuffer StringBuilder类"></a>String StringBuffer StringBuilder类</h2><blockquote><p>String 类一旦创建将不会改变<br>与String 类不同的是，StringBuffer 和 StringBuilder 类的对象能够被多次的修改，并且不产生新的未使用对象<br>tringBuffer用法和StringBuilder一样，不过，StringBuffer是线程安全的<br> StringBuilder 相较于 StringBuffer 有速度优势，所以多数情况下建议使用 StringBuilder类</p></blockquote><h3 id="String类方法"><a href="#String类方法" class="headerlink" title="String类方法"></a>String类方法</h3><ul><li><p>char charAt(int index)<br>取字符串中的某一个字符，其中的参数index指的是字符串中序数。<br>字符串的序数从0开始到length()-1    </p></li><li><p>int compareTo(String anotherString)<br>当前String对象与anotherString比较<br>相等关系返回０；不相等时，从两个字符串第0个字符开始比较，返回第一个不相等的字符差<br>另一种情况，较长字符串的前面部分恰巧是较短的字符串，返回它们的长度差  </p><hr><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">public class StringTest &#123;</span><br><span class="line"></span><br><span class="line">    private static String str;</span><br><span class="line"></span><br><span class="line">    public static void main (String[] args)&#123;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;创建字符串</span><br><span class="line">        String greeting &#x3D;&quot;hello world&quot;;</span><br><span class="line">        System.out.println(greeting);</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;string和StringBuffer类的相互转换</span><br><span class="line">        &#x2F;&#x2F;注意：可以&#x3D;解决scanner类输入字符串进行修改的问题</span><br><span class="line">        String aa &#x3D;new String(&quot;123456&quot;);</span><br><span class="line">        StringBuilder bb &#x3D; new  StringBuilder(aa);</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;初始化字符转</span><br><span class="line">        char [] helloArray &#x3D; &#123;&#39;a&#39;,&#39;b&#39;,&#39;c&#39;&#125;;</span><br><span class="line">        String arrayTest &#x3D; new String(helloArray);</span><br><span class="line">        System.out.println(arrayTest);</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;输出字符串的长度</span><br><span class="line">        System.out.println(arrayTest.length());</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;取字符串中的特定字符</span><br><span class="line">        System.out.println(arrayTest.charAt(1));</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;将两个字符串进行比较</span><br><span class="line">        String str1 &#x3D; new String(&quot;i love cat&quot;);</span><br><span class="line">        String str2 &#x3D; new String(&quot;i love cat&quot;);</span><br><span class="line">        String str3 &#x3D; new String(&quot;i love cat and dogs&quot;);</span><br><span class="line">        System.out.println(str1.compareTo(str2));</span><br><span class="line">        System.out.println(str1.compareTo(str3));</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;连接两个字符串的方法</span><br><span class="line">        String str4 &#x3D;&quot;我的github网站：&quot;;</span><br><span class="line">        String str5 &#x3D;&quot;https:&#x2F;&#x2F;github.com&#x2F;hermit-rain&quot;;</span><br><span class="line">        System.out.println(str1.concat(str2));</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;描述StringBuilder类中主要使用的方法</span><br><span class="line">        StringBuilder str6 &#x3D; new StringBuilder(&quot;hello &quot;);</span><br><span class="line">        &#x2F;&#x2F;追加</span><br><span class="line">        System.out.println(str6.append(&quot;java&quot;));</span><br><span class="line">        &#x2F;&#x2F;反转</span><br><span class="line">        System.out.println(str6.reverse());</span><br><span class="line">        &#x2F;&#x2F;移除</span><br><span class="line">        System.out.println(str6.delete(1,3));</span><br><span class="line">        &#x2F;&#x2F;替换</span><br><span class="line">        System.out.println(str6.insert(0,&quot;hello java&quot;));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Scanner类"><a href="#Scanner类" class="headerlink" title="Scanner类"></a>Scanner类</h2><blockquote><p>Scanner类包括文件输入和字符输入两种格式<br>next无法读取空格 遇到空格即停止编译  nextLine可以识别空格并成功输出<br>注意：Scanner类只能返回String类的对象 不能返回StringBuffer类的对象,要想调用StringBuffer方法必须将String类型转化成StringBuffer类型</p></blockquote></li></ul><h3 id="Scanner类方法"><a href="#Scanner类方法" class="headerlink" title="Scanner类方法"></a>Scanner类方法</h3><ul><li>hasNext hasNextLine作为判断判否还有下一行输入  </li><li>next  nextLine 返回输入源中的下一行字符串</li></ul><hr><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">public class ScannerTest &#123;</span><br><span class="line">    public static void main(String[] args) throws FileNotFoundException &#123;</span><br><span class="line">        </span><br><span class="line">        &#x2F;&#x2F;创建Scanner类对象</span><br><span class="line">        Scanner scan &#x3D; new Scanner(System.in) ;</span><br><span class="line">     </span><br><span class="line">        &#x2F;&#x2F;用next返回输入源中的下一行字符串</span><br><span class="line">        if (scan.hasNext())&#123;</span><br><span class="line">            String str1 &#x3D;scan.next();</span><br><span class="line">            System.out.println(&quot;输出的数据是：&quot;+str1);</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F;用 nextLine返回输入源中的下一行字符串</span><br><span class="line">        if (scan.hasNextLine())&#123;</span><br><span class="line">            String str2 &#x3D; scan.nextLine();</span><br><span class="line">            System.out.println(&quot;输入字符串str2：&quot;+str2);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        scan.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="System类"><a href="#System类" class="headerlink" title="System类"></a>System类</h2><blockquote><p>System类中包括类有 3 个静态成员变量<br>分别是 PrintStream out、InputStream in 和 PrintStream err  </p></blockquote><h3 id="System类方法"><a href="#System类方法" class="headerlink" title="System类方法"></a>System类方法</h3><ul><li>arrayCopy() 方法 该方法的作用是数组复制，即从指定源数组中复制一个数组 </li><li>currentTimeMillis() 方法 该方法的作用是返回当前的计算机时间  </li><li>identityHashCode(Object x) 该方法返回指定对象的精确hashCode值  <blockquote><blockquote><p>identityHashCode(Object x)与hashCode()两种方法的区别<br>Object的hashCode()默认是返回内存地址的，但是hashCode()可以重写，所以hashCode()不能代表内存地址的不同<br>System.identityHashCode(Object x)方法可以返回对象的内存地址,不管该对象的类是否重写了hashCode()方法<br>该方法返回指定对象的精确hashCode值，也就是根据该对象的地址计算得到的hashCode值，可以唯一地标识一个对象<br>判断两个对象是否是指向同一地址，应该用System.identityHashCode(Object x)方法进行判断 </p></blockquote></blockquote></li></ul><hr><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">public class SystemTest &#123;</span><br><span class="line"></span><br><span class="line">    public static void main (String[] args)&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;类方法arrayCopy</span><br><span class="line">        &#x2F;&#x2F; public static void arraycopy(Object src,int srcPos,Object dest,int destPos,int length)</span><br><span class="line">        &#x2F;&#x2F;src 表示源数组，srcPos 表示从源数组中复制的起始位置，dest 表示目标数组，destPos 表示要复制到的目标数组的起始位置，length 表示复制的个数。</span><br><span class="line"></span><br><span class="line">        char[] srcArray &#x3D; &#123;&#39;A&#39;,&#39;B&#39;,&#39;C&#39;,&#39;D&#39;&#125;;</span><br><span class="line">        char[] destArray &#x3D; new char[4];</span><br><span class="line">        System.arraycopy(srcArray,1,destArray,1,2);</span><br><span class="line">        System.out.println(&quot;输出原数组：&quot;);</span><br><span class="line">        for (int i&#x3D;0;i&lt;srcArray.length;i++)&#123;</span><br><span class="line">            System.out.println(srcArray[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(&quot;输出目标数组&quot;);</span><br><span class="line">        for (int j&#x3D;0; j&lt;destArray.length; j++)&#123;</span><br><span class="line">            System.out.println(destArray[j]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;currentTimeMillis() 方法</span><br><span class="line">        &#x2F;&#x2F;该方法的作用是返回当前的计算机时间，</span><br><span class="line">        &#x2F;&#x2F; 时间的格式为当前计算机时间与 GMT 时间（格林尼治时间）1970 年 1 月 1 日 0 时 0 分 0 秒所差的毫秒数</span><br><span class="line">        long startTime &#x3D; System.currentTimeMillis();</span><br><span class="line">        System.out.println(startTime);</span><br><span class="line">        int i;</span><br><span class="line">        long trem&#x3D;0;</span><br><span class="line">        for (i&#x3D;0;i&lt;100000000;i++)&#123;</span><br><span class="line">            trem &#x3D; trem+i;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(trem);</span><br><span class="line">        long endTime &#x3D; System.currentTimeMillis();</span><br><span class="line">        long soTime&#x3D;endTime-startTime;</span><br><span class="line">        System.out.println(soTime);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; identityHashCode(Object x)与hashCode()方法返回相同的哈希值</span><br><span class="line">        String  str1&#x3D; &quot;hello&quot;;</span><br><span class="line">        String str2&#x3D; &quot;hello&quot;;</span><br><span class="line">        System.out.println(str1.hashCode()+&quot;--------&quot;+str2.hashCode());</span><br><span class="line">        System.out.println(System.identityHashCode(str1)+&quot;-----&quot;+System.identityHashCode(str2));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        String str3 &#x3D;new String(&quot;Hello&quot;);</span><br><span class="line">        String str4 &#x3D; new String(&quot;Hello&quot;);</span><br><span class="line">        &#x2F;&#x2F;不同对象通过重写的hashCode()方法返回的值可能相同</span><br><span class="line">        System.out.println(str3 .hashCode()+&quot;------&quot;+str4.hashCode());</span><br><span class="line">        &#x2F;&#x2F;因为str3和str4为两种不同的对象所以他们通过identityHashCode方法返回的内存地址不相同；</span><br><span class="line">        System.out.println(System.identityHashCode(str3)+&quot;-----&quot;+System.identityHashCode(str4));</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Math类"><a href="#Math类" class="headerlink" title="Math类"></a>Math类</h2><blockquote><p>提供了两个静态变量：PI和E，值分别为：π和e<br>包含了用于执行基本数学运算的属性和方法，如初等指数、对数、平方根和三角函数等<br>Math 的方法都被定义为 static 形式，通过 Math 类可以在主函数中直接调用</p></blockquote><hr><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">public class MathTest &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args)&#123;</span><br><span class="line">        int a, b;</span><br><span class="line">        a&#x3D;9;</span><br><span class="line">        b&#x3D;-10;</span><br><span class="line">        System.out.println(Math.abs(b));</span><br><span class="line">        &#x2F;&#x2F;计算乘方</span><br><span class="line">        System.out.println(Math.pow(a,b));</span><br><span class="line">        &#x2F;&#x2F;计算自然对数</span><br><span class="line">        System.out.println(Math.log(a));</span><br><span class="line">        &#x2F;&#x2F;找出最大值</span><br><span class="line">        System.out.println(Math.max(7,12));</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;输出90度的正弦值</span><br><span class="line">        &#x2F;&#x2F;调用Math中的静态变量PI</span><br><span class="line">        System.out.println(&quot;90度的正弦值为：&quot;+Math.sin(Math.PI&#x2F;2));</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Random类"><a href="#Random类" class="headerlink" title="Random类"></a>Random类</h2><blockquote><p>Random类专门用于生成一个随机数<br>它有两个构造器，一个是使用默认的种子（以当前时间为种子），另一个是显式传入一个long整型的种子<br>使用相同的种子可以产生相同的随机数<br>为了避免产生相同的随机数常推荐使用当前时间作为 Random对象的种子<br>Random  rand  = new  Random (System.currentTimeMills()) ;</p><blockquote><p>相比于Math的random()方法，Random类提供了更多的方式来生成各种伪随机数<br>既可以生成浮点类型的伪随机数，也可以生成整数类型的伪随机数，还可以指定生成随机数的范围<br>ThreadLocalRandom类是Random的增强版<br>在并发访问的环境下，使用ThreadLocalRandom来代替Random可以减少多线程资源竞争，保证线程安全<br>它提供了一个静态方法current( )方法来获取对象，然后调用各种nextXxx( ) 方法来获取各种基本类型的随机数</p></blockquote></blockquote><hr><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">public class RandomTest &#123;</span><br><span class="line"></span><br><span class="line">    public static void main (String[] args)&#123;</span><br><span class="line"></span><br><span class="line">        Random rand &#x3D; new Random();</span><br><span class="line">        &#x2F;&#x2F;随机产生布尔类型的随机数</span><br><span class="line">        System.out.println(rand.nextBoolean());</span><br><span class="line">        &#x2F;&#x2F; 生成0.0~1.0之间的伪随机double数</span><br><span class="line">        System.out.println(rand.nextDouble());</span><br><span class="line">        &#x2F;&#x2F; 生成一个处于int整数取值范围的伪随机整数</span><br><span class="line">        System.out.println(rand.nextInt());</span><br><span class="line">        &#x2F;&#x2F; 生成0~26之间的伪随机整数</span><br><span class="line">        System.out.println(rand.nextInt(26));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;使用相同的种子产生相同的随机数</span><br><span class="line">        Random rand1 &#x3D; new Random(50);</span><br><span class="line">        Random rand2 &#x3D; new Random(50);</span><br><span class="line">        System.out.println(rand1.nextInt());</span><br><span class="line">        System.out.println(rand2.nextInt());</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;使用当前时间作为种子产生随机数</span><br><span class="line">        Random rand3 &#x3D; new Random(System.currentTimeMillis());</span><br><span class="line">        Random rand4 &#x3D; new Random(System.currentTimeMillis()+1000);</span><br><span class="line">        System.out.println(rand3.nextInt());</span><br><span class="line">        System.out.println(rand4.nextInt());</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;通过ThreadLocalRandom类来生成随机数</span><br><span class="line">        ThreadLocalRandom rand5 &#x3D; ThreadLocalRandom.current();</span><br><span class="line">        ThreadLocalRandom rand6 &#x3D; ThreadLocalRandom.current();</span><br><span class="line">        int  val  &#x3D; rand5.nextInt(10);</span><br><span class="line">        long va2 &#x3D; (long) rand6.nextDouble(10.00);</span><br><span class="line">        System.out.println(val);+</span><br><span class="line">        System.out.println(va2);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Runtime类"><a href="#Runtime类" class="headerlink" title="Runtime类"></a>Runtime类</h2><blockquote><p>Runtime类描述Java程序的运行时环境<br>每个Java程序都有一个与之对应的Runtime实例<br>该类会被自动创建，我们可以通过Runtime.getRuntime() 方法来获取当前程序的Runtime实例。<br>应用程序通过该对象与其运行的环境相连接 可以访问JVM的相关信息，如处理器数量、内存信息等  </p></blockquote><h3 id="Runtime类方法"><a href="#Runtime类方法" class="headerlink" title="Runtime类方法"></a>Runtime类方法</h3><ul><li>public static Runtime getRuntime（）： 此方法返回与当前Java应用程序关联的实例或Runtime对象。  </li><li>public long freeMemory（）：此方法返回JVM（Java虚拟机）中的可用内存量  </li><li>public long totalMemory（）：此方法返回JVM（Java虚拟机）中的总内存量  </li><li>public long maxMemory（）：此方法返回Java虚拟机将尝试使用的最大内存量  </li><li>public Process exec（String command）抛出IOException：此方法在单独的进程中执行给定的命令  </li><li>public void gc（）：此方法运行垃圾收集器。调用此方法表明Java虚拟机花费了大量精力来回收未使用的对象，以使其当前占用的内存可用于快速重用  </li></ul><hr><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public class RuntimeTest &#123;</span><br><span class="line">    public static void main (String[] args) throws IOException &#123;</span><br><span class="line">        &#x2F;&#x2F;创建一个实例化对象</span><br><span class="line">        Runtime run &#x3D; Runtime.getRuntime();</span><br><span class="line">        &#x2F;&#x2F;调用Runtime中的方法获取jvm的相关信息</span><br><span class="line">        System.out.println(&quot;jvm中可用的内存数：&quot;+run.freeMemory());</span><br><span class="line">        System.out.println(&quot;jvm中总内存数：&quot;+run.totalMemory());</span><br><span class="line">        System.out.println(&quot;jvm尝试使用最大的内存数：&quot;+run.maxMemory());</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;通过exec方放来调用jvm单独启用一个进程来执行操作命令</span><br><span class="line">        run.exec(&quot;notepad.exe&quot;);</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;调用Runtime中gc()方法进行垃圾回收</span><br><span class="line">        run.gc();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Date类"><a href="#Date类" class="headerlink" title="Date类"></a>Date类</h2><blockquote><p>Data类共有两种构造器分别是无参和有参数的构造器  </p><blockquote><p>Date()   生成一个代表当前日期时间的对象<br>Date(long date) 根据指定的long型整数来生成一个Date对象  </p></blockquote></blockquote><h3 id="Date类方法"><a href="#Date类方法" class="headerlink" title="Date类方法"></a>Date类方法</h3><ul><li>boolean after(Date date)：判断当前日期是否在date之后  </li><li>boolean before(Date date)：判断当前日期是否在date之前  </li><li>long  getTime()：返回该时间对应的long型整数，即从1970年1月1日00:00:00到当前对象之间的时间差  </li><li>int compareTo(Date date)<br>比较当调用此方法的Date对象和指定日期<br>两者相等时候返回0，调用对象在指定日期之前则返回负数。调用对象在指定日期之后则返回正数  </li></ul><hr><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">public class DateTest &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args)&#123;</span><br><span class="line"></span><br><span class="line">        Date date &#x3D;new Date();</span><br><span class="line">        System.out.println(date.toString());</span><br><span class="line">        Date date1 &#x3D;new Date(System.currentTimeMillis());</span><br><span class="line">        &#x2F;&#x2F;注意参数的设置：  Date类的年份是以1900开头，以0月开头的；</span><br><span class="line">        Date date2 &#x3D; new Date(2020-1900,6-1,12);</span><br><span class="line">        System.out.println(date1);</span><br><span class="line">        System.out.println(date2);</span><br><span class="line">        &#x2F;&#x2F;返回当前时间对应的long型整数</span><br><span class="line">        System.out.println(date.getTime());</span><br><span class="line">        System.out.println(date.before(date2));</span><br><span class="line">        System.out.println(date.after(date2));</span><br><span class="line">        System.out.println(date.compareTo(date2));</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Calendar类"><a href="#Calendar类" class="headerlink" title="Calendar类"></a>Calendar类</h2><blockquote><p>Calendar类是一个抽象类，因此不能用构造器来创建对象，必须通过静态方法getInstance( )方法来获取Calendar对象<br>Calendar类可以直接对date的年份，月份或者日期进行更改</p><blockquote><p>roll以及add的区别<br>add方法的月份增加年份会进行递增<br>roll方法月份的增加只会自身进行循环</p></blockquote></blockquote><hr><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">public class CalendarTest &#123;</span><br><span class="line">    public static void main(String[] args)&#123;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 创建一个代表系统当前日期的Calendar对象</span><br><span class="line">        Calendar c1 &#x3D; Calendar.getInstance();</span><br><span class="line">        Date date &#x3D; c1.getTime();</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;创建一个指定时间的Calendar对象</span><br><span class="line">        Calendar c2 &#x3D;Calendar.getInstance();</span><br><span class="line">        c2.set(2008,9,3);</span><br><span class="line">        System.out.println(date);</span><br><span class="line">        System.out.println(c2.getTime());</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;取出某个时间对象的具体年份月份以及日</span><br><span class="line">        System.out.println(c2.get(Calendar.YEAR));</span><br><span class="line">        System.out.println(c2.get(Calendar.MONTH));</span><br><span class="line">        System.out.println(c2.get(Calendar.DATE));</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;更改年月日</span><br><span class="line">         c1.add(Calendar.YEAR,2);</span><br><span class="line">        &#x2F;&#x2F;添加的月份数满12个月后年份会自动增加一位</span><br><span class="line">         c1.add(Calendar.MONTH,10);</span><br><span class="line">        &#x2F;&#x2F; roll方法的月份增加只会改变月份，如果满12则会进行迭代</span><br><span class="line">         c2.roll(Calendar.MONTH,10);</span><br><span class="line">         c1.add(Calendar.DATE,10);</span><br><span class="line"></span><br><span class="line">        System.out.println(c1.get(Calendar.YEAR));</span><br><span class="line">        System.out.println(c1.get(Calendar.MONTH));</span><br><span class="line">        System.out.println(c1.get(Calendar.DATE));</span><br><span class="line">        System.out.println(c2.get(Calendar.MONTH));</span><br><span class="line">        System.out.println(c1.get(Calendar.DATE));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;Date类与Calendar类的相互转换 </span><br><span class="line">        &#x2F;&#x2F;Date类转Calendar类</span><br><span class="line">        Calendar cal1 &#x3D; Calendar.getInstance();</span><br><span class="line">        Date  date1 &#x3D; cal1.getTime();</span><br><span class="line">        &#x2F;&#x2F;Calendar类转Date类</span><br><span class="line">        Date date2 &#x3D; new Date();</span><br><span class="line">        Calendar cal2 &#x3D;Calendar.getInstance();</span><br><span class="line">        cal2.setTime(date2);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="BigDecimal类"><a href="#BigDecimal类" class="headerlink" title="BigDecimal类"></a>BigDecimal类</h2><blockquote><p>float和double类型的主要设计目标是为了科学计算和工程计算<br>因在于我们的计算机是二进制的 浮点数没有办法是用二进制进行精确表示<br>商业计算往往要求结果精确，这时候BigDecimal就派上大用场  </p></blockquote><h3 id="BigDecimal类的常用构造方法"><a href="#BigDecimal类的常用构造方法" class="headerlink" title="BigDecimal类的常用构造方法"></a>BigDecimal类的常用构造方法</h3><ul><li>1.public BigDecimal(double val)    将double表示形式转换为BigDecimal 不建议使用  </li><li>2.public BigDecimal(int val)　　将int表示形式转换成BigDecimal  </li><li>3.public BigDecimal(String val)　　将String表示形式转换成BigDecimal  </li></ul><blockquote><blockquote><p>注意：参数类型为double的构造方法的结果有一定的不可预知性 String 构造方法是完全可预知的<br> 所以BigDecimal类最好使用String类的构造器  </p></blockquote></blockquote><h3 id="BigDecimal类的常用方法"><a href="#BigDecimal类的常用方法" class="headerlink" title="BigDecimal类的常用方法"></a>BigDecimal类的常用方法</h3><ul><li>public BigDecimal add(BigDecimal value);                加法  </li><li>public BigDecimal subtract(BigDecimal value);           减法</li><li>public BigDecimal multiply(BigDecimal value);           乘法  </li><li>public BigDecimal divide(BigDecimal value);             除法  </li></ul><hr><pre><code>public class BigDecimalTest {    public static void main(String[] args){        //BigDecimal类的基础对象的构建        BigDecimal doubleTest1 = new BigDecimal(&quot;0.01&quot;);        BigDecimal doubleTest2 = new BigDecimal(0.01);        BigDecimal intTest1 = new BigDecimal(178);        //string 的构造器是完全预知的所以可以精确的表示0.01        System.out.println(doubleTest1);        //0.01无法精确的表示double所以系统会默认随机补位        System.out.println(doubleTest2);        System.out.println(intTest1);        //BigDecimal类的基础方法的使用        BigDecimal testNumber1 = new BigDecimal(&quot;0.15&quot;);        BigDecimal testNumber2 = new BigDecimal(&quot;0.03&quot;);        System.out.println(testNumber1.add(testNumber2));        System.out.println(testNumber1.subtract(testNumber2));        System.out.println(testNumber1.multiply(testNumber2));        System.out.println(testNumber1.divide(testNumber2));    }}</code></pre><h2 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h2><blockquote><p>正则表达式定义了字符串的模式，相当于构建了一个java字符串的自定义模板<br>java.util.regex 包主要包括以下两个类：<br>attern 类：<br>pattern 对象是一个正则表达式的编译表示<br>Pattern 类没有公共构造方法 要创建一个 Pattern 对象，你必须首先调用其公共静态编译方法<br>它返回一个 Pattern 对象。该方法接受一个正则表达式作为它的第一个参数<br>Matcher 类：<br>Matcher 对象是对输入字符串进行解释和匹配操作的引擎<br>与Pattern 类一样，Matcher 也没有公共构造方法<br>需要调用 Pattern 对象的 matcher 方法来获得一个 Matcher 对象  </p></blockquote><h3 id="Matcher-类的方法"><a href="#Matcher-类的方法" class="headerlink" title="Matcher 类的方法"></a>Matcher 类的方法</h3><ul><li>public int start()  返回以前匹配的初始索引  </li><li>public int end() 返回最后匹配字符之后的偏移量  </li><li>public boolean find()  尝试查找与该模式匹配的输入序列的下一个子序列  </li></ul><hr><pre><code>public class RegexTest {    public static void main(String[] args){        String str = new String(&quot;请尽快联系我17824852705,我的电话是15143385727出售二手书籍16824852705&quot;);        // 创建一个pattern字符串模板        Pattern pat = Pattern.compile(&quot;((17\\d)|(15\\d))\\d{8}&quot;);        //调用Pattern类的matcher方法创建一个Matcher对象        Matcher m =pat.matcher(str);        //将给定字符串与模板字符串进行比较        while (m.find()){            //输出所有与模板字符串相匹配的字符串            System.out.println(m.group());        }        //描述正则表达式的特殊字符        Pattern pat2 =Pattern.compile(&quot;a*b&quot;);        Matcher m2 = pat2.matcher(&quot;aab&quot;);        boolean boo = m2.matches();        System.out.println(boo);         //Matcher类end()和start()方法         String str2 =new String(&quot;java is very good &quot;);         System.out.println(&quot;目标字符串：&quot;+str2);         Matcher m3 = Pattern.compile(&quot;\\w+&quot;).matcher(str2);         while(m3.find()){             System.out.println(m3.group()+&quot;起始字符位置：&quot;+m3.start()+&quot;结尾字符位置：&quot;+ m3.end());        }         //通过正则表达式输出字符串数组         String[] mails = {&quot;kongyeeku@163.com&quot;, &quot;kongyeeku@gmail.com&quot;, &quot;ligang@crazyit.org&quot;, &quot;wawa@abc.xx&quot;};         String mailRegEx = &quot;\\w{3,20}@\\w+\\.(com|org|cn|net|gov)&quot;;         Pattern mailPattern =Pattern.compile(mailRegEx);         //用for循环for（：）方法对数组进行遍历输出         Matcher matcher =null;         for(String mail :mails){            if (matcher == null)                //第一次匹配时创建matcher对象                matcher = mailPattern.matcher(mail);                //先重置目标字符串-避免后面重置时第一个数组会输出两次；                matcher.reset(mail);                while (matcher.find()) {                    System.out.println(matcher.group());                }         }    }} </code></pre>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;java基础库类&quot;&gt;&lt;a href=&quot;#java基础库类&quot; class=&quot;headerlink&quot; title=&quot;java基础库类&quot;&gt;&lt;/a&gt;java基础库类&lt;/h1&gt;&lt;h2 id=&quot;Main类&quot;&gt;&lt;a href=&quot;#Main类&quot; class=&quot;headerlink&quot; title=&quot;Main类&quot;&gt;&lt;/a&gt;Main类&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt; JVM运行Java应用程序的时候，首先会调用main方法&lt;br&gt;  调用时不实例化这个类的对象,而是通过类名直接调用&lt;br&gt;  因此需要是限制为public static&lt;br&gt; main()方法定义：“public static void main(String[]  字符串数组参数名)”&lt;br&gt;  jvm有限制，不能有返回值，因此返回值类型为void&lt;/p&gt;
&lt;/blockquote&gt;
&lt;hr&gt;</summary>
    
    
    
    
    <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>Windows如何重做系统</title>
    <link href="http://yoursite.com/2020/09/01/window10/"/>
    <id>http://yoursite.com/2020/09/01/window10/</id>
    <published>2020-09-01T05:06:33.000Z</published>
    <updated>2020-09-19T02:14:55.829Z</updated>
    
    <content type="html"><![CDATA[<hr><h2 id="Window10重置系统与重装系统"><a href="#Window10重置系统与重装系统" class="headerlink" title="Window10重置系统与重装系统"></a>Window10重置系统与重装系统</h2><h2 id="为什么要重做系统"><a href="#为什么要重做系统" class="headerlink" title="为什么要重做系统"></a>为什么要重做系统</h2><p>1.提高系统稳定性<br>2.清理系统垃圾<br>3.修复缺失的系统文件<br>4.杀死病毒<br>5.系统崩溃——没招  </p><a id="more"></a><h2 id="重置系统与重装系统的区别"><a href="#重置系统与重装系统的区别" class="headerlink" title="重置系统与重装系统的区别"></a>重置系统与重装系统的区别</h2><p>1.重置利用系统现有的资源重新组成可用的系统，重装把全新的系统写入电脑<br>2.重置可以主动保留必要的文件（电脑可以开机），重装系统则需要手动备份<br>3.重置可能不会解决系统所有的问题，重装一定会<br>4.重置不需要借助工具，重装需要借助光盘或者U盘做介质下载系统镜像<br>5.重置系统后联网自动激活重装系统后可能存在系统激活问题<br>6.若系统损坏严重则只能进行系统重装</p><h2 id="重做系统的注意事项"><a href="#重做系统的注意事项" class="headerlink" title="重做系统的注意事项"></a>重做系统的注意事项</h2><p>1.重装系统和重置系统都会格式化系统盘<br>2.数字权利—包括一些激活码和正版软件的激活可能失效（注意保留激活工具）  </p><h2 id="重置系统"><a href="#重置系统" class="headerlink" title="重置系统"></a>重置系统</h2><p>windows&gt;设置&gt;更新和安全&gt;恢复</p><p><img src="/2020/09/01/window10/1.png" alt="alt"></p><h2 id="重装系统"><a href="#重装系统" class="headerlink" title="重装系统"></a>重装系统</h2><h3 id="前期准备"><a href="#前期准备" class="headerlink" title="前期准备"></a>前期准备</h3><p>工具：8G以上的U盘  </p><h4 id="下载镜像源："><a href="#下载镜像源：" class="headerlink" title="下载镜像源："></a>下载镜像源：</h4><p>旧版本的系统镜像源（非官方授权）<br>[msdn I tell you]  (<a href="https://msdn.itellyou.cn/" target="_blank" rel="noopener">https://msdn.itellyou.cn/</a>)   </p><p><img src="/2020/09/01/window10/2.png" alt="alt"><br>Window10<br>[微软官网]  (<a href="https://www.microsoft.com/zh-cn/software-download/windows10/" target="_blank" rel="noopener">https://www.microsoft.com/zh-cn/software-download/windows10/</a>)    </p><p><img src="/2020/09/01/window10/3.png" alt="alt"><br>下载安装工具后运行插入U盘选择为另一台电脑安装介质  </p><p><img src="/2020/09/01/window10/4.png" alt="alt">  </p><p>（注意: U盘插入后微软会自动格式化U盘）  </p><h3 id="开始重装"><a href="#开始重装" class="headerlink" title="开始重装"></a>开始重装</h3><p>1.插入U盘  </p><p>2.通过bios设置U盘为第一启动项  </p><p>3.进入系统安装界面进行逐步安装  </p><p><img src="/2020/09/01/window10/5.png" alt="alt">    </p><p>(注：在安装成功后系统重新启动时要拔出U盘)</p>]]></content>
    
    
    <summary type="html">&lt;hr&gt;
&lt;h2 id=&quot;Window10重置系统与重装系统&quot;&gt;&lt;a href=&quot;#Window10重置系统与重装系统&quot; class=&quot;headerlink&quot; title=&quot;Window10重置系统与重装系统&quot;&gt;&lt;/a&gt;Window10重置系统与重装系统&lt;/h2&gt;&lt;h2 id=&quot;为什么要重做系统&quot;&gt;&lt;a href=&quot;#为什么要重做系统&quot; class=&quot;headerlink&quot; title=&quot;为什么要重做系统&quot;&gt;&lt;/a&gt;为什么要重做系统&lt;/h2&gt;&lt;p&gt;1.提高系统稳定性&lt;br&gt;2.清理系统垃圾&lt;br&gt;3.修复缺失的系统文件&lt;br&gt;4.杀死病毒&lt;br&gt;5.系统崩溃——没招  &lt;/p&gt;</summary>
    
    
    
    
    <category term="windows" scheme="http://yoursite.com/tags/windows/"/>
    
  </entry>
  
  <entry>
    <title>uni--app 接入高德地图</title>
    <link href="http://yoursite.com/2020/08/24/uni-app%E5%BC%80%E5%8F%91-%E5%89%8D%E7%AB%AF%E5%9C%B0%E5%9B%BE%E7%9A%84%E5%AE%9E%E7%8E%B0/"/>
    <id>http://yoursite.com/2020/08/24/uni-app%E5%BC%80%E5%8F%91-%E5%89%8D%E7%AB%AF%E5%9C%B0%E5%9B%BE%E7%9A%84%E5%AE%9E%E7%8E%B0/</id>
    <published>2020-08-24T05:06:33.000Z</published>
    <updated>2020-09-18T08:07:21.790Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Uni-app-map前端开发流程"><a href="#Uni-app-map前端开发流程" class="headerlink" title="Uni-app-map前端开发流程"></a>Uni-app-map前端开发流程</h1><h1 id="一、搭建Android开发环境"><a href="#一、搭建Android开发环境" class="headerlink" title="一、搭建Android开发环境"></a>一、搭建Android开发环境</h1><p>[开发工具：HBuilder X ]  (<a href="https://www.cnblogs.com/qisi007/p/10489176.html" target="_blank" rel="noopener">https://www.cnblogs.com/qisi007/p/10489176.html</a>)  </p><p>[ Android SDK 安装及配置]  ( <a href="https://www.cnblogs.com/nebie/p/9145627.html" target="_blank" rel="noopener">https://www.cnblogs.com/nebie/p/9145627.html</a>) </p><p>[JDK的安装及配置]  (<a href="https://zhuanlan.zhihu.com/p/105478993" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/105478993</a>)  </p><a id="more"></a><h2 id="二、-地图实现"><a href="#二、-地图实现" class="headerlink" title="二、    地图实现"></a>二、    地图实现</h2><h3 id="注册高德地图开发者账号"><a href="#注册高德地图开发者账号" class="headerlink" title="注册高德地图开发者账号"></a>注册高德地图开发者账号</h3><ul><li><p>[注册账号]  (<a href="https://lbs.amap.com/" target="_blank" rel="noopener">https://lbs.amap.com/</a>)    </p><h3 id="创建应用获取key（Android平台）"><a href="#创建应用获取key（Android平台）" class="headerlink" title="创建应用获取key（Android平台）"></a>创建应用获取key（Android平台）</h3></li><li><p>[创建Android平台签名证书 获取发布版SHA1值 ]  (<a href="https://ask.dcloud.net.cn/article/35777" target="_blank" rel="noopener">https://ask.dcloud.net.cn/article/35777</a>) </p></li><li><p>[获取调试版SHA1值]  ( <a href="https://blog.csdn.net/qq_21402513/article/details/51982234" target="_blank" rel="noopener">https://blog.csdn.net/qq_21402513/article/details/51982234</a>)  </p></li></ul><h3 id="获取PackageName"><a href="#获取PackageName" class="headerlink" title="获取PackageName"></a>获取PackageName</h3><ul><li>在HBuilder X中创建工程在发行云打包上获取Android包名即可    </li></ul><h3 id="创建应用获取key（小程序平台）"><a href="#创建应用获取key（小程序平台）" class="headerlink" title="创建应用获取key（小程序平台）"></a>创建应用获取key（小程序平台）</h3><ul><li>直接可得到key   </li></ul><h3 id="下载相应的sdk文件导入项目"><a href="#下载相应的sdk文件导入项目" class="headerlink" title="下载相应的sdk文件导入项目"></a>下载相应的sdk文件导入项目</h3><ul><li>[ Android sdk] ( <a href="https://lbs.amap.com/api/android-sdk/summary/" target="_blank" rel="noopener">https://lbs.amap.com/api/android-sdk/summary/</a>)  </li><li>[小程序 sdk ]  ( <a href="https://lbs.amap.com/api/wx/summary/" target="_blank" rel="noopener">https://lbs.amap.com/api/wx/summary/</a>)  <h3 id="在项目中创建Amap对象"><a href="#在项目中创建Amap对象" class="headerlink" title="在项目中创建Amap对象"></a>在项目中创建Amap对象</h3></li><li>[创建对象]  (<a href="https://ask.dcloud.net.cn/article/35070" target="_blank" rel="noopener">https://ask.dcloud.net.cn/article/35070</a>)  <h2 id="三、-运行"><a href="#三、-运行" class="headerlink" title="三、    运行"></a>三、    运行</h2><h3 id="运行到小程序模拟器"><a href="#运行到小程序模拟器" class="headerlink" title="运行到小程序模拟器"></a>运行到小程序模拟器</h3></li><li>[安装微信开发者工具]<br>(<a href="https://jingyan.baidu.com/article/f0e83a2558580022e591018b.html" target="_blank" rel="noopener">https://jingyan.baidu.com/article/f0e83a2558580022e591018b.html</a> )  </li><li>[获取小程序App Id]<br>(<a href="https://mp.weixin.qq.com/wxamp/home/guide?lang=zh_CN&amp;token=371280001" target="_blank" rel="noopener">https://mp.weixin.qq.com/wxamp/home/guide?lang=zh_CN&amp;token=371280001</a>)  </li></ul><h3 id="运行到手机模拟器（Android平台）"><a href="#运行到手机模拟器（Android平台）" class="headerlink" title="运行到手机模拟器（Android平台）"></a>运行到手机模拟器（Android平台）</h3><ul><li>[配置手机模拟器]  (<a href="https://ask.dcloud.net.cn/article/151" target="_blank" rel="noopener">https://ask.dcloud.net.cn/article/151</a>)   </li></ul><h2 id="附加、-git及github使用"><a href="#附加、-git及github使用" class="headerlink" title="附加、 git及github使用"></a>附加、 git及github使用</h2><ul><li>[ Git安装及配置]  (<a href="https://my.oschina.net/u/2933229/blog/1818671" target="_blank" rel="noopener">https://my.oschina.net/u/2933229/blog/1818671</a>)   </li><li>[TortoiseGIT 安装及配置]  (<a href="https://www.cnblogs.com/xiuxingzhe/p/9312929.html" target="_blank" rel="noopener">https://www.cnblogs.com/xiuxingzhe/p/9312929.html</a>)  </li></ul><hr><blockquote><p>我的第一篇博客   谢谢！</p></blockquote>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;Uni-app-map前端开发流程&quot;&gt;&lt;a href=&quot;#Uni-app-map前端开发流程&quot; class=&quot;headerlink&quot; title=&quot;Uni-app-map前端开发流程&quot;&gt;&lt;/a&gt;Uni-app-map前端开发流程&lt;/h1&gt;&lt;h1 id=&quot;一、搭建Android开发环境&quot;&gt;&lt;a href=&quot;#一、搭建Android开发环境&quot; class=&quot;headerlink&quot; title=&quot;一、搭建Android开发环境&quot;&gt;&lt;/a&gt;一、搭建Android开发环境&lt;/h1&gt;&lt;p&gt;[开发工具：HBuilder X ]  (&lt;a href=&quot;https://www.cnblogs.com/qisi007/p/10489176.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://www.cnblogs.com/qisi007/p/10489176.html&lt;/a&gt;)  &lt;/p&gt;
&lt;p&gt;[ Android SDK 安装及配置]  ( &lt;a href=&quot;https://www.cnblogs.com/nebie/p/9145627.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://www.cnblogs.com/nebie/p/9145627.html&lt;/a&gt;) &lt;/p&gt;
&lt;p&gt;[JDK的安装及配置]  (&lt;a href=&quot;https://zhuanlan.zhihu.com/p/105478993&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://zhuanlan.zhihu.com/p/105478993&lt;/a&gt;)  &lt;/p&gt;</summary>
    
    
    
    
    <category term="uni-app" scheme="http://yoursite.com/tags/uni-app/"/>
    
  </entry>
  
</feed>
