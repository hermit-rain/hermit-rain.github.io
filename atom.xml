<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>鑫宇的个人博客</title>
  
  
  <link href="http://yoursite.com/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2021-10-07T08:21:15.943Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>rain</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>MySQL基础综合</title>
    <link href="http://yoursite.com/2021/10/07/MySQL%E5%9F%BA%E7%A1%80%E7%BB%BC%E5%90%88/"/>
    <id>http://yoursite.com/2021/10/07/MySQL%E5%9F%BA%E7%A1%80%E7%BB%BC%E5%90%88/</id>
    <published>2021-10-07T08:06:50.000Z</published>
    <updated>2021-10-07T08:21:15.943Z</updated>
    
    <content type="html"><![CDATA[<h2 id="如何设计一个关系型数据库"><a href="#如何设计一个关系型数据库" class="headerlink" title="如何设计一个关系型数据库"></a>如何设计一个关系型数据库</h2><p>要设计一个关系型数据库，首先要将其划分为两大部分，即<strong>存储</strong>部分和<strong>程序实例</strong>部分。存储部分就类似于OS文件系统，将数据最终持久化存入磁盘中，即存入机械硬盘或者SSD固态硬盘中。程序实例部分要对存储部分进行逻辑上的管理，而程序实例部分包括<strong>将数据的逻辑关系转换成物理存储关系的存储管理模块</strong>、<strong>优化执行效率的缓存模块</strong>、<strong>将SQL语句进行解析的SQL解析模块</strong>、<strong>记录操作的日志管理模块</strong>、<strong>进行多用户管理的权限划分模块</strong>、<strong>灾难恢复的容灾机制模块</strong>、<strong>优化数据查询的索引管理模块</strong>、<strong>以及使得数据库支持并发操作的锁管理模块</strong>。</p>  <a id="more"></a> <img src="/2021/10/07/MySQL%E5%9F%BA%E7%A1%80%E7%BB%BC%E5%90%88/1.png" alt="1" style="zoom:67%;"><h2 id="数据库理论范式"><a href="#数据库理论范式" class="headerlink" title="数据库理论范式"></a>数据库理论范式</h2><table><thead><tr><th align="center">范式</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">1NF</td><td align="center">每个属性值都是不可再分的最小数据单位,即不能表中有表</td></tr><tr><td align="center">2NF</td><td align="center">从1NF中消除非主属性对候选码的部分函数依赖</td></tr><tr><td align="center">3NF</td><td align="center">从2NF关系中,消除非主属性对码的传递函数依赖</td></tr><tr><td align="center">BCNF</td><td align="center">从3NF基础上，消除主属性对候选码的部分依赖与传递依赖</td></tr></tbody></table><h2 id="MySQL注入"><a href="#MySQL注入" class="headerlink" title="MySQL注入"></a>MySQL注入</h2><p>SQL注入 —&gt;  通过把SQL命令插入到Web表单提交或输入域名或页面请求的查询字符串，最终达到欺骗服务器执行恶意的SQL命令。简单来说，SQL注入就是一种通过操作输入（可以是表单，可以是get请求，也可以是POST请求等）来插入或修改后台SQL语句达到代码执行从而进行攻击的技术。</p><p><strong>SQL注入产生的原因</strong></p><p>程序错误 -&gt; 程序员在编写代码的时候，没有对用户输入数据的合法性进行严格的判断和过滤，从而导致应用程序存在该漏洞。</p><p><strong>SQL 注入的方式</strong></p><ul><li>手工注入</li><li>工具注入</li></ul><p><strong>手工注入</strong>： 在mysql手工注入中主要是利用mysql自带的information_schema数据库，information_schema这个数据库保存了MySQL服务器所有数据库的信息。如数据库名，数据库的表，表栏的数据类型与访问权限等。</p><p><strong>工具注入：</strong> 工具注入是可以节省很多时间，但是仅仅靠工具也不一定能利用该漏洞，因为工具有自己的局限性，不如手工那么灵活。常见的SQL注入工具有 sqlmap，BSQL、the mole…..</p><h2 id="MySQL-主从复制"><a href="#MySQL-主从复制" class="headerlink" title="MySQL 主从复制"></a>MySQL 主从复制</h2><p><strong>基本概念</strong></p><p>MySQL 主从复制是指数据可以从一个MySQL数据库服务器主节点复制到一个或多个从节点。MySQL 默认采用异步复制方式，这样从节点不用一直访问主服务器来更新自己的数据，数据的更新可以在远程连接上进行，从节点可以复制主数据库中的所有数据库或者特定的数据库，或者特定的表。</p><p><strong>主从复制的用途</strong></p><ol><li><strong>读写分离 ：</strong> 在开发工作中，有时候会遇见某个sql 语句需要锁表，导致暂时不能使用读的服务，这样就会影响现有业务，使用主从复制，让主库负责写，从库负责读，这样，即使主库出现了锁表的情景，通过读从库也可以保证业务的正常运作。</li><li><strong>数据的实时备份：</strong>  数据实时备份，当系统中某个节点发生故障时，可以方便的故障切换</li></ol><p><strong>主从复制的基本原则</strong></p><ul><li>每个slave只能有一个 master</li><li>每个slave 只能有一个唯一的服务器 ID</li><li>每个master 可以有多个 salve</li></ul><p><strong>主从复制的步骤</strong></p><ol><li>master 将改变记录到二进制日志 binary log (这些 记录过程叫做二进制日志事件 binary log events);</li><li>salve 将 master 的 binary log events 拷贝到它的中继日志 (relay log);</li><li>slave 重做中继日志中的事件，将改变应用到自己的数据库中;</li></ol><p><strong>Binlog日志的作用</strong></p><ol><li><strong>数据恢复：</strong> 因为 Binlog 详细记录了所有修改数据的 SQL，当某一时刻的数据误操作而导致出问题，或者数据库宕机数据丢失，那么可以根据 Binlog 来回放历史数据。</li><li><strong>主从复制：</strong> 想要做多机备份的业务，可以去监听当前写库的 Binlog 日志，同步写库的所有更改。</li></ol><h2 id="MySQL-读写分离"><a href="#MySQL-读写分离" class="headerlink" title="MySQL 读写分离"></a>MySQL 读写分离</h2><p> 对数据库的更新操作往往要比查找操作更费时，对于高并发的业务场景，如果是单机部署的MySQL，会导致I/O频率过高。采用<strong>主从复制、读写分离可以提高数据库的可用性</strong>。</p><p>MySQL读写分离是指 修改操作在主库上执行，而对于查询操作，可以在从库上执行。主要目的是分担主库的压力。主库压力太大，无法承载业务，通过实现读写分离还能进一步提升数据库的负载性能。对于高访问量的业务场景，MySQL读写分离显得格外重要。</p><h2 id="一条SQL-语句的-执行顺序"><a href="#一条SQL-语句的-执行顺序" class="headerlink" title="一条SQL 语句的 执行顺序"></a>一条SQL 语句的 执行顺序</h2><p><strong>一条 SELECT语句的定义如下：</strong></p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;SELECT clause&gt; [&lt;FROM clause&gt;] [&lt;WHERE clause&gt;] [&lt;GROUP BY clause&gt;] [&lt;HAVING clause&gt;] [&lt;ORDER BY clause&gt;] [&lt;LIMIT clause&gt;]</span><br></pre></td></tr></table></figure><p><strong>一条基本的SELECT语句的执行流程如下：</strong></p><ol><li>from:需要从哪个数据表检索数据 </li><li>where:过滤表中数据的条件 </li><li>group by:如何将上面过滤出的数据分组 </li><li>having:对上面已经分组的数据进行过滤的条件 </li><li>select:查看结果集中的哪个列，或列的计算结果 </li><li>order by :按照什么样的顺序来查看返回的数据</li><li>limit : 添加返回限制</li></ol><p><strong>参考资料</strong></p><p><a href="https://www.cnblogs.com/rickiyang/p/13856388.html" target="_blank" rel="noopener">MySQL 主从复制</a></p><p><a href="https://blog.csdn.net/u014044812/article/details/51004754" target="_blank" rel="noopener">sql的执行顺序</a></p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;如何设计一个关系型数据库&quot;&gt;&lt;a href=&quot;#如何设计一个关系型数据库&quot; class=&quot;headerlink&quot; title=&quot;如何设计一个关系型数据库&quot;&gt;&lt;/a&gt;如何设计一个关系型数据库&lt;/h2&gt;&lt;p&gt;要设计一个关系型数据库，首先要将其划分为两大部分，即&lt;strong&gt;存储&lt;/strong&gt;部分和&lt;strong&gt;程序实例&lt;/strong&gt;部分。存储部分就类似于OS文件系统，将数据最终持久化存入磁盘中，即存入机械硬盘或者SSD固态硬盘中。程序实例部分要对存储部分进行逻辑上的管理，而程序实例部分包括&lt;strong&gt;将数据的逻辑关系转换成物理存储关系的存储管理模块&lt;/strong&gt;、&lt;strong&gt;优化执行效率的缓存模块&lt;/strong&gt;、&lt;strong&gt;将SQL语句进行解析的SQL解析模块&lt;/strong&gt;、&lt;strong&gt;记录操作的日志管理模块&lt;/strong&gt;、&lt;strong&gt;进行多用户管理的权限划分模块&lt;/strong&gt;、&lt;strong&gt;灾难恢复的容灾机制模块&lt;/strong&gt;、&lt;strong&gt;优化数据查询的索引管理模块&lt;/strong&gt;、&lt;strong&gt;以及使得数据库支持并发操作的锁管理模块&lt;/strong&gt;。&lt;/p&gt;</summary>
    
    
    
    
    <category term="MySQL" scheme="http://yoursite.com/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>SQL常用语法</title>
    <link href="http://yoursite.com/2021/10/01/sql%E5%B8%B8%E7%94%A8%E8%AF%AD%E6%B3%95/"/>
    <id>http://yoursite.com/2021/10/01/sql%E5%B8%B8%E7%94%A8%E8%AF%AD%E6%B3%95/</id>
    <published>2021-10-01T08:12:06.000Z</published>
    <updated>2021-10-07T08:21:35.280Z</updated>
    
    <content type="html"><![CDATA[<h2 id="数据库的基本操作"><a href="#数据库的基本操作" class="headerlink" title="数据库的基本操作"></a>数据库的基本操作</h2><p>显示数据库</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> <span class="keyword">databases</span>;</span><br></pre></td></tr></table></figure>  <a id="more"></a> <p>创建数据库</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">database</span> student;</span><br></pre></td></tr></table></figure><p>创建以关键字命名的数据库等</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">database</span> <span class="string">`database`</span>;</span><br></pre></td></tr></table></figure><p>创建前进行判断</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">database</span> <span class="keyword">if</span> <span class="keyword">not</span> <span class="keyword">exists</span> student;s</span><br></pre></td></tr></table></figure><p>删除数据库</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">drop</span> <span class="keyword">database</span> student;</span><br></pre></td></tr></table></figure><p>删除前进行判断</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">drop</span> <span class="keyword">database</span> <span class="keyword">if</span> <span class="keyword">exists</span> student;</span><br></pre></td></tr></table></figure><p>查看创建数据库时的设置信息</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show create database teacher;</span><br><span class="line">+<span class="comment">----------+------------------------------------------------------------------+</span></span><br><span class="line">| Database | <span class="keyword">Create</span> <span class="keyword">Database</span>                                                  |      </span><br><span class="line">+<span class="comment">----------+------------------------------------------------------------------+      </span></span><br><span class="line">| teacher  | <span class="keyword">CREATE</span> <span class="keyword">DATABASE</span> <span class="string">`teacher`</span> <span class="comment">/*!40100 DEFAULT CHARACTER SET utf8 */</span> |</span><br><span class="line">+<span class="comment">----------+------------------------------------------------------------------+</span></span><br></pre></td></tr></table></figure><p>修改数据库的字符编码</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">database</span> teacher <span class="keyword">charset</span> = gbk;</span><br></pre></td></tr></table></figure><p>使用数据库</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> rain_school;</span><br></pre></td></tr></table></figure><p>查看字符编码</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> <span class="keyword">variables</span> <span class="keyword">like</span> <span class="string">'character_set_%'</span>;</span><br></pre></td></tr></table></figure><h2 id="表的基本操作"><a href="#表的基本操作" class="headerlink" title="表的基本操作"></a>表的基本操作</h2><p>创建表</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; create table student(</span><br><span class="line">    -&gt; id int (4),</span><br><span class="line">    -&gt; name varchar(30),</span><br><span class="line">    -&gt; age int</span><br><span class="line">    -&gt; );</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    id 的字段宽度为 4 -&gt; 显示的数值宽度，但是只要插入的数据在int的数值范围内，即使数值宽度大于4也可以显示</span></span><br><span class="line"><span class="comment">    name 字段的宽度为30 -&gt; name 字段为字符类型，所以插入的字符宽度不可以超过30 </span></span><br><span class="line"><span class="comment">    **/</span></span><br></pre></td></tr></table></figure><p>显示当前所使用的数据库中的表</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show tables;</span><br><span class="line">+<span class="comment">-----------------------+</span></span><br><span class="line">| Tables_in_rain_school |</span><br><span class="line">+<span class="comment">-----------------------+</span></span><br><span class="line">| student               |</span><br><span class="line">+<span class="comment">-----------------------+</span></span><br></pre></td></tr></table></figure><p>更详细滴创建表</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt;  create table if not exists teacher(    </span><br><span class="line">    -&gt;  id int auto_increment primary key comment '主键id',     </span><br><span class="line">    -&gt;  name varchar(30) not null comment '老师名字非空',    </span><br><span class="line">    -&gt;  phone varchar(20) comment '电话号码',    </span><br><span class="line">    -&gt;  address varchar(100) default '暂时未知' comment '住址'    </span><br><span class="line">    -&gt;  )engine=innodb;</span><br><span class="line">Query OK, 0 rows affected (0.09 sec)</span><br><span class="line">    <span class="comment">/**id name phone... 字段</span></span><br><span class="line"><span class="comment">    auto_increment 自动增长</span></span><br><span class="line"><span class="comment">    primary key 主键</span></span><br><span class="line"><span class="comment">    comment 注释</span></span><br><span class="line"><span class="comment">    not null 非空</span></span><br><span class="line"><span class="comment">    default 默认</span></span><br><span class="line"><span class="comment">    engine 存储引擎**/</span></span><br></pre></td></tr></table></figure><p>查看之前创建表时的信息</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> <span class="keyword">create</span> <span class="keyword">table</span> teacher;</span><br></pre></td></tr></table></figure><p>查看表结构</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; desc teacher;</span><br><span class="line">+<span class="comment">---------+--------------+------+-----+----------+----------------+</span></span><br><span class="line">| Field   | Type         | Null | Key | Default  | Extra          |      </span><br><span class="line">+<span class="comment">---------+--------------+------+-----+----------+----------------+      </span></span><br><span class="line">| id      | int(11)      | NO   | PRI | NULL     | auto_increment |      </span><br><span class="line">| name    | varchar(30)  | NO   |     | NULL     |                |      </span><br><span class="line">| phone   | varchar(20)  | YES  |     | NULL     |                |      </span><br><span class="line">| address | varchar(100) | YES  |     | 暂时未知 |                |      </span><br><span class="line">+<span class="comment">---------+--------------+------+-----+----------+----------------+</span></span><br></pre></td></tr></table></figure><p>删除单个表</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">drop</span> <span class="keyword">table</span> <span class="keyword">if</span> <span class="keyword">exists</span> stu;</span><br></pre></td></tr></table></figure><p>一次删除多个表</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">drop</span> <span class="keyword">table</span> <span class="keyword">if</span> <span class="keyword">exists</span> stu, teacher, sss;</span><br></pre></td></tr></table></figure><p>修改表-添加字段</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> student <span class="keyword">add</span> phone <span class="built_in">varchar</span>(<span class="number">20</span>);</span><br></pre></td></tr></table></figure><p>在指定位置添加字段</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> student <span class="keyword">add</span> gender <span class="built_in">varchar</span>(<span class="number">1</span>) <span class="keyword">after</span> <span class="keyword">name</span>;</span><br></pre></td></tr></table></figure><p>删除表的某个字段</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> student <span class="keyword">drop</span> phone;</span><br></pre></td></tr></table></figure><p>修改表中字段的类型</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> student <span class="keyword">modify</span> age <span class="built_in">int</span>(<span class="number">2</span>);</span><br></pre></td></tr></table></figure><p>修改表名字</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> student <span class="keyword">rename</span> <span class="keyword">to</span> stu;</span><br></pre></td></tr></table></figure><h2 id="数据的更新操作"><a href="#数据的更新操作" class="headerlink" title="数据的更新操作"></a>数据的更新操作</h2><p>向表中插入数据</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; insert into teacher (id, name, phone, address) values (1, 'rain', </span><br><span class="line">'17824852705', 'DALIAN');</span><br></pre></td></tr></table></figure><p>一次性插入多条数据</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> teacher(<span class="keyword">id</span>, <span class="keyword">name</span>) <span class="keyword">values</span>(<span class="number">7</span>, <span class="string">"MIA"</span>),(<span class="number">8</span>, <span class="string">"sss"</span>);</span><br></pre></td></tr></table></figure><p>删除数据</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">delete</span> <span class="keyword">from</span> teacher <span class="keyword">where</span> <span class="keyword">id</span> = <span class="number">6</span>;</span><br></pre></td></tr></table></figure><p>清空表中的数据</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">delete from student;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">truncate table student;</span><br></pre></td></tr></table></figure><p>truncate 与 delete 清表的区别</p><ul><li>truncate 比 delete 更快 -&gt; delete删除会记录到日志中</li><li>truncate 是直接销毁表，delete 可以按照条件删除</li><li>清空后 truncate 的 id 会从头开始， delete 的 id 会接着删除之前的 id –&gt; delete 清空表底层是通过 where 遍历； </li></ul><p>修改数据</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; update teacher set name = 'rain', address='DALIAN',phone='17824852705' where id = 1;</span><br></pre></td></tr></table></figure><p>修改数据时如果没有指定更新条件where -&gt; 将所有数据全部更新</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; update teacher set name = 'rain', address='DALIAN',phone='17824852705';</span><br></pre></td></tr></table></figure><p>查询全部数据</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select * from teacher;</span><br><span class="line">+<span class="comment">----+------+-------------+---------+</span></span><br><span class="line">| id | name | phone       | address |</span><br><span class="line">+<span class="comment">----+------+-------------+---------+</span></span><br><span class="line">|  1 | MIA  | 18192768186 | XIAN    |</span><br><span class="line">|  2 | rain | 17824852705 | DALIAN  |</span><br><span class="line">+<span class="comment">----+------+-------------+---------+</span></span><br></pre></td></tr></table></figure><p>查询指定字段的数据</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select id, name, address from teacher;</span><br><span class="line">+<span class="comment">----+------+---------+</span></span><br><span class="line">| id | name | address |</span><br><span class="line">+<span class="comment">----+------+---------+</span></span><br><span class="line">|  1 | MIA  | XIAN    |</span><br><span class="line">|  2 | rain | DALIAN  |</span><br><span class="line">+<span class="comment">----+------+---------+</span></span><br></pre></td></tr></table></figure><h2 id="数据的查询操作"><a href="#数据的查询操作" class="headerlink" title="数据的查询操作"></a>数据的查询操作</h2><h4 id="单表查询"><a href="#单表查询" class="headerlink" title="单表查询"></a>单表查询</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select 2*5 as res from dual; #dual 为默认的伪表可以不写, as 定义表的别名</span><br><span class="line">+<span class="comment">-----+</span></span><br><span class="line">| res |</span><br><span class="line">+<span class="comment">-----+</span></span><br><span class="line">|  10 |</span><br><span class="line">+<span class="comment">-----+</span></span><br><span class="line">1 row in <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure><p><code>limit</code>  限制条件</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select * from teacher limit 0,2; # 从下标 0 位置开始，共查询两条数据</span><br><span class="line">+<span class="comment">----+------+--------+-----+-------------+---------+</span></span><br><span class="line">| id | name | gender | age | phone       | address |</span><br><span class="line">+<span class="comment">----+------+--------+-----+-------------+---------+</span></span><br><span class="line">|  1 | Tom  | 男     |  15 | 18192768186 | XIAN    |</span><br><span class="line">|  2 | rain | 男     |  16 | 17824852705 | DALIAN  |</span><br><span class="line">+<span class="comment">----+------+--------+-----+-------------+---------+</span></span><br><span class="line">2 rows in <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; <span class="keyword">select</span> * <span class="keyword">from</span> teacher <span class="keyword">limit</span> <span class="number">3</span>; <span class="comment">#取前三条数据</span></span><br><span class="line">+<span class="comment">----+------+--------+-----+-------------+---------+</span></span><br><span class="line">| id | name | gender | age | phone       | address |</span><br><span class="line">+<span class="comment">----+------+--------+-----+-------------+---------+</span></span><br><span class="line">|  1 | Tom  | 男     |  15 | 18192768186 | XIAN    |</span><br><span class="line">|  2 | rain | 男     |  16 | 17824852705 | DALIAN  |</span><br><span class="line">|  3 | 饭饭 | 女     |  18 | 15145124023 | BEIJING |</span><br><span class="line">+<span class="comment">----+------+--------+-----+-------------+---------+</span></span><br><span class="line">3 rows in <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure><p><code>distinct</code> -&gt;去重</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select address from teacher;</span><br><span class="line">+<span class="comment">----------+</span></span><br><span class="line">| address  |</span><br><span class="line">+<span class="comment">----------+</span></span><br><span class="line">| XIAN     |</span><br><span class="line">| DALIAN   |</span><br><span class="line">| BEIJING  |</span><br><span class="line">| SHANGHAI |</span><br><span class="line">| SHANGHAI |</span><br><span class="line">| BEIJING  |</span><br><span class="line">| 暂时未知 |</span><br><span class="line">+<span class="comment">----------+</span></span><br><span class="line">7 rows in <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; <span class="keyword">select</span> <span class="keyword">distinct</span> address <span class="keyword">from</span> teacher;</span><br><span class="line">+<span class="comment">----------+</span></span><br><span class="line">| address  |</span><br><span class="line">+<span class="comment">----------+</span></span><br><span class="line">| XIAN     |</span><br><span class="line">| DALIAN   |</span><br><span class="line">| BEIJING  |</span><br><span class="line">| SHANGHAI |</span><br><span class="line">| 暂时未知 |</span><br><span class="line">+<span class="comment">----------+</span></span><br><span class="line">5 rows in <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure><p>聚合函数</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select count(*) from teacher;</span><br><span class="line">+<span class="comment">----------+</span></span><br><span class="line">| count(*) |</span><br><span class="line">+<span class="comment">----------+</span></span><br><span class="line">|        5 |</span><br><span class="line">+<span class="comment">----------+</span></span><br><span class="line">1 row in <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; <span class="keyword">select</span> <span class="keyword">max</span>(<span class="keyword">id</span>) <span class="keyword">from</span> teacher;</span><br><span class="line">+<span class="comment">---------+</span></span><br><span class="line">| max(id) |</span><br><span class="line">+<span class="comment">---------+</span></span><br><span class="line">|       5 |</span><br><span class="line">+<span class="comment">---------+</span></span><br><span class="line">1 row in <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure><p>条件查询</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select * from teacher where address = 'beijing';</span><br><span class="line">+<span class="comment">----+------+-------------+---------+</span></span><br><span class="line">| id | name | phone       | address |</span><br><span class="line">+<span class="comment">----+------+-------------+---------+</span></span><br><span class="line">|  3 | 饭饭 | 15145124023 | beijing |</span><br><span class="line">+<span class="comment">----+------+-------------+---------+</span></span><br><span class="line"></span><br><span class="line">mysql&gt; select * from teacher where address in('beijing', 'DALIAN');</span><br><span class="line">+<span class="comment">----+------+-------------+---------+</span></span><br><span class="line">| id | name | phone       | address |</span><br><span class="line">+<span class="comment">----+------+-------------+---------+</span></span><br><span class="line">|  2 | rain | 17824852705 | DALIAN  |</span><br><span class="line">|  3 | 饭饭 | 15145124023 | beijing |</span><br><span class="line">+<span class="comment">----+------+-------------+---------+</span></span><br><span class="line">2 rows in <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; <span class="keyword">select</span> * <span class="keyword">from</span> teacher <span class="keyword">where</span> <span class="keyword">id</span> <span class="keyword">not</span> <span class="keyword">between</span> <span class="number">2</span> <span class="keyword">and</span> <span class="number">3</span>;</span><br><span class="line">+<span class="comment">----+-------+-------------+----------+</span></span><br><span class="line">| id | name  | phone       | address  |</span><br><span class="line">+<span class="comment">----+-------+-------------+----------+</span></span><br><span class="line">|  1 | Tom   | 18192768186 | XIAN     |</span><br><span class="line">|  4 | Jerry | 13803694825 | CHANGSHA |</span><br><span class="line">|  5 | Frank | 12415452639 | 暂时未知 |</span><br><span class="line">+<span class="comment">----+-------+-------------+----------+</span></span><br><span class="line">3 rows in <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; <span class="keyword">select</span> * <span class="keyword">from</span> student <span class="keyword">where</span> age <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">null</span>;</span><br><span class="line">+<span class="comment">------+------+--------+------+</span></span><br><span class="line">| id   | name | gender | age  |</span><br><span class="line">+<span class="comment">------+------+--------+------+</span></span><br><span class="line">|    1 | rain | 男     |   23 |</span><br><span class="line">|    2 | MIA  | 女     |   19 |</span><br><span class="line">+<span class="comment">------+------+--------+------+</span></span><br><span class="line">2 rows in <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure><p>模糊查询</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select * from teacher where address like 'bei%';</span><br><span class="line">+<span class="comment">----+----------+-------------+---------+</span></span><br><span class="line">| id | name     | phone       | address |</span><br><span class="line">+<span class="comment">----+----------+-------------+---------+</span></span><br><span class="line">|  3 | 饭饭     | 15145124023 | beijing |</span><br><span class="line">|  6 | Fiveteen | 15145236589 | beijing |</span><br><span class="line">+<span class="comment">----+----------+-------------+---------+</span></span><br><span class="line"></span><br><span class="line">mysql&gt; select * from teacher where name  like 'rai_';</span><br><span class="line">+<span class="comment">----+------+-------------+---------+</span></span><br><span class="line">| id | name | phone       | address |</span><br><span class="line">+<span class="comment">----+------+-------------+---------+</span></span><br><span class="line">|  2 | rain | 17824852705 | DALIAN  |</span><br><span class="line">+<span class="comment">----+------+-------------+---------+</span></span><br><span class="line">1 row in <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure><p>排序查询</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select * from teacher order by age asc; #升序排列 默认为升序</span><br><span class="line">+<span class="comment">----+----------+------+-------------+----------+</span></span><br><span class="line">| id | name     | age  | phone       | address  |</span><br><span class="line">+<span class="comment">----+----------+------+-------------+----------+</span></span><br><span class="line">|  1 | Tom      |   15 | 18192768186 | XIAN     |</span><br><span class="line">|  2 | rain     |   16 | 17824852705 | DALIAN   |</span><br><span class="line">|  3 | 饭饭     |   18 | 15145124023 | beijing  |</span><br><span class="line">|  4 | Jerry    |   18 | 13803694825 | CHANGSHA |</span><br><span class="line">|  6 | Fiveteen |   20 | 15145236589 | beijing  |</span><br><span class="line">|  5 | Frank    |   26 | 12415452639 | 暂时未知 |</span><br><span class="line">+<span class="comment">----+----------+------+-------------+----------+</span></span><br><span class="line">6 rows in <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; <span class="keyword">select</span> * <span class="keyword">from</span> teacher <span class="keyword">order</span> <span class="keyword">by</span> age <span class="keyword">desc</span>; <span class="comment">#降序排列</span></span><br><span class="line">+<span class="comment">----+----------+------+-------------+----------+</span></span><br><span class="line">| id | name     | age  | phone       | address  |</span><br><span class="line">+<span class="comment">----+----------+------+-------------+----------+</span></span><br><span class="line">|  5 | Frank    |   26 | 12415452639 | 暂时未知 |</span><br><span class="line">|  6 | Fiveteen |   20 | 15145236589 | beijing  |</span><br><span class="line">|  3 | 饭饭     |   18 | 15145124023 | beijing  |</span><br><span class="line">|  4 | Jerry    |   18 | 13803694825 | CHANGSHA |</span><br><span class="line">|  2 | rain     |   16 | 17824852705 | DALIAN   |</span><br><span class="line">|  1 | Tom      |   15 | 18192768186 | XIAN     |</span><br><span class="line">+<span class="comment">----+----------+------+-------------+----------+</span></span><br><span class="line">6 rows in <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure><p>分组查询   (格式 -&gt; 聚合函数 + 分组字段）</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select avg(age) as '平均年龄', address as '地区' from teacher group by address;</span><br><span class="line">+<span class="comment">----------+----------+</span></span><br><span class="line">| 平均年龄 | 地区       |</span><br><span class="line">+<span class="comment">----------+----------+</span></span><br><span class="line">|  19.0000 | BEIJING  |</span><br><span class="line">|  16.0000 | DALIAN   |</span><br><span class="line">|  22.0000 | SHANGHAI |</span><br><span class="line">|  15.0000 | XIAN     |</span><br><span class="line">|  23.0000 | 暂时未知  |</span><br><span class="line">+<span class="comment">----------+----------+</span></span><br><span class="line">5 rows in <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; <span class="keyword">select</span> <span class="keyword">avg</span>(age), address <span class="keyword">from</span> teacher <span class="keyword">group</span> <span class="keyword">by</span> address <span class="keyword">order</span> <span class="keyword">by</span> <span class="keyword">avg</span>(age); <span class="comment">#order by要在group by 之后</span></span><br><span class="line">+<span class="comment">----------+----------+</span></span><br><span class="line">| avg(age) | address  |</span><br><span class="line">+<span class="comment">----------+----------+</span></span><br><span class="line">|  15.0000 | XIAN     |</span><br><span class="line">|  16.0000 | DALIAN   |</span><br><span class="line">|  19.0000 | BEIJING  |</span><br><span class="line">|  22.0000 | SHANGHAI |</span><br><span class="line">|  23.0000 | 暂时未知 |</span><br><span class="line">+<span class="comment">----------+----------+</span></span><br><span class="line">5 rows in <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; <span class="keyword">select</span> <span class="keyword">avg</span>(age) <span class="keyword">as</span> age, address <span class="keyword">from</span> teacher <span class="keyword">group</span> <span class="keyword">by</span> address <span class="keyword">desc</span> <span class="keyword">having</span> age &gt; <span class="number">20</span>; <span class="comment">#having 分组筛选</span></span><br><span class="line">+<span class="comment">---------+----------+</span></span><br><span class="line">| age     | address  |</span><br><span class="line">+<span class="comment">---------+----------+</span></span><br><span class="line">| 23.0000 | 暂时未知  |</span><br><span class="line">| 22.0000 | SHANGHAI |</span><br><span class="line">+<span class="comment">---------+----------+</span></span><br><span class="line">2 rows in <span class="keyword">set</span>, <span class="number">1</span> <span class="keyword">warning</span> (<span class="number">0.00</span> sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; <span class="keyword">select</span> <span class="keyword">group_concat</span>(<span class="keyword">name</span>), gender <span class="keyword">from</span> teacher <span class="keyword">group</span> <span class="keyword">by</span> gender; <span class="comment">#聚合显示</span></span><br><span class="line">+<span class="comment">---------------------+--------+</span></span><br><span class="line">| group_concat(name)  | gender |</span><br><span class="line">+<span class="comment">---------------------+--------+</span></span><br><span class="line">| 饭饭,Frank,Fiveteen | 女     |</span><br><span class="line">| Tom,rain,Jerry,Free | 男     |</span><br><span class="line">+<span class="comment">---------------------+--------+</span></span><br><span class="line">2 rows in <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure><h4 id="多表查询"><a href="#多表查询" class="headerlink" title="多表查询"></a>多表查询</h4><p><strong>数据库的连接方式</strong></p><ol><li><strong>内连接</strong></li><li><strong>外连接</strong> -&gt; 左外连接、右外连接、全连接 (注意MySQL 已经取消全连接 <code>full join</code>但是可以用 <code>union</code>关键字实现)</li><li><strong>交叉连接</strong></li></ol><p>内连接  -&gt; <code>inner join</code>  -&gt; 在两张表的<strong>相同属性</strong>上做等值连接，当不使用 <code>on</code> 关键字时，与 <code>cross join</code> 交叉连接(取笛卡尔积) 相同</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select * from student;</span><br><span class="line">+<span class="comment">----+---------+--------+------+----------+</span></span><br><span class="line">| id | name    | gender | age  | dept     |</span><br><span class="line">+<span class="comment">----+---------+--------+------+----------+</span></span><br><span class="line">|  1 | rain    | 男     |   23 | Cs       |</span><br><span class="line">|  2 | MIA     | 女     |   19 | Japanese |</span><br><span class="line">|  3 | free    | 男     |   18 | Math     |</span><br><span class="line">|  4 | sss     | 女     |   18 | Cs       |</span><br><span class="line">|  5 | Frank   | 男     |   28 | Cs       |</span><br><span class="line">|  6 | BigHead | 男     |   23 | Math     |</span><br><span class="line">|  7 | Jashen  | 男     |   22 | Math     |</span><br><span class="line">+<span class="comment">----+---------+--------+------+----------+</span></span><br><span class="line">7 rows in <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; <span class="keyword">select</span> * <span class="keyword">from</span> course;</span><br><span class="line">+<span class="comment">----+----------+---------+</span></span><br><span class="line">| id | name     | creadit |</span><br><span class="line">+<span class="comment">----+----------+---------+</span></span><br><span class="line">|  1 | 数据库   |       4 |</span><br><span class="line">|  2 | 数学     |       2 |</span><br><span class="line">|  3 | 操作系统 |       4 |</span><br><span class="line">|  4 | 计网     |       3 |</span><br><span class="line">|  5 | 日语     |       2 |</span><br><span class="line">|  6 | 数据结构 |       4 |</span><br><span class="line">+<span class="comment">----+----------+---------+</span></span><br><span class="line">6 rows in <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; <span class="keyword">select</span> * <span class="keyword">from</span> score;</span><br><span class="line">+<span class="comment">----+-----+-------+</span></span><br><span class="line">| id | cno | grade |</span><br><span class="line">+<span class="comment">----+-----+-------+</span></span><br><span class="line">|  1 |   1 |    98 |</span><br><span class="line">|  1 |   3 |    65 |</span><br><span class="line">|  1 |   6 |    95 |</span><br><span class="line">|  2 |   5 |   100 |</span><br><span class="line">|  3 |   2 |    98 |</span><br><span class="line">|  4 |   1 |    96 |</span><br><span class="line">|  4 |   4 |    85 |</span><br><span class="line">|  5 |   1 |   100 |</span><br><span class="line">|  6 |   2 |    90 |</span><br><span class="line">|  6 |   3 |    80 |</span><br><span class="line">+<span class="comment">----+-----+-------+</span></span><br><span class="line">10 rows in <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; <span class="keyword">select</span> student.id, <span class="keyword">name</span>, dept, score.cno, grade <span class="keyword">from</span> student <span class="keyword">inner</span> <span class="keyword">join</span> score <span class="keyword">on</span> student.id = score.id;</span><br><span class="line">+<span class="comment">----+---------+----------+-----+-------+</span></span><br><span class="line">| id | name    | dept     | cno | grade |</span><br><span class="line">+<span class="comment">----+---------+----------+-----+-------+</span></span><br><span class="line">|  1 | rain    | Cs       |   1 |    98 |</span><br><span class="line">|  1 | rain    | Cs       |   3 |    65 |</span><br><span class="line">|  1 | rain    | Cs       |   6 |    95 |</span><br><span class="line">|  2 | MIA     | Japanese |   5 |   100 |</span><br><span class="line">|  3 | free    | Math     |   2 |    98 |</span><br><span class="line">|  4 | sss     | Cs       |   1 |    96 |</span><br><span class="line">|  4 | sss     | Cs       |   4 |    85 |</span><br><span class="line">|  5 | Frank   | Cs       |   1 |   100 |</span><br><span class="line">|  6 | BigHead | Math     |   2 |    90 |</span><br><span class="line">|  6 | BigHead | Math     |   3 |    80 |</span><br><span class="line">+<span class="comment">----+---------+----------+-----+-------+</span></span><br><span class="line">10 rows in <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; <span class="keyword">select</span> student.id, student.name, dept, course.name <span class="keyword">as</span> cname, score.grade <span class="keyword">from</span> student <span class="keyword">inner</span> <span class="keyword">join</span> score <span class="keyword">on</span> student.id = score.id <span class="keyword">inner</span> <span class="keyword">join</span> course <span class="keyword">on</span> score.cno = course.id;</span><br><span class="line">+<span class="comment">----+---------+----------+----------+-------+</span></span><br><span class="line">| id | name    | dept     | cname    | grade |</span><br><span class="line">+<span class="comment">----+---------+----------+----------+-------+</span></span><br><span class="line">|  1 | rain    | Cs       | 数据库   |    98 |</span><br><span class="line">|  1 | rain    | Cs       | 操作系统 |    65 |</span><br><span class="line">|  1 | rain    | Cs       | 数据结构 |    95 |</span><br><span class="line">|  2 | MIA     | Japanese | 日语     |   100 |</span><br><span class="line">|  3 | free    | Math     | 数学     |    98 |</span><br><span class="line">|  4 | sss     | Cs       | 数据库   |    96 |</span><br><span class="line">|  4 | sss     | Cs       | 计网     |    85 |</span><br><span class="line">|  5 | Frank   | Cs       | 数据库   |   100 |</span><br><span class="line">|  6 | BigHead | Math     | 数学     |    90 |</span><br><span class="line">|  6 | BigHead | Math     | 操作系统 |    80 |</span><br><span class="line">+<span class="comment">----+---------+----------+----------+-------+</span></span><br><span class="line">10 rows in <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure><p>自然连接 <code>natural join</code>  -&gt; 根据同名字段自动进行连接并且去掉重复列，不需要使用 <code>on</code>关键字</p><p>如果两张表没有同名字段返回笛卡尔积</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select * from student natural join score;</span><br><span class="line">+<span class="comment">----+---------+--------+------+----------+-----+-------+</span></span><br><span class="line">| id | name    | gender | age  | dept     | cno | grade |</span><br><span class="line">+<span class="comment">----+---------+--------+------+----------+-----+-------+</span></span><br><span class="line">|  1 | rain    | 男     |   23 | Cs       |   1 |    98 |</span><br><span class="line">|  1 | rain    | 男     |   23 | Cs       |   3 |    65 |</span><br><span class="line">|  1 | rain    | 男     |   23 | Cs       |   6 |    95 |</span><br><span class="line">|  2 | MIA     | 女     |   19 | Japanese |   5 |   100 |</span><br><span class="line">|  3 | free    | 男     |   18 | Math     |   2 |    98 |</span><br><span class="line">|  4 | sss     | 女     |   18 | Cs       |   1 |    96 |</span><br><span class="line">|  4 | sss     | 女     |   18 | Cs       |   4 |    85 |</span><br><span class="line">|  5 | Frank   | 男     |   28 | Cs       |   1 |   100 |</span><br><span class="line">|  6 | BigHead | 男     |   23 | Math     |   2 |    90 |</span><br><span class="line">|  6 | BigHead | 男     |   23 | Math     |   3 |    80 |</span><br><span class="line">+<span class="comment">----+---------+--------+------+----------+-----+-------+</span></span><br><span class="line">10 rows in <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure><p>左连接  <code>left join</code> - &gt;  以左表为基准连接右表,没有的值用null补全</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select student.id, student.name, score.cno, score.grade from student </span><br><span class="line">left join score on student.id = score.id;</span><br><span class="line">+<span class="comment">----+---------+------+-------+</span></span><br><span class="line">| id | name    | cno  | grade |</span><br><span class="line">+<span class="comment">----+---------+------+-------+</span></span><br><span class="line">|  1 | rain    |    1 |    98 |</span><br><span class="line">|  1 | rain    |    3 |    65 |</span><br><span class="line">|  1 | rain    |    6 |    95 |</span><br><span class="line">|  2 | MIA     |    5 |   100 |</span><br><span class="line">|  3 | free    |    2 |    98 |</span><br><span class="line">|  4 | sss     |    1 |    96 |</span><br><span class="line">|  4 | sss     |    4 |    85 |</span><br><span class="line">|  5 | Frank   |    1 |   100 |</span><br><span class="line">|  6 | BigHead |    2 |    90 |</span><br><span class="line">|  6 | BigHead |    3 |    80 |</span><br><span class="line">|  7 | Jashen  | NULL |  NULL |</span><br><span class="line">+<span class="comment">----+---------+------+-------+</span></span><br><span class="line">11 rows in <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; <span class="keyword">select</span> score.id, score.cno, course.name, score.grade <span class="keyword">from</span> score <span class="keyword">left</span> </span><br><span class="line"><span class="keyword">join</span> course <span class="keyword">on</span> score.cno = course.id;</span><br><span class="line">+<span class="comment">----+-----+----------+-------+</span></span><br><span class="line">| id | cno | name     | grade |</span><br><span class="line">+<span class="comment">----+-----+----------+-------+</span></span><br><span class="line">|  1 |   1 | 数据库   |    98 |</span><br><span class="line">|  1 |   3 | 操作系统 |    65 |</span><br><span class="line">|  1 |   6 | 数据结构 |    95 |</span><br><span class="line">|  2 |   5 | 日语     |   100 |</span><br><span class="line">|  3 |   2 | 数学     |    98 |</span><br><span class="line">|  4 |   1 | 数据库   |    96 |</span><br><span class="line">|  4 |   4 | 计网     |    85 |</span><br><span class="line">|  5 |   1 | 数据库   |   100 |</span><br><span class="line">|  6 |   2 | 数学     |    90 |</span><br><span class="line">|  6 |   3 | 操作系统 |    80 |</span><br><span class="line">+<span class="comment">----+-----+----------+-------+</span></span><br><span class="line">10 rows in <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure><p>右连接  <code>right join</code>-&gt; 已右排头为基准向右看齐</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select * from course; </span><br><span class="line">+<span class="comment">----+----------+---------+</span></span><br><span class="line">| id | name     | creadit |</span><br><span class="line">+<span class="comment">----+----------+---------+</span></span><br><span class="line">|  1 | 数据库   |       4 |</span><br><span class="line">|  2 | 数学     |       2 |</span><br><span class="line">|  3 | 操作系统 |       4 |</span><br><span class="line">|  4 | 计网     |       3 |</span><br><span class="line">|  5 | 日语     |       2 |</span><br><span class="line">|  6 | 数据结构 |       4 |</span><br><span class="line">|  7 | C语言    |       2 |</span><br><span class="line">+<span class="comment">----+----------+---------+</span></span><br><span class="line">7 rows in <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br><span class="line"></span><br><span class="line">mysql&gt;  <span class="keyword">select</span> score.id, score.cno, course.name, score.grade <span class="keyword">from</span> score <span class="keyword">right</span> <span class="keyword">join</span> course <span class="keyword">on</span> score.cno = course.id;</span><br><span class="line">+<span class="comment">------+------+----------+-------+</span></span><br><span class="line">| id   | cno  | name     | grade |</span><br><span class="line">+<span class="comment">------+------+----------+-------+</span></span><br><span class="line">|    1 |    1 | 数据库   |    98 |</span><br><span class="line">|    4 |    1 | 数据库   |    96 |</span><br><span class="line">|    5 |    1 | 数据库   |   100 |</span><br><span class="line">|    3 |    2 | 数学     |    98 |</span><br><span class="line">|    6 |    2 | 数学     |    90 |</span><br><span class="line">|    1 |    3 | 操作系统 |    65 |</span><br><span class="line">|    6 |    3 | 操作系统 |    80 |</span><br><span class="line">|    4 |    4 | 计网     |    85 |</span><br><span class="line">|    2 |    5 | 日语     |   100 |</span><br><span class="line">|    1 |    6 | 数据结构 |    95 |</span><br><span class="line">| NULL | NULL | C语言    |  NULL |</span><br><span class="line">+<span class="comment">------+------+----------+-------+</span></span><br><span class="line">11 rows in <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure><h4 id="子查询"><a href="#子查询" class="headerlink" title="子查询"></a>子查询</h4><p><code>in</code> and <code>not in</code></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#找出成绩中有大于 95 的所有学生信息</span></span><br><span class="line">mysql&gt; select * from student where id in (select score.id from score where grade &gt;= 95); </span><br><span class="line">+<span class="comment">----+-------+--------+------+----------+</span></span><br><span class="line">| id | name  | gender | age  | dept     |</span><br><span class="line">+<span class="comment">----+-------+--------+------+----------+</span></span><br><span class="line">|  1 | rain  | 男     |   23 | Cs       |</span><br><span class="line">|  2 | MIA   | 女     |   19 | Japanese |</span><br><span class="line">|  3 | free  | 男     |   18 | Math     |</span><br><span class="line">|  4 | sss   | 女     |   18 | Cs       |</span><br><span class="line">|  5 | Frank | 男     |   28 | Cs       |</span><br><span class="line">+<span class="comment">----+-------+--------+------+----------+</span></span><br><span class="line">5 rows in <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br><span class="line"></span><br><span class="line"><span class="comment">#返回所学科目任何一科都不大于95 的学生的信息</span></span><br><span class="line">mysql&gt; <span class="keyword">select</span> * <span class="keyword">from</span> student <span class="keyword">where</span> <span class="keyword">id</span> <span class="keyword">not</span> <span class="keyword">in</span> (<span class="keyword">select</span> score.id <span class="keyword">from</span> score <span class="keyword">where</span> grade &gt;= <span class="number">95</span>);</span><br><span class="line">+<span class="comment">----+---------+--------+------+------+</span></span><br><span class="line">| id | name    | gender | age  | dept |</span><br><span class="line">+<span class="comment">----+---------+--------+------+------+</span></span><br><span class="line">|  6 | BigHead | 男     |   23 | Math |</span><br><span class="line">|  7 | Jashen  | 男     |   22 | Math |</span><br><span class="line">+<span class="comment">----+---------+--------+------+------+</span></span><br><span class="line">2 rows in <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure><p><code>exists</code> and <code>not exists</code></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#如果存在符合子查询条件的返回值则执行父查询 </span></span><br><span class="line">mysql&gt; select * from student where exists (select score.id from score where </span><br><span class="line">grade = 100);</span><br><span class="line">+<span class="comment">----+---------+--------+------+----------+</span></span><br><span class="line">| id | name    | gender | age  | dept     |</span><br><span class="line">+<span class="comment">----+---------+--------+------+----------+</span></span><br><span class="line">|  1 | rain    | 男     |   23 | Cs       |</span><br><span class="line">|  2 | MIA     | 女     |   19 | Japanese |</span><br><span class="line">|  3 | free    | 男     |   18 | Math     |</span><br><span class="line">|  4 | sss     | 女     |   18 | Cs       |</span><br><span class="line">|  5 | Frank   | 男     |   28 | Cs       |</span><br><span class="line">|  6 | BigHead | 男     |   23 | Math     |</span><br><span class="line">|  7 | Jashen  | 男     |   22 | Math     |</span><br><span class="line">+<span class="comment">----+---------+--------+------+----------+</span></span><br><span class="line">7 rows in <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure><h2 id="视图的基本操作"><a href="#视图的基本操作" class="headerlink" title="视图的基本操作"></a>视图的基本操作</h2><p>视图的两种设计算法 -&gt; <code>temptable</code> (临时表算法)、 <code>merge</code></p><p>创建视图</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">view</span> vw_stu_all <span class="keyword">as</span> </span><br><span class="line"><span class="keyword">select</span> <span class="keyword">name</span>, phone, score <span class="keyword">from</span> student <span class="keyword">inner</span> <span class="keyword">join</span> score <span class="keyword">on</span> </span><br><span class="line">student.id = score.stuId;</span><br></pre></td></tr></table></figure><p>查看视图</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> vw_stu_all;</span><br></pre></td></tr></table></figure><p>查看视图创建的信息</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> <span class="keyword">create</span> <span class="keyword">view</span> vw_stu_all;</span><br></pre></td></tr></table></figure><p>查看视图的结构</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">desc vw_stu_all;</span><br></pre></td></tr></table></figure><p>修改视图</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">view</span> vw_stu_all <span class="keyword">as</span></span><br><span class="line"><span class="keyword">select</span> <span class="keyword">name</span> <span class="keyword">from</span> student;</span><br></pre></td></tr></table></figure><p>删除视图</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">drop</span> <span class="keyword">view</span> vw_stu_all;</span><br></pre></td></tr></table></figure><h2 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h2><p>开启事务 </p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; start transaction;</span><br></pre></td></tr></table></figure><p>事务提交 -&gt; <code>commit</code> –&gt; 事务一旦提交就不可以回滚</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select * from wallet;</span><br><span class="line">+<span class="comment">----+---------+</span></span><br><span class="line">| id | balance |</span><br><span class="line">+<span class="comment">----+---------+</span></span><br><span class="line">|  1 |   10.00 |</span><br><span class="line">|  2 |   19.25 |</span><br><span class="line">|  3 |   66.66 |</span><br><span class="line">+<span class="comment">----+---------+</span></span><br><span class="line">3 rows in <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; <span class="keyword">start</span> <span class="keyword">transaction</span>;</span><br><span class="line">Query OK, 0 rows affected (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; update wallet set balance=balance - 5 where id = 1;</span><br><span class="line">Query OK, 1 row affected (0.00 sec)</span><br><span class="line">Rows matched: 1  Changed: 1  Warnings: 0</span><br><span class="line"></span><br><span class="line">mysql&gt; update wallet set balance=balance + 5 where id = 2;</span><br><span class="line">Query OK, 1 row affected (0.00 sec)</span><br><span class="line">Rows matched: 1  Changed: 1  Warnings: 0</span><br><span class="line"></span><br><span class="line">mysql&gt; commit;</span><br><span class="line">Query OK, 0 rows affected (0.02 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; select * from wallet;</span><br><span class="line">+<span class="comment">----+---------+</span></span><br><span class="line">| id | balance |</span><br><span class="line">+<span class="comment">----+---------+</span></span><br><span class="line">|  1 |    5.00 |</span><br><span class="line">|  2 |   24.25 |</span><br><span class="line">|  3 |   66.66 |</span><br><span class="line">+<span class="comment">----+---------+</span></span><br><span class="line">3 rows in <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure><p>事务回滚 -&gt; <code>rollback</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; start transaction;</span><br><span class="line">Query OK, 0 rows affected (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; delete from wallet;</span><br><span class="line">Query OK, 3 rows affected (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; select * from wallet;</span><br><span class="line">Empty set (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; rollback;</span><br><span class="line">Query OK, 0 rows affected (0.01 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; select * from wallet;</span><br><span class="line">+----+---------+</span><br><span class="line">| id | balance |</span><br><span class="line">+----+---------+</span><br><span class="line">|  1 |    5.00 |</span><br><span class="line">|  2 |   24.25 |</span><br><span class="line">|  3 |   66.66 |</span><br><span class="line">+----+---------+</span><br><span class="line">3 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure><p>设置回滚点 -&gt; <code>savepoint</code></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; start transaction;</span><br><span class="line">Query OK, 0 rows affected (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; insert into wallet values (4,15.00);</span><br><span class="line">Query OK, 1 row affected (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; savepoint first;</span><br><span class="line">Query OK, 0 rows affected (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; insert into wallet values (5, 25.15);</span><br><span class="line">Query OK, 1 row affected (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; savepoint second;</span><br><span class="line">Query OK, 0 rows affected (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; rollback to first;</span><br><span class="line">Query OK, 0 rows affected (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; commit;</span><br><span class="line">Query OK, 0 rows affected (0.01 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; select * from wallet;</span><br><span class="line">+<span class="comment">----+---------+</span></span><br><span class="line">| id | balance |</span><br><span class="line">+<span class="comment">----+---------+</span></span><br><span class="line">|  1 |    5.00 |</span><br><span class="line">|  2 |   24.25 |</span><br><span class="line">|  3 |   67.66 |</span><br><span class="line">|  4 |   15.00 |</span><br><span class="line">+<span class="comment">----+---------+</span></span><br><span class="line">4 rows in <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure><h2 id="存储过程"><a href="#存储过程" class="headerlink" title="存储过程"></a>存储过程</h2><p>创建存储过程</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; delimiter //</span><br><span class="line">mysql&gt; create procedure proc()</span><br><span class="line">    -&gt; begin</span><br><span class="line">    -&gt; update teacher set name = 'Tom' where id = 1;</span><br><span class="line">    -&gt; update student set age= 18;</span><br><span class="line">    -&gt; end //</span><br><span class="line">Query OK, 0 rows affected (0.01 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt;  delimiter ;</span><br><span class="line">mysql&gt; select * from teacher;</span><br><span class="line">+<span class="comment">----+------+-------------+---------+</span></span><br><span class="line">| id | name | phone       | address |</span><br><span class="line">+<span class="comment">----+------+-------------+---------+</span></span><br><span class="line">|  1 | MIA  | 18192768186 | XIAN    |</span><br><span class="line">|  2 | rain | 17824852705 | DALIAN  |</span><br><span class="line">+<span class="comment">----+------+-------------+---------+</span></span><br><span class="line">3 rows in <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; <span class="keyword">call</span> proc();</span><br><span class="line">Query OK, 0 rows affected (0.01 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; select * from teacher;</span><br><span class="line">+<span class="comment">----+------+-------------+---------+</span></span><br><span class="line">| id | name | phone       | address |</span><br><span class="line">+<span class="comment">----+------+-------------+---------+</span></span><br><span class="line">|  1 | Tom  | 18192768186 | XIAN    |</span><br><span class="line">|  2 | rain | 17824852705 | DALIAN  |</span><br><span class="line">+<span class="comment">----+------+-------------+---------+</span></span><br><span class="line">3 rows in <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure><p>删除存储过程</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">drop</span> <span class="keyword">procedure</span> proc;</span><br></pre></td></tr></table></figure><h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><p><code>rand()</code> -&gt; 生成随机数</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select rand();</span><br><span class="line">+<span class="comment">---------------------+</span></span><br><span class="line">| rand()              |</span><br><span class="line">+<span class="comment">---------------------+</span></span><br><span class="line">| 0.07800444688462135 |</span><br><span class="line">+<span class="comment">---------------------+</span></span><br><span class="line">1 row in <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; <span class="keyword">select</span> * <span class="keyword">from</span> teacher <span class="keyword">order</span> <span class="keyword">by</span> <span class="keyword">rand</span>(); <span class="comment">#随机排序</span></span><br><span class="line">+<span class="comment">----+-------+-------------+----------+</span></span><br><span class="line">| id | name  | phone       | address  |</span><br><span class="line">+<span class="comment">----+-------+-------------+----------+</span></span><br><span class="line">|  5 | Frank | 12415452639 | 暂时未知 |</span><br><span class="line">|  4 | Jerry | 13803694825 | CHANGSHA |</span><br><span class="line">|  3 | 饭饭  | 15145124023 | beijing  |</span><br><span class="line">|  1 | Tom   | 18192768186 | XIAN     |</span><br><span class="line">|  2 | rain  | 17824852705 | DALIAN   |</span><br><span class="line">+<span class="comment">----+-------+-------------+----------+</span></span><br><span class="line">5 rows in <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; <span class="keyword">select</span> * <span class="keyword">from</span> teacher <span class="keyword">order</span> <span class="keyword">by</span> <span class="keyword">rand</span>() <span class="keyword">limit</span> <span class="number">3</span>; <span class="comment">#抽奖 -&gt; 随机从teacher表中抽取三条数据</span></span><br><span class="line">+<span class="comment">----+-------+-------------+----------+</span></span><br><span class="line">| id | name  | phone       | address  |</span><br><span class="line">+<span class="comment">----+-------+-------------+----------+</span></span><br><span class="line">|  2 | rain  | 17824852705 | DALIAN   |</span><br><span class="line">|  4 | Jerry | 13803694825 | CHANGSHA |</span><br><span class="line">|  3 | 饭饭  | 15145124023 | beijing  |</span><br><span class="line">+<span class="comment">----+-------+-------------+----------+</span></span><br><span class="line">3 row in <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure><p>向上取整</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select ceil(4.2);</span><br><span class="line">+<span class="comment">-----------+</span></span><br><span class="line">| ceil(4.2) |</span><br><span class="line">+<span class="comment">-----------+</span></span><br><span class="line">|         5 |</span><br><span class="line">+<span class="comment">-----------+</span></span><br><span class="line">1 row in <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure><p>向下取整</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select floor(4.2);</span><br><span class="line">+<span class="comment">------------+</span></span><br><span class="line">| floor(4.2) |</span><br><span class="line">+<span class="comment">------------+</span></span><br><span class="line">|          4 |</span><br><span class="line">+<span class="comment">------------+</span></span><br><span class="line">1 row in <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure><p>数据截取</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select truncate(3.1415926, 3);</span><br><span class="line">+<span class="comment">------------------------+</span></span><br><span class="line">| <span class="keyword">truncate</span>(<span class="number">3.1415926</span>, <span class="number">3</span>) |</span><br><span class="line">+<span class="comment">------------------------+</span></span><br><span class="line">|                  <span class="number">3.141</span> |</span><br><span class="line">+<span class="comment">------------------------+</span></span><br><span class="line"><span class="number">1</span> <span class="keyword">row</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure><p>字符串操作</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select lcase('RAIN');  #将字符串转换成小写</span><br><span class="line">+<span class="comment">---------------+</span></span><br><span class="line">| lcase('RAIN') |</span><br><span class="line">+<span class="comment">---------------+</span></span><br><span class="line">| rain          |</span><br><span class="line">+<span class="comment">---------------+</span></span><br><span class="line">1 row in <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; <span class="keyword">select</span> <span class="keyword">ucase</span>(<span class="string">'rain'</span>); <span class="comment">#将字符串转换成大写的</span></span><br><span class="line">+<span class="comment">---------------+</span></span><br><span class="line">| ucase('rain') |</span><br><span class="line">+<span class="comment">---------------+</span></span><br><span class="line">| RAIN          |</span><br><span class="line">+<span class="comment">---------------+</span></span><br><span class="line">1 row in <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; <span class="keyword">select</span> <span class="keyword">left</span>(<span class="string">'rain'</span>, <span class="number">2</span>); <span class="comment">#从左侧截取字符串</span></span><br><span class="line">+<span class="comment">-----------------+</span></span><br><span class="line">| left('rain', 2) |</span><br><span class="line">+<span class="comment">-----------------+</span></span><br><span class="line">| ra              |</span><br><span class="line">+<span class="comment">-----------------+</span></span><br><span class="line">1 row in <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; <span class="keyword">select</span> <span class="keyword">right</span>(<span class="string">'rain'</span>, <span class="number">2</span>); <span class="comment">#从右侧截取字符串</span></span><br><span class="line">+<span class="comment">------------------+</span></span><br><span class="line">| right('rain', 2) |</span><br><span class="line">+<span class="comment">------------------+</span></span><br><span class="line">| in               |</span><br><span class="line">+<span class="comment">------------------+</span></span><br><span class="line">1 row in <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; <span class="keyword">select</span> <span class="keyword">substring</span>(<span class="string">'rain is well'</span>, <span class="number">3</span>,<span class="number">5</span>); <span class="comment">#从指定位置截取字符串</span></span><br><span class="line">+<span class="comment">--------------------------------+</span></span><br><span class="line">| substring('rain is well', 3,5) |</span><br><span class="line">+<span class="comment">--------------------------------+</span></span><br><span class="line">| in is                          |</span><br><span class="line">+<span class="comment">--------------------------------+</span></span><br><span class="line">1 row in <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; <span class="keyword">select</span> <span class="keyword">concat</span>(<span class="string">'rain'</span>, <span class="string">'figthing'</span>);   <span class="comment">#拼接字符串</span></span><br><span class="line">+<span class="comment">----------------------------+</span></span><br><span class="line">| concat('rain', 'figthing') |</span><br><span class="line">+<span class="comment">----------------------------+</span></span><br><span class="line">| rainfigthing               |</span><br><span class="line">+<span class="comment">----------------------------+</span></span><br><span class="line">1 row in <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure><p>获取当前时间</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select now();</span><br><span class="line">+<span class="comment">---------------------+</span></span><br><span class="line">| now()               |</span><br><span class="line">+<span class="comment">---------------------+</span></span><br><span class="line">| 2021-10-02 21:45:28 |</span><br><span class="line">+<span class="comment">---------------------+</span></span><br><span class="line">1 row in <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure><p>获取<code>unix</code>时间戳</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"> mysql&gt; select unix_timestamp();</span><br><span class="line">+<span class="comment">------------------+</span></span><br><span class="line">| unix_timestamp() |</span><br><span class="line">+<span class="comment">------------------+</span></span><br><span class="line">|       1633182401 |</span><br><span class="line">+<span class="comment">------------------+</span></span><br><span class="line">1 row in <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure><p>数据加密函数</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select sha("jack loves rose");</span><br><span class="line">+<span class="comment">------------------------------------------+</span></span><br><span class="line">| sha("jack loves rose")                   |</span><br><span class="line">+<span class="comment">------------------------------------------+</span></span><br><span class="line">| 3247c2efec1e356224bac3044be2b2f6e9d0adee |</span><br><span class="line">+<span class="comment">------------------------------------------+</span></span><br><span class="line">1 row in <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;数据库的基本操作&quot;&gt;&lt;a href=&quot;#数据库的基本操作&quot; class=&quot;headerlink&quot; title=&quot;数据库的基本操作&quot;&gt;&lt;/a&gt;数据库的基本操作&lt;/h2&gt;&lt;p&gt;显示数据库&lt;/p&gt;
&lt;figure class=&quot;highlight sql&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;show&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;databases&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;</summary>
    
    
    
    
    <category term="MySQL" scheme="http://yoursite.com/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>进程间通信</title>
    <link href="http://yoursite.com/2021/09/26/%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1/"/>
    <id>http://yoursite.com/2021/09/26/%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1/</id>
    <published>2021-09-26T13:22:29.000Z</published>
    <updated>2021-10-07T13:20:27.238Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、进程-线程及协程"><a href="#一、进程-线程及协程" class="headerlink" title="一、进程 线程及协程"></a>一、进程 线程及协程</h1><h4 id="1、程序、进程、线程"><a href="#1、程序、进程、线程" class="headerlink" title="1、程序、进程、线程"></a>1、程序、进程、线程</h4><p>程序：通过某种语言编写的一组指令 ，即一段<strong>静态的代码</strong>。</p><p>进程：程序的一次执行过程。将程序加载入内存分配空间并执行，该段静态代码程序便拥有了<strong>动态性</strong>。<strong>系统运行一个程序即是一个进程从创建，运行到消亡的过程</strong>。如下图所示，在 ubuntu中通过查看任务管理器的方式，我们就可以清楚看到当前运行的进程。</p><a id="more"></a>  <img src="/2021/09/26/%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1/1.png" alt="1" style="zoom: 67%;"><p><strong>线程概念的出现</strong></p><p>进程的出现使操作系统的并发成为了可能，但是随着计算机的普及，人们对<strong>实时性</strong>有了更高的要求。一个进程在一段时间只能做一件事情，如果一个进程有多个任务，只能逐一的去执行这些子任务。然而这些子任务之间并不存在顺序上的依赖，因此人们想到既然CPU可以按照时间片的方式轮流的切换执行不同的进程，那为什么不能也同样给进程子任务打上标签，让CPU按照更细的时间片来执行子任务呢？由于子任务共享内存等资源，因此隶属于同一个进程的子任务之间的切换是不需要切换页目录以使用新的地址空间的，这就为子任务的快速切换提供了可能。此时人们便提出了线程，让一个线程去执行子任务，这样一个进程就包括了多个线程，每个线程去负责独立的子任务，这样让进程的内部并发成为了可能，就实现了实时性的目的。</p><p>线程：<strong>进程进一步细化为线程，是一个程序内部的一条执行路径</strong>。也叫做轻量级进程。</p><p>如下图所示，在<code>CCleaner</code> 这一应用程序中，我们同时执行<code>Health Check</code> 以及 <code>Custom Clean</code> 两项子任务即为多线程。</p><img src="/2021/09/26/%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1/5.png" alt="5" style="zoom:67%;"><h4 id="2、进程与线程的关系及区别"><a href="#2、进程与线程的关系及区别" class="headerlink" title="2、进程与线程的关系及区别"></a>2、进程与线程的关系及区别</h4><ul><li><strong>进程是资源分配的最小单位，线程是CPU调度的最小单位</strong></li><li>进程有独立的地址空间，相互不影响，多个线程只是进程的不同执行路径，共享其地址空间及资源</li><li>线程不能看做独立的应用，而进程可看作独立应用</li><li>多进程的程序比多线程的程序健壮</li><li>进程的切换比线程的切换开销大</li></ul><p><strong>注解</strong></p><p>进程是资源分配的基本单位，所有与该进程有关的资源都被记录在进程控制块PCB中，以表示该进程拥有或者正在使用这些资源。同时进程也是抢占处理机调度的单位，它拥有完整的虚拟内存和地址空间。当进程发生调度时，不同的进程拥有不同的虚拟地址空间，而同一进程中的不同线程共享同一地址空间。</p><p>线程与资源分配无关，它属于某一进程，并和该进程内的其他线程共享进程的资源。线程只由相关的堆、栈 寄存器、程序计数器和线程控制表TCB组成，其中寄存器用来存储线程内的局部变量，但并不存储其他线程的相关变量。每一个独立的线程有一个程序的入口、顺序执行序列以及程序的出口，但是线程并不能独立的执行，必须依存于某个应用程序中，由应用程序提供对多个线程的执行控制。</p><p>操作系统并没有将多个线程当作多个应用来实现进程的调度和管理以及资源的分配，而进程可作为独立的应用，拥有独立的内存空间。当一个进程崩溃后，在保护模式下并不会对其他进程产生影响，然而某个线程挂掉之后其所在的进程也会同样挂掉。</p><p>进程切换比线程切换开销大、耗费资源、效率差，对于要求同时进行，并且要求共享某些变量的并发操作只能用线程，不能用进程。</p><h4 id="3-协程"><a href="#3-协程" class="headerlink" title="3.协程"></a>3.协程</h4><p>用户级线程-&gt; 区别于进程和线程的调度是由操作系统决定，协程的调度由程序员控制</p><p><strong>协程的特点</strong></p><ol><li>线程的切换由操作系统负责调度，协程由用户自己进行调度，因此减少了上下文切换，提高了效率。</li><li>线程的默认Stack大小是1M，而协程更轻量，接近1K。因此可以在相同的内存中开启更多的协程。</li><li>由于在同一个线程上，因此可以避免竞争关系而使用锁。</li><li>适用于被阻塞的，且需要大量并发的场景。但不适用于大量计算的多线程，遇到此种情况，更好实用线程去解决</li></ol><h1 id="二、进程间通信"><a href="#二、进程间通信" class="headerlink" title="二、进程间通信"></a>二、进程间通信</h1><p><strong>进程间通信</strong>（<strong>IPC</strong>，<em>Inter-Process Communication</em>），指至少两个进程或线程间传送数据或信号的一些技术或方法。</p><h4 id="进程间通信的方式"><a href="#进程间通信的方式" class="headerlink" title="进程间通信的方式"></a>进程间通信的方式</h4><p><strong>管道pipe</strong>：管道是一种半双工的通信方式，数据只能单向流动，而且只能在具有亲缘关系的进程间使用。进程的亲缘关系通常是指父子进程关系。</p><ol><li><strong>命名管道FIFO</strong>：有名管道也是半双工的通信方式，但是它允许无亲缘关系进程间的通信。</li><li><strong>消息队列 Message Queue</strong>：消息队列是由消息的链表，存放在内核中并由消息队列标识符标识。消息队列克服了信号传递信息少、管道只能承载无格式字节流以及缓冲区大小受限等缺点。</li><li><strong>共享存储Shared Memory</strong>：共享内存就是映射一段能被其他进程所访问的内存，这段共享内存由一个进程创建，但多个进程都可以访问。共享内存是最快的 IPC 方式，它是针对其他进程间通信方式运行效率低而专门设计的。它往往与其他通信机制，如信号两，配合使用，来实现进程间的同步和通信。</li><li><strong>信号  Signals</strong>  ： 信号是一种比较复杂的通信方式，用于通知接收进程某个事件已经发生。</li><li><strong>信号量 Semaphore：</strong>信号量是一个计数器，可以用来控制多个进程对共享资源的访问。它常作为一种锁机制，防止某进程正在访问共享资源时，其他进程也访问该资源。因此，主要作为进程间以及同一进程内不同线程之间的同步手段。</li><li><strong>套接字 Socket：</strong>套解口也是一种进程间通信机制，与其他通信机制不同的是，它可用于不同及其间的进程通信。</li></ol>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;一、进程-线程及协程&quot;&gt;&lt;a href=&quot;#一、进程-线程及协程&quot; class=&quot;headerlink&quot; title=&quot;一、进程 线程及协程&quot;&gt;&lt;/a&gt;一、进程 线程及协程&lt;/h1&gt;&lt;h4 id=&quot;1、程序、进程、线程&quot;&gt;&lt;a href=&quot;#1、程序、进程、线程&quot; class=&quot;headerlink&quot; title=&quot;1、程序、进程、线程&quot;&gt;&lt;/a&gt;1、程序、进程、线程&lt;/h4&gt;&lt;p&gt;程序：通过某种语言编写的一组指令 ，即一段&lt;strong&gt;静态的代码&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;进程：程序的一次执行过程。将程序加载入内存分配空间并执行，该段静态代码程序便拥有了&lt;strong&gt;动态性&lt;/strong&gt;。&lt;strong&gt;系统运行一个程序即是一个进程从创建，运行到消亡的过程&lt;/strong&gt;。如下图所示，在 ubuntu中通过查看任务管理器的方式，我们就可以清楚看到当前运行的进程。&lt;/p&gt;</summary>
    
    
    
    
    <category term="操作系统" scheme="http://yoursite.com/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>java异常体系</title>
    <link href="http://yoursite.com/2021/08/20/java%E5%BC%82%E5%B8%B8%E4%BD%93%E7%B3%BB/"/>
    <id>http://yoursite.com/2021/08/20/java%E5%BC%82%E5%B8%B8%E4%BD%93%E7%B3%BB/</id>
    <published>2021-08-20T00:50:29.000Z</published>
    <updated>2021-08-20T07:09:24.962Z</updated>
    
    <content type="html"><![CDATA[<p>java 在设计之初就提供了相对完善的异常处理体制，在有效使用异常的情况下，java异常可以清楚的回答  what -&gt; 异常类型回答了什么被抛出 、where -&gt; 异常堆栈跟踪回答了在哪抛出、why -&gt; 异常信息回答了为什么被抛出 这三个问题；异常处理机制大大降低了编写和维护可靠程序的门槛；</p><a id="more"></a>  <h2 id="异常体系结构"><a href="#异常体系结构" class="headerlink" title="异常体系结构"></a>异常体系结构</h2><img src="/2021/08/20/java%E5%BC%82%E5%B8%B8%E4%BD%93%E7%B3%BB/image-20210820085820002.png" alt="image-20210820085820002" style="zoom: 80%;"><p><strong>从概念角度分析</strong></p><p>如上图所示：Throwable 是java 异常体系的顶层父类，他有两个子类，分别是Exception 和 Error 子类</p><ul><li>Error : 程序<strong>无法处理的系统错误</strong>，编译器不做检查 –&gt; 系统错误、虚拟机错误、内存空间不足、方法调用栈溢出等</li><li>Exception : 程序<strong>可以处理的异常</strong>、捕获后可能恢复</li></ul><p>Exception 异常又主要分为两大类 ，分别是 RuntimeException 和  非RuntimeException </p><ul><li>RuntimeException：<strong>不可预知的，程序应当自行避免</strong> -&gt; 数组下标越界、访问空指针等;</li><li>非RuntimeException：即 Checked Exception <strong>可以预知的，从编辑器校验的异常</strong>，从编译器角度讲是必须处理的异常，如果不处理程序就不能编译通过 -&gt; 文件不存在而打开文件的 IOException 等;</li></ul><p><strong>从责任角度分析</strong></p><ul><li>Error 属于 JVM 需要负担的责任</li><li>RuntimeException 是程序应该负担的责任</li><li>Checked Exception 可检查异常是 Java 编译器应该负担的责任</li></ul><h2 id="常见的-Error-以及-Exception"><a href="#常见的-Error-以及-Exception" class="headerlink" title="常见的 Error 以及 Exception"></a>常见的 Error 以及 Exception</h2><p><strong>RuntimeException</strong> </p><ul><li>NullPointerException -&gt; 空指针异常</li><li>ClassCastException -&gt; 类型强制转换异常</li><li>IllegalArgumentException -&gt; 传递非法参数异常</li><li>IndexOutOfBoundsException -&gt; 下标越界异常</li><li>NumberFormatException -&gt; 数字格式异常</li></ul><p><strong>非RuntimeException</strong></p><ul><li>ClassNotFoundException -&gt; 找不到指定 class 的异常 </li><li>IOException -&gt; IO操作异常</li></ul><p><strong>Error</strong></p><ul><li><p>StackOverflowError -&gt; 深递归导致栈被耗尽而抛出的异常</p></li><li><p>OutOfMemoryError -&gt; 内存溢出异常</p></li><li><p>NoClassDefFoundError -&gt; 找不到 class 定义的异常</p><p>​    1.类依赖的class 或者 jar 不存在</p><p>​    2.类文件存在，但是存在不同的域中</p><p>​    3.大小写问题，javac 编译的时候是无视大小写的，很有可能编译出来的 class 文件就与想要的不一样</p></li></ul><h2 id="异常处理机制"><a href="#异常处理机制" class="headerlink" title="异常处理机制"></a>异常处理机制</h2><h4 id="抛出异常"><a href="#抛出异常" class="headerlink" title="抛出异常"></a>抛出异常</h4><p><strong>创建异常对象，交由运行时系统处理</strong></p><p>当一个方法出现错误引发异常时，方法创建异常对象，并交付给运行时的系统，系统对象中包含了异常类型和异常出现时的程序状态等异常信息。运行时系统负责寻找处理异常的代码并执行，之后会捕获异常。</p><h4 id="捕获异常"><a href="#捕获异常" class="headerlink" title="捕获异常"></a>捕获异常</h4><p><strong>寻找合适的异常处理器处理异常，否则终止运行</strong></p><p>在方法抛出异常之后，运行时系统将转为寻找合适的异常处理器，潜在的异常处理是异常发生时依次存留在调用栈中的方法的集合，当异常处理器所能处理的异常类型与抛出的异常类型相符时即为合适的异常处理器。运行时系统从发生异常的方法开始，依次回查调用栈中的方法直到找到含有异常处理器的方法并执行，当运行时系统遍历了调用栈都没找到合适的异常处理器，则运行时系统终止，java程序终止！</p><img src="/2021/08/20/java%E5%BC%82%E5%B8%B8%E4%BD%93%E7%B3%BB/image-20210820150856114.png" alt="image-20210820150856114" style="zoom: 67%;"><h2 id="异常处理原则"><a href="#异常处理原则" class="headerlink" title="异常处理原则"></a>异常处理原则</h2><p>1.具体明确：抛出的异常应能通过异常类名和Message 准确说明异常的类型和产生异常的原因</p><p>2.提早抛出：应尽可能早的发现并抛出异常，便于精确定位问题 (子类方法不能抛出比父类方法更大的异常)</p><p>3.延迟捕获：异常的捕获和处理应尽可能的延迟，让掌握更多信息的作用域来处理异常 即-&gt; 抛给上层具体的业务类型来处理 </p><h2 id="异常处理关键字的使用"><a href="#异常处理关键字的使用" class="headerlink" title="异常处理关键字的使用"></a>异常处理关键字的使用</h2><p>Java 的异常机制主要依赖于 try、catch、finally、throw和throws五个关键字。</p><h4 id="throw-与-throws-关键字"><a href="#throw-与-throws-关键字" class="headerlink" title="throw 与 throws 关键字"></a>throw 与 throws 关键字</h4><p>throws 声明抛出只能在方法签名中使用，throws可以声明抛出多个异常类，多个异常类之间以逗号隔开。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CheckedExceptionTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//调用声明抛出Checked异常的方法,要么显式捕获该异常,要么在main方法中再次声明抛出</span></span><br><span class="line">            throwsChecked(<span class="number">1</span>);</span><br><span class="line">            <span class="comment">//此处的异常将不会被抛出 ===&gt; catch块一旦捕获异常try块将停止运行</span></span><br><span class="line">            throwsRuntime(<span class="number">4</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            System.out.println(e.getMessage());</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">throwsChecked</span><span class="params">(<span class="keyword">int</span> a)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">//抛出Exception异常,该代码必须处于try块里,或处于带throws声明的方法中</span></span><br><span class="line">        <span class="keyword">if</span> (a &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Exception(<span class="string">"Checked Exception -&gt; a的值大于零，不符合要求"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">throwsRuntime</span><span class="params">(<span class="keyword">int</span> a)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//自行抛出RuntimeException异常,既可以显式捕获该异常,也可完全不理会该异常,把该异常交给该方法调用者处理</span></span><br><span class="line">        <span class="keyword">if</span> (a &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"RuntimeException -&gt; a的值大于零，不符合要求"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>运行结果</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Checked Exception -&gt; a的值大于零，不符合要求</span><br><span class="line">java.lang.Exception: Checked Exception -&gt; a的值大于零，不符合要求</span><br><span class="line">at com.google.exception_handling.CheckedExceptionTest.throwsChecked(CheckedExceptionTest.java:25)</span><br><span class="line">at com.google.exception_handling.CheckedExceptionTest.main(CheckedExceptionTest.java:13)</span><br></pre></td></tr></table></figure><h4 id="try-catch-finally"><a href="#try-catch-finally" class="headerlink" title="try - catch - finally"></a>try - catch - finally</h4><p>通过下面的程序我们发现，finally 块中的程序 总是有优先于 catch 块的 return 语句之前执行</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = doWork();</span><br><span class="line">        System.out.println(<span class="string">"res = "</span> + res);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">doWork</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">int</span> i = <span class="number">10</span> / <span class="number">0</span>;</span><br><span class="line">            System.out.println(<span class="string">"i = "</span> + i);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ArithmeticException e) &#123;  <span class="comment">//异常一旦捕获将不会再向下执行</span></span><br><span class="line">            System.out.println(<span class="string">"ArithmeticException : "</span> + e);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            System.out.println(<span class="string">"Exception : "</span> + e);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">"Finally"</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">//        return 3;</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><strong>运行结果</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ArithmeticException : java.lang.ArithmeticException: &#x2F; by zero</span><br><span class="line">Finally</span><br><span class="line">res &#x3D; 2</span><br></pre></td></tr></table></figure><h4 id="java-7-以及-java-9-的增强功能"><a href="#java-7-以及-java-9-的增强功能" class="headerlink" title="java 7 以及 java 9 的增强功能"></a>java 7 以及 java 9 的增强功能</h4><p>java 7 的异常处理try块不在依赖于finally块来进行物理资源的关闭</p><p>try块可以单独存在 -&gt; 对于自动关闭资源的try语句， 可以没有catch和finally</p><p>Java 9再次增强了try语句，Java 9不要求在try后的圆括号内声明并创建资源，只需要自动关闭的资源有final修饰或者是有效的final，Java 9允许将资源变量放在try后的圆括号内</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="comment">//java 7 的try块处理资源回收的部分</span></span><br><span class="line">    <span class="keyword">try</span> (</span><br><span class="line">            <span class="comment">// 声明、初始化两个可关闭的资源 try语句会自动关闭这两个资源</span></span><br><span class="line">            BufferedReader br = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> FileReader(<span class="string">"hello.java"</span>));</span><br><span class="line">            PrintStream ps = <span class="keyword">new</span> PrintStream(<span class="keyword">new</span> FileOutputStream(<span class="string">"a.txt"</span>));</span><br><span class="line">    ) &#123;</span><br><span class="line">        System.out.println(br.readLine());</span><br><span class="line">        ps.println(<span class="string">"hello java"</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//java 9新增了java的try块的功能</span></span><br><span class="line">    <span class="keyword">final</span> BufferedReader br = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> FileReader(<span class="string">"AutoCloseTest2.java"</span>));</span><br><span class="line">    <span class="comment">//没有显式使用final修饰,但只要不对该变量重新赋值,该变量就是有效的final</span></span><br><span class="line">    PrintStream ps = <span class="keyword">new</span> PrintStream(<span class="keyword">new</span> FileOutputStream(<span class="string">"a.txt"</span>));</span><br><span class="line">    <span class="comment">// 只要将两个资源放在try后的圆括号内即可</span></span><br><span class="line">    <span class="keyword">try</span> (br; ps) &#123;</span><br><span class="line">        <span class="comment">// 使用两个资源</span></span><br><span class="line">        System.out.println(br.readLine());</span><br><span class="line">        ps.println(<span class="string">"庄生晓梦迷蝴蝶"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="如何设计一个高效主流的异常处理框架"><a href="#如何设计一个高效主流的异常处理框架" class="headerlink" title="如何设计一个高效主流的异常处理框架"></a>如何设计一个高效主流的异常处理框架</h2><p><strong>在用户看来，应用系统发生的所有异常都是应用系统内部的异常</strong></p><ul><li>设计一个通用的继承自 RuntimeException 的异常来统一处理</li><li>其余异常都统一转译上述异常 AppException</li><li>在 catch 之后，抛出上述异常的子类，并提供足已定位的信息</li><li>由前端接收 AppException 做统一处理</li></ul><h2 id="Java-异常处理消耗性能的地方"><a href="#Java-异常处理消耗性能的地方" class="headerlink" title="Java 异常处理消耗性能的地方"></a>Java 异常处理消耗性能的地方</h2><ul><li>try - catch 块影响 JVM 的优化</li><li>异常对象实例需要保存栈快照等信息，开销较大</li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;java 在设计之初就提供了相对完善的异常处理体制，在有效使用异常的情况下，java异常可以清楚的回答  what -&amp;gt; 异常类型回答了什么被抛出 、where -&amp;gt; 异常堆栈跟踪回答了在哪抛出、why -&amp;gt; 异常信息回答了为什么被抛出 这三个问题；异常处理机制大大降低了编写和维护可靠程序的门槛；&lt;/p&gt;</summary>
    
    
    
    
    <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>JVM垃圾回收机制</title>
    <link href="http://yoursite.com/2021/08/04/JVM%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6/"/>
    <id>http://yoursite.com/2021/08/04/JVM%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6/</id>
    <published>2021-08-04T02:03:05.000Z</published>
    <updated>2021-08-18T03:24:05.876Z</updated>
    
    <content type="html"><![CDATA[<h2 id="对象被判定为垃圾的标准"><a href="#对象被判定为垃圾的标准" class="headerlink" title="对象被判定为垃圾的标准"></a>对象被判定为垃圾的标准</h2><p>对于java对象来讲，当没有被任何对象所引用时，该对象就是没用的。对于系统而言它就是垃圾，其占据的内存就要被释放，同时该对象也要被销毁。</p><a id="more"></a> <p><strong>判断对象是否为垃圾的算法</strong></p><ul><li>引用计数算法</li><li>可达性分析算法</li></ul><h4 id="引用计数算法"><a href="#引用计数算法" class="headerlink" title="引用计数算法"></a>引用计数算法</h4><ul><li>通过判断对象的引用数量来判断对象是否可以被回收；</li><li>每个对象实例都是一个引用计数器，被引用则 + 1，完成引用则 - 1；</li><li>任何引用计数为0的对象实例可以被当作垃圾收集；</li></ul><p>引用计数算法通过判断对象的引用数量来决定对象是否可以被回收。在这种机制下，<strong>堆中的每一个对象实例都有一个引用计数器</strong>，当一个对象被创建时，若该对象实例分配给一个引用变量，该对象实例的引用变量则会被置为1，若该对象又被另一个对象所引用，则该对象的引用计数器继续+1。而当<strong>该对象的实例的某个引用</strong>超过了生命周期或者被置为一个新值时，该对象实例的引用计数器将会 -1，比如在某个方法中定义了一个引用变量，指向该对象实例，当方法结束的时，由于该引用变量是局部变量，存储在虚拟机栈上，方法结束后会被自动干掉，此时该实例变量的引用计数器便会 - 1。任何引用计数为 0 的对象实例都可以被当做垃圾收集。</p><p>采用此类算法的优势是可以快速的执行，因为我们只要过滤出引用计数为 0 的对象实例，将其内存回收即可，可以交织在程序运行中。由于垃圾回收的时候几乎不打断程序的执行，因此对程序需要不被长时间打断的实时环境有利 。<strong>这个方法实现简单，效率高，但是目前主流的虚拟机中并没有选择这个算法来管理内存，其最主要的原因是它很难解决对象之间相互循环引用的问题</strong>。如父对象有一个对子对象的引用，子对象又返回来引用父对象，这样引用计数永远不可能为 0。</p><h4 id="可达性分析算法"><a href="#可达性分析算法" class="headerlink" title="可达性分析算法"></a>可达性分析算法</h4><p>通过判断对象的引用链是否可达来决定对象是否可以被回收。</p><p>主流的java垃圾回收机制用的是可达性分析算法来对垃圾进行标记。可达性分析算法是通过判断对象的引用链是否可达来决定对象是否可以被回收的。可达性算法是从离散数学的图论引入的，程序把所有的引用关系看成一张图，通过一系列的名为 GC Root 的对象作为起始点，从这些起始点向下搜索，搜索所走过的路径被称做引用链。当一个对象从GC Root 开始没有与任何引用链相连，那么从图论上来说，即从GC Root 到该对象是不可达的，此时证明该对象是不可用的，它也就会被标记为垃圾。</p><img src="/2021/08/04/JVM%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6/image-20210805200054715.png" alt="image-20210805200054715" style="zoom: 80%;"><p>如上图所示，垃圾回收器会对内存中的整个对象进行遍历，从GC 根 ，即GC Root 开始，到根对象引用的其他对象，回收器将访问到的所有对象标记为存活，存活的对象在图中被标记为蓝色，即 Object 1、Object 2、Object 3，均为可达对象。在所有标记阶段被完成之后，所有存活对象已被标记完毕，其他那些比如图中灰色部分 Object 4、Object 5 就是GC 根对象不可达的对象，也就意味着应用不会在用到他们，回收器将会在回收阶段清除它们。 </p><p><strong>可以作为 GC Root 的对象</strong></p><ul><li>虚拟机栈中引用的对象 ： 比如java方法中new 了一个 Object 并赋值给一个局部变量，那么在该局部变量没有被销毁之前，new出来的Object 就会成为 GC Root。</li><li>方法区中的常量引用的对象 : 在类中定义了一个常量，而该常量保存的是某个对象的地址，那么被保存的对象也称为GC 的根对象，当别的对象引用到它的时候就会形成关系链。</li><li>方法区中的类静态属性引用的对象 </li><li>本地方法栈中 JNI(Native方法) 的引用对象</li><li>活跃线程的引用对象 ：java一切皆对象，因此活跃的线程也会成为 GC Root，只要线程还处于活跃状态，那么它引用的对象也被称为可达的。</li></ul><h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><p>无论是通过引用计数法判断对象引用数量，还是通过可达性分析法判断对象的引用链是否可达，判定对象的存活都与“引用”有关。</p><p>JDK1.2 之前，Java 中引用的定义很传统：如果 reference 类型的数据存储的数值代表的是另一块内存的起始地址，就称这块内存代表一个引用。</p><p>JDK1.2 以后，Java 对引用的概念进行了扩充，将引用分为强引用、软引用、弱引用、虚引用四种（引用强度逐渐减弱）</p><p><strong>1．强引用（StrongReference）</strong></p><p>以前我们使用的大部分引用实际上都是强引用，这是使用最普遍的引用。如果一个对象具有强引用，垃圾回收器绝不会回收它。当内存空间不足，Java 虚拟机宁愿抛出 OutOfMemoryError 错误，使程序异常终止，也不会靠随意回收具有强引用的对象来解决内存不足问题。</p><p><strong>2．软引用（SoftReference）</strong></p><p>如果一个对象只具有软引用，如果内存空间足够，垃圾回收器就不会回收它，如果内存空间不足了，就会回收这些对象的内存。只要垃圾回收器没有回收它，该对象就可以被程序使用。软引用可用来实现内存敏感的高速缓存。</p><p>软引用可以和一个引用队列（ReferenceQueue）联合使用，如果软引用所引用的对象被垃圾回收，JAVA 虚拟机就会把这个软引用加入到与之关联的引用队列中。</p><p><strong>3．弱引用（WeakReference）</strong></p><p>弱引用与软引用的区别在于：只具有弱引用的对象拥有更短暂的生命周期。在垃圾回收器线程扫描它所管辖的内存区域的过程中，一旦发现了只具有弱引用的对象，不管当前内存空间足够与否，都会回收它的内存。不过由于垃圾回收器是一个优先级很低的线程， 因此不一定会很快发现那些只具有弱引用的对象。</p><p>弱引用可以和一个引用队列（ReferenceQueue）联合使用，如果弱引用所引用的对象被垃圾回收，Java 虚拟机就会把这个弱引用加入到与之关联的引用队列中。</p><p><strong>4．虚引用（PhantomReference）</strong></p><p>“虚引用”顾名思义，就是形同虚设，与其他几种引用都不同，虚引用并不会决定对象的生命周期。如果一个对象仅持有虚引用，那么它就和没有任何引用一样，在任何时候都可能被垃圾回收。<strong>虚引用主要用来跟踪对象被垃圾回收的活动</strong>。</p><p><strong>虚引用与软引用和弱引用的一个区别在于：</strong> 虚引用必须和引用队列（ReferenceQueue）联合使用。当垃圾回收器准备回收一个对象时，如果发现它还有虚引用，就会在回收对象的内存之前，把这个虚引用加入到与之关联的引用队列中。程序可以通过判断引用队列中是否已经加入了虚引用，来了解被引用的对象是否将要被垃圾回收。程序如果发现某个虚引用已经被加入到引用队列，那么就可以在所引用的对象的内存被回收之前采取必要的行动。</p><p>特别注意，在程序设计中一般很少使用弱引用与虚引用，使用软引用的情况较多，这是因为<strong>软引用可以加速 JVM 对垃圾内存的回收速度，可以维护系统的运行安全，防止内存溢出（OutOfMemory）等问题的产生</strong>。</p><h2 id="垃圾收集算法"><a href="#垃圾收集算法" class="headerlink" title="垃圾收集算法"></a>垃圾收集算法</h2><ul><li>标记-清除算法</li><li>复制算法</li><li>标记-整理算法</li><li>分代收集算法</li></ul><h3 id="标记-清除算法-Mark-and-Sweep"><a href="#标记-清除算法-Mark-and-Sweep" class="headerlink" title="标记-清除算法(Mark and Sweep)"></a>标记-清除算法(Mark and Sweep)</h3><ul><li>标记：从根集合进行扫描，对存活的对象进行标记</li><li>清除：对堆内存从头到尾进行线性遍历，回收不可达对象内存</li></ul><img src="/2021/08/04/JVM%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6/image-20210806084405663.png" alt="image-20210806084405663" style="zoom:80%;"><p>该算法将回收分为标记和清除两个阶段，先从根节点进行扫描，对已经存活的对象进行标记，用的是可达性分析算法，标记完成后会对堆内存从头到尾进行线性遍历，如果发现某对象没有被标记为可达对象，就会将次对象占用的内存回收。并且将原来已标记为可达对象的标识给清除掉，以便进行下一次垃圾回收。 </p><p><strong>空间问题 - 碎片化</strong></p><p>由于该算法不需要进行对象的移动，并且仅对不存活的对象进行处理，因此标记清除之后，会产生大量不连续的内存碎片。内存碎片太多会导致以后程序运行过程中需要分配较大的对象时，无法找到足够的连续内存，而不得不提前触发另一次垃圾收集动作。</p><h3 id="复制算法-Copying"><a href="#复制算法-Copying" class="headerlink" title="复制算法(Copying)"></a>复制算法(Copying)</h3><ul><li>分为对象面和空闲面</li><li>对象在对象面上创建</li><li>存活的对象被从对象面复制到空闲面</li><li>将对象面所有对象内存清除</li></ul><img src="/2021/08/04/JVM%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6/image-20210806091340603.png" alt="image-20210806091340603"><p>复制算法将可用内存按容量、比例划分为两个或者多个块，并选择其中的一块或者两块作为对象面，其他的则作为空闲面。对象主要是在对象面上创建的，当被定义的对象面块的内存快用完时，就将还活着的对象复制到其中一块空闲面上，再将已使用的内存空间一次清理掉。</p><p><strong>这种算法解决了碎片化的问题、顺序分配内存，简单高效、适用于对象存活率低的场景</strong>，比如年轻代，这样使得每次都对整个半区进行内存回收，内存分配时也就不用考虑内存碎片等复杂情况，推倒重建只需要移动堆顶指针按顺序分配内存即可。</p><p>事实上现在商用的虚拟机都采用这种算法来回收年轻代，因为年轻代中的对象每次回收都基本上有10%左右的对象存活，所以需要复制的对象很少。</p><h3 id="标记-整理算法"><a href="#标记-整理算法" class="headerlink" title="标记-整理算法"></a>标记-整理算法</h3><ul><li>标记：从根集合中进行扫描，对存活的对象进行标记</li><li>清除：移动所有存活的对象，且按照内存地址次序依次排列，然后将末端内存地址以后的内存全部回收。</li></ul><p><img src="/2021/08/04/JVM%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6/image-20210806101737937.png" alt="image-20210806101737937"></p><p>复制回收算法在应对对象存活率较高的情况就不好用了，要进行较多的复制操作，效率就会变低，更关键的是，如果不想浪费50%的空间就需要有额外的空间进行分配担保以应对被使用的内存中所有对象都100%存活的极端情况，所以在老年代中一般并不会适用复制算法，而是采用标记整理算法。</p><p> 标记-整理算法它采用同标记-清除算法相同的方式对对象进行标记，但在清除阶段不同，<strong>标记-整理算法是在标记清除算法的基础上又进行了对象的移动</strong>，因此成本更高，但也解决了内存碎片的问题。</p><h3 id="分代收集算法-Generation-Collector"><a href="#分代收集算法-Generation-Collector" class="headerlink" title="分代收集算法(Generation Collector)"></a>分代收集算法(Generation Collector)</h3><ul><li>垃圾回收算法的组合拳</li><li>按照对象生命周期的不同划分区域以采取不同的垃圾回收算法</li><li>提高JVM 的回收效率</li></ul><p>分代收集算法可以理解为组合拳，将堆内存进一步划分，不同的对象的生命周期和存活情况也不一样，将不同生命周期的对象分配到堆中不同的区域并对堆内存的不同区域采用不同的回收策略进行回收是可以提高JVM回收效率。</p><h4 id="java堆结构"><a href="#java堆结构" class="headerlink" title="java堆结构"></a>java堆结构</h4><p>Java 堆是垃圾收集器管理的主要区域，因此也被称作<strong>GC 堆（Garbage Collected Heap）</strong>由于现在收集器基本都采用分代垃圾收集算法，所以 Java 堆还可以细分为：年轻代和老年代，再细致一点有：Eden 空间、From Survivor、To Survivor 空间等。<strong>进一步划分的目的是更好地回收内存，或者更快地分配内存。</strong></p><p>我们知道jdk7及jdk7以前java的堆内存一般可以分为 Young Generation 年轻代、Old Generation 老年代、以及Permanent Generation 永久代，而 jdk8及以后 永久代就被去掉了，仅保留年轻代和老年代。下图所示的 Eden 区、From Survivor0(“From”) 区、To Survivor1(“To”) 区都属于新生代，Old Memory 区属于老年代。</p><p>从垃圾回收的角度，<strong>年轻代的对象存活率低就会采用复制算法，而老年代的存活率高就采用标记-清除算法或者标记整理算法</strong>。</p><img src="/2021/08/04/JVM%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6/1.png" alt="1" style="zoom: 67%;"><p><strong>常用的调优参数</strong></p><ul><li><code>-XX:SurvivorRatio</code> : Eden 和 Survivor 的比值，默认为 8 ：1</li><li><code>-XX:NewRatio</code>: 老年代和年轻代内存大小的比值</li><li><code>-XX:MaxTenuringThreshold</code> : 对象从年轻代晋升到老年代经过 GC 次数的最大阈值</li></ul><h4 id="GC-的分类"><a href="#GC-的分类" class="headerlink" title="GC 的分类"></a>GC 的分类</h4><ul><li>Minor GC</li><li>Full GC</li></ul><p>分代收集的算法主要分为两种，分别了 Minor GC 和 Full GC , Minor GC 是发生在年轻代中的复制算法，年轻代几乎是所有java 对象出生的地方，即 java对象申请的内存以及存放都是在这里发生的。java 中的大部分对象通常不需要长久的存活，具有朝生夕灭的性质。当一个对象被判定为死亡时，GC 就有责任来回收掉这部分对象的内存空间。新生代是GC 收集垃圾的频繁区域。第二种GC 方式与老年代相关，由于对老年代的回收一般会伴随年轻代的垃圾收集，因此第二种方式被命名为Full GC。</p><h5 id="Minor-GC"><a href="#Minor-GC" class="headerlink" title="Minor GC"></a>Minor GC</h5><p>大部分情况，对象都会首先在 Eden 区域分配，<strong>若Eden区放不下新创建的对象也可能被放到Survivor区或者老年代中去</strong>。两个Survivor 区分别被定义为 “From”区和 “To”区，并且并没有明确规定，会随着垃圾回收的进行而相互转换。</p><p>在一次新生代垃圾回收后，如果对象还存活，则会进入 s0 或者 s1，并且对象的年龄还会加 1(Eden 区-&gt;Survivor 区后对象的初始年龄变为1)，<strong>当它的年龄增加到一定程度（默认为大于 15 岁），就会被晋升到老年代中</strong>。</p><h5 id="Full-GC"><a href="#Full-GC" class="headerlink" title="Full GC"></a>Full GC</h5><p>在年轻代中的对象经过一定次数的回收后依然存活并且年龄超过了晋升阈值时，将会进入老年代，因此可以认为老年代中存放的都是生命周期较长的对象。老年代的内存要比新生代的内存要大，大概的比例为2：1。</p><p>大批对象死去少量对象存活的新生代，使用的是复制算法，复制成本较低；而对象存活率较高，没有额外空间进行分配担保的老年代则采用标记-清理算法或者标记-整理算法进行回收。</p><p><img src="/2021/08/04/JVM%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6/image-20210806151741410.png" alt="image-20210806151741410"></p><p>当触发老年代的垃圾回收时通常也会伴随着对新生代堆内存的回收，即对整个堆进行垃圾回收，这便是所谓的Full GC</p><p>Major GC 通常与 Full GC 是等价的(Major GC 要分清楚是年轻代的GC 还是老年代中的GC)，即收集整个GC 堆。Full GC 的速度通常比 Minor GC 慢得多，一般会慢10倍以上，不过一般情况下，老年代中的对象大多数是在Survivor中熬过来的，他们是不会那么容易死掉的，因此Full GC发生的次数不会比 Major GC那么频繁。</p><p><strong>触发Full GC 的条件</strong></p><p>1、老年代空间不足：如果创建一个大对象，Eden 区域放不下这个对象，就会直接保存在老年代中，如果老年代空间也不足就会触发Full GC,为了避免这种情况最好就是不要创建太大的对象。</p><p>2、永久代空间不足：仅仅针对jdk7及以前版本，当系统中需要加载的类调用的方法很多，同时永久代中没有足够的空间去存放我们需要的类的信息和方法的信息就会触发 Full GC, 而jdk8以后取消了永久代所以该条件不成立。这也是为什么用元空间替代永久代的原因，为的是降低 Full GC 的频率，减少GC的负担，提升其效率。</p><p>3、CMS GC 时出现 promotion failed, concurrent mode failure ： 对于采用 CMS 进行老年代的程序而言尤其要注意 GC 日志中是否有promotion failed, concurrent mode failure 这两种情况，当这两种日志出现的时候可能会触发 Full GC </p><p>4、Minor GC 晋升到老年代的平均大小大于老年代的剩余空间：<code>HotSpot</code> 为了避免由于新生代对象晋升到老年代导致老年代空间不足的现象，在进行Minor GC 时做了一个判断，如果之前统计所得到了Minor GC晋升到老年代的平均大小大于老年代的剩余空间，那么就直接触发Full GC.</p><p>5、调用 <code>System.gc()</code> : 在程序中直接调用 <code>System.gc()</code>会显示触发 Full GC  ,同时对老年代和年轻代进行回收，这个方法只是提醒虚拟机，码农需要你回收一下，但是虚拟机执不执行由虚拟机自己决定，码农没有绝对的控制权。</p><p>6、使用RMI来进行 RPC 或管理的JDK 应用，每小时执行1次Full GC</p><h2 id="垃圾收集器"><a href="#垃圾收集器" class="headerlink" title="垃圾收集器"></a>垃圾收集器</h2><h3 id="相关概念"><a href="#相关概念" class="headerlink" title="相关概念"></a>相关概念</h3><p><strong>Stop - the - World</strong></p><p>Stop - the - World 意味着 JVM 由于要执行 GC线程，而停止了应用程序的执行，并且这种情况会在任何一种GC 算法中发生。当 Stop - the - world 发生时，除了GC 所需要的线程外，所有线程都处于等待状态，直到GC 任务完成。</p><p>实际上GC优化很多时候就是要减少 Stop - the - World 发生的时间，从而使系统具有高吞吐低停顿的特点。</p><p><strong>Safepoint</strong></p><p>JVM垃圾回收中在可达性分析中，要分析哪个对象有没有被引用的时候，必须在一个快照点进行。此时所有线程被冻结，不可以出现在分析的过程中对象的引用关系还在不停变化的情况，因此分析的结果需要在某个节点具有确定性，该节点便叫做安全点。程序并不是随便到达哪个点便停下来，而是到达安全点才停止。一般在方法调用、循环跳转、异常跳转才会产生安全点。一旦GC 发生就让所有的线程都跑到最新的安全点，再停顿下来。如果发现线程不在安全点就恢复线程等其跑到安全点。安全点的选择不能太少，因为太少会让GC等待时间太长，也不能太多，因为太多会增加程序的负荷。</p><p><strong>JVM的运行模式</strong></p><p>JVM有两种运行模式，即 Client 和 Server，Client 启动较快、Server 启动较慢，但是启动进入稳定期后，Server 运行更快。因为Server 采用的是重量级的虚拟机而 Client 采用的则是轻量级的虚拟机，所有Server 启动慢但是运行起来后快。</p><p>查看当前虚拟机处于那种模式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">C:\Users\hermi&gt;java -version</span><br><span class="line">java version &quot;9.0.4&quot;</span><br><span class="line">Java(TM) SE Runtime Environment (build 9.0.4+11)</span><br><span class="line">Java HotSpot(TM) 64-Bit Server VM (build 9.0.4+11, mixed mode)</span><br></pre></td></tr></table></figure><h3 id="常见的垃圾收集器"><a href="#常见的垃圾收集器" class="headerlink" title="常见的垃圾收集器"></a>常见的垃圾收集器</h3><ul><li><code>Serial</code> 收集器</li><li><code>ParNew</code> 收集器</li><li><code>Parallel Scavenge</code> 收集器</li><li><code>CMS</code> 收集器</li><li><code>G1</code> 收集器</li></ul><h4 id="Serial-收集器"><a href="#Serial-收集器" class="headerlink" title="Serial 收集器"></a>Serial 收集器</h4><ul><li>单线程收集，进行垃圾收集时，必须暂停所有工作线程</li><li>简单高效，Client 模式下默认的年轻代收集器</li></ul><p><img src="/2021/08/04/JVM%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6/2.png" alt="2"></p><p>Serial 收集器是java 虚拟机中最基本，历史也最悠久的收集器，在jdk1.3之前是java虚拟机年轻代收集的唯一选择，Serial 收集器是采用复制算法的单线程垃圾收集器，<strong>它的单线程意义并不只是说明它只适用于一个CPU或者一条收集线程去实现垃圾回收工作，更重要的是在它进行垃圾回收时必须暂停其他所有的工作线程直到它收集结束</strong> (<strong>“Stop The World”</strong> ）。虚拟机的设计者们当然知道 Stop The World 带来的不良用户体验，所以在后续的垃圾收集器设计中停顿时间在不断缩短（仍然还有停顿，寻找最优秀的垃圾收集器的过程仍然在继续）。</p><p>到目前为止，Serial 收集器依然是虚拟机运行在Client 模式下的默认年轻代收集器，因为其简单高效，在用户桌面应用中分配给虚拟机管理的内存一般不会很大，收集几十兆甚至一两百兆年轻代的停顿时间会在几十毫秒到一百毫秒之间完成。只要不是频繁的发生这里的停顿是完全可以接受的。</p><h4 id="ParNew收集器"><a href="#ParNew收集器" class="headerlink" title="ParNew收集器"></a>ParNew收集器</h4><ul><li>多线程收集，其余的行为、特点和Serial 收集器一样</li><li>单核执行效率不如Serial,在多核下执行才有优势</li></ul><p><img src="/2021/08/04/JVM%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6/3.png" alt="3"></p><p>ParNew 收集器采用的是复制算法的多线程收集，其余行为、特点和Serial 收集器一样。它是Server模式下虚拟机首选的年轻代收集器。在单个 CPU 环境中，并不会比 Serial 收集器好，因为存在线程的交互开销。当随着可用 CPU 数量的增加，对于GC 池以及系统资源的利用更好，默认开启的线程数与CPU 数量相同。同时除了 Serial 收集器外，只有它能与 CMS 收集器配合工作。</p><h4 id="Parallel-Scavenge-收集器"><a href="#Parallel-Scavenge-收集器" class="headerlink" title="Parallel Scavenge 收集器"></a>Parallel Scavenge 收集器</h4><ul><li>比起关注用户线程停顿时间，更关注系统的吞吐量</li><li>在多核下执行才有优势，Server 模式下默认的年轻代收集器</li></ul><p><img src="/2021/08/04/JVM%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6/4.png" alt="4"></p><p>Parallel Scavenge 收集器也是使用复制算法的多线程收集器，它看上去几乎和 ParNew 都一样，但是<strong>Parallel Scavenge 收集器关注点是吞吐量（高效率的利用 CPU）。CMS 等垃圾收集器的关注点更多的是用户线程的停顿时间（提高用户体验）。所谓吞吐量就是 CPU 中用于运行用户代码的时间与 CPU 总消耗时间的比值。</strong></p><p> Parallel Scavenge 收集器提供了很多参数供用户找到最合适的停顿时间或最大吞吐量，如果对于收集器运作不太了解，手工优化存在困难的时候，使用 Parallel Scavenge 收集器配合自适应调节策略，把内存管理优化交给虚拟机去完成也是一个不错的选择。</p><h4 id="Serial-Old-收集器"><a href="#Serial-Old-收集器" class="headerlink" title="Serial Old 收集器"></a>Serial Old 收集器</h4><ul><li>单线程收集，进行垃圾收集时，必须暂停所有工作线程</li><li>简单高效，Client 模式下默认的老年代收集器</li></ul><p><img src="/2021/08/04/JVM%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6/2.png" alt="2"></p><p><strong>Serial Old 收集器是Serial 收集器的老年代版本，采用的是标记整理算法</strong>。除了采用的垃圾收集算法和Serial 的不同以外，其他的都和Serial 类似。它主要有两大用途：一种用途是在 JDK1.5 以及以前的版本中与 Parallel Scavenge 收集器搭配使用，另一种用途是作为 CMS 收集器的后备方案。</p><h4 id="Parallel-Old-收集器"><a href="#Parallel-Old-收集器" class="headerlink" title="Parallel Old 收集器"></a>Parallel Old 收集器</h4><ul><li>多线程，吞吐量优先</li></ul><p><img src="/2021/08/04/JVM%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6/4.png" alt="4"></p><p><strong>Parallel Scavenge 收集器的老年代版本</strong>。<strong>使用多线程和“标记-整理”算法</strong>。 该收集器是在jdk6以后提供的，在此之前新生代的 Parallel Scavenge 收集器一直处于比较尴尬的状态–&gt; 如果新生代选择Parallel Scavenge 收集器，老年代除了选择 Serial Old 收集器以外别无选择。由于到年代 Serial Old 收集器在服务端的拖累，使用Parallel Scavenge 收集器也未必能在整体应用上获得吞吐量最大化的效果。由于单线程的老年代收集中无法充分利用服务器多CPU 的处理能力。在老年代很大而且硬件比较高级的环境中这种组合的吞吐量还不一定有 ParNew + CMS 的组合强。</p><p>直到 Parallel Old 收集器出现以后，吞吐量优先收集器终于有了比较名副其实的应用组合，在注重吞吐量以及 CPU 资源的场合，都可以优先考虑 Parallel Scavenge 收集器和 Parallel Old 收集器。</p><h4 id="CMS-收集器"><a href="#CMS-收集器" class="headerlink" title="CMS 收集器"></a>CMS 收集器</h4><p><strong>CMS（Concurrent Mark Sweep）收集器是一种以获取最短回收停顿时间为目标的收集器。它非常符合在注重用户体验的应用上使用。</strong></p><p>CMS（Concurrent Mark Sweep）收集器是 HotSpot 虚拟机第一款真正意义上的并发收集器，它第一次实现了让垃圾收集线程与用户线程（基本上）同时工作。从名字中的<strong>Mark Sweep</strong>这两个词可以看出，CMS 收集器是一种 <strong>“标记-清除”算法</strong>实现的，它的运作过程相比于前面几种垃圾收集器来说更加复杂一些。整个过程分为四个步骤：</p><ul><li><strong>初始标记：</strong> stop -the - world 暂停所有的其他线程，并记录下直接与 root 相连的对象并做标记 ，速度很快 ；</li><li><strong>并发标记：</strong> 同时开启 GC 和用户线程，用一个闭包结构去记录可达对象。但在这个阶段结束，这个闭包结构并不能保证包含当前所有  的可达对象。因为用户线程可能会不断的更新引用域，所以 GC 线程无法保证可达性分析的实时性。所以这个算法里会跟踪记录这些发生引用更新的地方。</li><li><strong>重新标记：</strong> stop -the - world 重新标记阶段就是为了修正并发标记期间因为用户程序继续运行而导致标记产生变动的那一部分对象的标记记录，这个阶段的停顿时间一般会比初始标记阶段的时间稍长，远远比并发标记阶段时间短</li><li><strong>并发清除：</strong> 清除垃圾对象，程序不会停顿。</li></ul><p><img src="/2021/08/04/JVM%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6/5.png" alt="5"></p><p>CMS主要优点：<strong>并发收集、低停顿</strong>。但是它有下面三个明显的缺点：</p><ul><li><strong>对 CPU 资源敏感；</strong></li><li><strong>无法处理浮动垃圾；</strong></li><li><strong>它使用的回收算法-“标记-清除”算法会导致收集结束时会有大量空间碎片产生。</strong></li></ul><h4 id="G1收集器"><a href="#G1收集器" class="headerlink" title="G1收集器"></a>G1收集器</h4><p><strong>G1 (Garbage-First) 是一款面向服务器的垃圾收集器,主要针对配备多颗处理器及大容量内存的机器. 以极高概率满足 GC 停顿时间要求的同时,还具备高吞吐量性能特征。</strong></p><p> <strong>G1收集器是既适用于年轻代也适用于老年代的垃圾收集器，采用 复制 + 标记整理算法</strong></p><p>与其他的收集器相比，G1收集器具有如下特点：</p><ul><li><strong>并行与并发</strong>：G1 能充分利用 CPU、多核环境下的硬件优势，使用多个 CPU（CPU 或者 CPU 核心）来缩短 Stop-The-World 停顿时间。部分其他收集器原本需要停顿 Java 线程执行的 GC 动作，G1 收集器仍然可以通过并发的方式让 java 程序继续执行。</li><li><strong>分代收集</strong>：虽然 G1 可以不需要其他收集器配合就能独立管理整个 GC 堆，但是还是保留了分代的概念。</li><li><strong>空间整合</strong>：与 CMS 的“标记-清理”算法不同，G1 从整体来看是基于“标记-整理”算法实现的收集器；从局部上来看是基于“标记-复制”算法实现的。</li><li><strong>可预测的停顿</strong>：这是 G1 相对于 CMS 的另一个大优势 ，降低停顿时间是 G1 和 CMS 共同的关注点，但 G1 除了追求低停顿外，还能建立可预测的停顿时间模型，能让使用者明确指定在一个长度为 M 毫秒的时间片段内。</li></ul><p>G1 收集器的运作大致分为以下几个步骤：</p><ul><li><strong>初始标记</strong></li><li><strong>并发标记</strong></li><li><strong>最终标记</strong></li><li><strong>筛选回收</strong></li></ul><p>在Garbage First 之前的垃圾收集器收集的范围都是整个年轻代或者老年代的，Garbage First 不再是这样。使用 G1 收集器时 java 堆的内存能布局与其他的收集器有很大的差别。它会将整个java 堆内存划分成多个大小相同的独立区域 Region ，虽然还保留有新生代和老年代的概念，但是新生代和老年代不再是物理隔离的啦，他们是可以不连续的 Region 的集合。</p><h3 id="垃圾收集器之间的联系"><a href="#垃圾收集器之间的联系" class="headerlink" title="垃圾收集器之间的联系"></a>垃圾收集器之间的联系</h3><p>如下图所示：如果两个收集器之间有连线说明它们可以搭配使用</p><p><img src="/2021/08/04/JVM%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6/image-20210807093408009.png" alt="image-20210807093408009"></p><p><strong>如果说收集算法是内存回收的方法论，那么垃圾收集器就是内存回收的具体实现。</strong></p><p>虽然我们对各个收集器进行比较，但并非要挑选出一个最好的收集器。因为直到现在为止还没有最好的垃圾收集器出现，更加没有万能的垃圾收集器，<strong>我们能做的就是根据具体应用场景选择适合自己的垃圾收集器</strong>。</p><h4 id="老年代的-CMS-收集器不能与年轻代的-Parallel-Scavenge-收集器兼容使用"><a href="#老年代的-CMS-收集器不能与年轻代的-Parallel-Scavenge-收集器兼容使用" class="headerlink" title="老年代的 CMS 收集器不能与年轻代的 Parallel Scavenge 收集器兼容使用"></a>老年代的 CMS 收集器不能与年轻代的 Parallel Scavenge 收集器兼容使用</h4><p>CMS 是 HotSpot 在jdk5 推出的真正意义上的收集器，第一次实现了让垃圾收集线程与用户线程同时工作。CMS 作为老年代的收集器但却无法与jdk4已经存在的  Parallel Scavenge 收集器配合使用，因为 Parallel Scavenge 以及 G1收集器都没有使用传统的GC 收集器代码框架，而是独立实现的。其余的收集器都共用了部分代码框架，因此可以搭配使用。</p><p><strong>参考资料</strong></p><ul><li><a href="https://github.com/Snailclimb/JavaGuide/blob/master/docs/java/jvm/JVM%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6.md#4-%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8" target="_blank" rel="noopener">JavaGuide - JVM垃圾回收</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;对象被判定为垃圾的标准&quot;&gt;&lt;a href=&quot;#对象被判定为垃圾的标准&quot; class=&quot;headerlink&quot; title=&quot;对象被判定为垃圾的标准&quot;&gt;&lt;/a&gt;对象被判定为垃圾的标准&lt;/h2&gt;&lt;p&gt;对于java对象来讲，当没有被任何对象所引用时，该对象就是没用的。对于系统而言它就是垃圾，其占据的内存就要被释放，同时该对象也要被销毁。&lt;/p&gt;</summary>
    
    
    
    
    <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>排序算法</title>
    <link href="http://yoursite.com/2021/07/21/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"/>
    <id>http://yoursite.com/2021/07/21/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/</id>
    <published>2021-07-21T03:38:43.000Z</published>
    <updated>2021-08-27T13:37:12.483Z</updated>
    
    <content type="html"><![CDATA[<h2 id="排序算法概述"><a href="#排序算法概述" class="headerlink" title="排序算法概述"></a>排序算法概述</h2><p>排序算法主要分为内部排序和外部排序两大类别</p><ul><li>内部排序 ：将数据加载进内存进行排序</li><li>外部排序 ：使用内存和外存相结合的方式对数据进行排序</li></ul><a id="more"></a>  <img src="/2021/07/21/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/0.png" alt="0"><p><strong>相关概念</strong></p><ul><li>稳定：如果a原本在b前面，而a=b，排序之后a仍然在b的前面</li><li>不稳定：如果a原本在b的前面，而a=b，排序之后 a 可能会出现在 b 的后面</li><li>时间复杂度：对排序数据的总的操作次数。反映当n变化时，操作次数呈现什么规律</li><li>空间复杂度：指算法在计算机内执行时所需存储空间的度量，它也是数据规模n的函数</li><li>k代表数值中的”数位”个数</li><li>n代表数据规模</li><li>m代表数据的最大值减最小值</li></ul><table><thead><tr><th>排序算法</th><th>平均时间复杂度</th><th>最坏时间复杂度</th><th>最好时间复杂度</th><th>空间复杂度</th><th>稳定性</th></tr></thead><tbody><tr><td>冒泡排序</td><td>O(n2)</td><td>O(n2)</td><td>O(n)</td><td>O(1)</td><td><img src="https://upload.wikimedia.org/wikipedia/commons/thumb/f/fb/Yes_check.svg/15px-Yes_check.svg.png" alt="img"></td></tr><tr><td>插入排序</td><td>O(n2)</td><td>O(n2)</td><td>O(n)</td><td>O(1)</td><td><img src="https://upload.wikimedia.org/wikipedia/commons/thumb/f/fb/Yes_check.svg/15px-Yes_check.svg.png" alt="img"></td></tr><tr><td>选择排序</td><td>O(n2)</td><td>O(n2)</td><td>O(n2)</td><td>O(1)</td><td><img src="https://upload.wikimedia.org/wikipedia/commons/thumb/a/a2/X_mark.svg/15px-X_mark.svg.png" alt="img"></td></tr><tr><td>快速排序</td><td>O(nlogn)</td><td>O(n2)</td><td>O(nlogn)</td><td>O(nlogn)</td><td><img src="https://upload.wikimedia.org/wikipedia/commons/thumb/a/a2/X_mark.svg/15px-X_mark.svg.png" alt="img"></td></tr><tr><td>希尔排序</td><td>O(nlogn)</td><td>O(n2)</td><td>O(n)</td><td>O(1)</td><td><img src="https://upload.wikimedia.org/wikipedia/commons/thumb/a/a2/X_mark.svg/15px-X_mark.svg.png" alt="img"></td></tr><tr><td>堆排序</td><td>O(nlogn)</td><td>O(nlogn)</td><td>O(nlogn)</td><td>O(1)</td><td><img src="https://upload.wikimedia.org/wikipedia/commons/thumb/a/a2/X_mark.svg/15px-X_mark.svg.png" alt="img"></td></tr><tr><td>归并排序</td><td>O(nlogn)</td><td>O(nlogn)</td><td>O(nlogn)</td><td>O(n)</td><td><img src="https://upload.wikimedia.org/wikipedia/commons/thumb/f/fb/Yes_check.svg/15px-Yes_check.svg.png" alt="img"></td></tr><tr><td>计数排序</td><td>O(n + m)</td><td>O(n + m)</td><td>O(n + m)</td><td>O(n + m)</td><td><img src="https://upload.wikimedia.org/wikipedia/commons/thumb/f/fb/Yes_check.svg/15px-Yes_check.svg.png" alt="img"></td></tr><tr><td>桶排序</td><td>O(n + m)</td><td>O(n2)</td><td>O(n)</td><td>O(n + m)</td><td><img src="https://upload.wikimedia.org/wikipedia/commons/thumb/f/fb/Yes_check.svg/15px-Yes_check.svg.png" alt="img"></td></tr><tr><td>基数排序</td><td>O(n * k)</td><td>O(n * k)</td><td>O(n * k)</td><td>O(n + k)</td><td><img src="https://upload.wikimedia.org/wikipedia/commons/thumb/f/fb/Yes_check.svg/15px-Yes_check.svg.png" alt="img"></td></tr></tbody></table><h2 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h2><h4 id="基本思想"><a href="#基本思想" class="headerlink" title="基本思想"></a>基本思想</h4><p>通过对待排序序列从前向后（从下标较小的元素开始）,依次比较相邻元素的值，若发现逆序则交换，使值较大的元素逐渐从前移向后部，就象水底下的气泡一样逐渐向上冒。</p><h4 id="冒泡排序的优化"><a href="#冒泡排序的优化" class="headerlink" title="冒泡排序的优化"></a>冒泡排序的优化</h4><p>因为排序的过程中，各元素不断接近自己的位置，如果一趟比较下来没有进行过交换，就说明序列有序，因此要在排序过程中设置一个标志 flag 判断元素是否进行过交换。从而减少不必要的比较。</p><h4 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">bubbleSort</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length - <span class="number">1</span>; i++) &#123; <span class="comment">//一共进行 arr.length - 1 次大循环-&gt; 每次冒往出冒一个</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; arr.length - <span class="number">1</span> - i; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[j] &gt; arr[j + <span class="number">1</span>]) &#123;</span><br><span class="line">                <span class="keyword">int</span> temp = arr[j];</span><br><span class="line">                arr[j] = arr[j + <span class="number">1</span>];</span><br><span class="line">                arr[j + <span class="number">1</span>] = temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>优化</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">bubbleSort</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> flag = <span class="keyword">false</span>; <span class="comment">//flag 初始为 false</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; arr.length - <span class="number">1</span> - i; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[j] &gt; arr[j + <span class="number">1</span>]) &#123;</span><br><span class="line">                flag = <span class="keyword">true</span>; <span class="comment">//如果在一次小的循环中发生了交换则将 flag 置为 true</span></span><br><span class="line">                arr[j + <span class="number">1</span>] = arr[j] + arr[j + <span class="number">1</span>];</span><br><span class="line">                arr[j] = arr[j + <span class="number">1</span>] - arr[j];</span><br><span class="line">                arr[j + <span class="number">1</span>] = arr[j + <span class="number">1</span>] - arr[j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!flag) <span class="keyword">break</span>; <span class="comment">//如果判断小循环中没有发生交换则表示序列已经有序 --&gt; 直接退出循环即可</span></span><br><span class="line">        <span class="keyword">else</span> flag = <span class="keyword">false</span>; <span class="comment">//重置 flag</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h2><h4 id="基本思想-1"><a href="#基本思想-1" class="headerlink" title="基本思想"></a>基本思想</h4><ul><li>从数组中取出一个数，称之为基数（pivot）</li><li>遍历数组，将比基数大的数字放到它的右边，比基数小的数字放到它的左边。遍历完成后，数组被分成了左右两个区域</li><li>将左右两个区域视为两个数组，重复前两个步骤，递归排序即可</li></ul><h4 id="基准元素的选择"><a href="#基准元素的选择" class="headerlink" title="基准元素的选择"></a>基准元素的选择</h4><p>快速排序是首先定义基准元素 –&gt; 基准元素的选取一般分三种</p><ul><li>数组起始元素–&gt; 下标为0</li><li>数组的末尾元素 –&gt; 下标为 <code>arr.length - 1</code></li><li>随机选取</li></ul><p>选择的基数不同，算法的实现也不同。实际上随机选取的方式的平均时间复杂度是最优的。</p><h4 id="分区方法的设计"><a href="#分区方法的设计" class="headerlink" title="分区方法的设计"></a>分区方法的设计</h4><p>分区方法的目的包括</p><ul><li>将当前数组元素按照基准元素分区，将比基数大的数字放到它的右边，比基数小的数字放到它的左边。</li><li>返回当前基准元素的下标 ，为接下来的递归分区确定边界。 –&gt; 基准值的下标在分区的过程是不断变化的</li></ul><h4 id="递归退出的条件"><a href="#递归退出的条件" class="headerlink" title="递归退出的条件"></a>递归退出的条件</h4><p>我们定义两个指针L， R， 初始分别指向数组的起始和末尾位置  –&gt; L = 0; R =<code>arr.length</code> - 1；</p><p>在递归的过程中根据<strong>基准元素下标的变化</strong>动态的调整 L 及 R ,当 <strong>L &gt;= R 时即退出递归</strong></p><ul><li>L = R ：分区中只有一个元素 </li><li>L &gt; R：分区中没有元素</li></ul><h4 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h4><p><strong>移动”填坑法”实现分区方法</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">quickSort</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> L, <span class="keyword">int</span> R)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (L &gt; R) <span class="keyword">return</span>;  <span class="comment">//递归推出的条件</span></span><br><span class="line">    <span class="keyword">int</span> pivotIndex = partition(arr, L, R); <span class="comment">//将数组分区,并返回基准值下标</span></span><br><span class="line">    quickSort(arr, L, pivotIndex - <span class="number">1</span>); <span class="comment">//对左侧分区进行递归排序</span></span><br><span class="line">    quickSort(arr, pivotIndex + <span class="number">1</span>, R); <span class="comment">//对右侧分区进行递归排序</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">partition</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> L, <span class="keyword">int</span> R)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> left = L;</span><br><span class="line">    <span class="keyword">int</span> right = R;</span><br><span class="line">    <span class="keyword">int</span> pivot = arr[left]; <span class="comment">//选取数组起始元素为基准值</span></span><br><span class="line">    <span class="keyword">while</span> (left != right) &#123;</span><br><span class="line">        <span class="comment">//从右向左遍历找到第一个小于基准值的元素</span></span><br><span class="line">        <span class="keyword">while</span> (right &gt; left &amp;&amp; arr[right] &gt;= pivot) right--;</span><br><span class="line">        arr[left] = arr[right]; <span class="comment">//挖坑-&gt; 将right位置处的元素挖走放到 left处</span></span><br><span class="line">        <span class="comment">//从左向右遍历找到第一个比基准值大的元素</span></span><br><span class="line">        <span class="keyword">while</span> (left &lt; right &amp;&amp; arr[left] &lt;= pivot) left++;</span><br><span class="line">        arr[right] = arr[left]; <span class="comment">//填坑 -&gt; 将当前left处的元素填到之前挖走的 right地址处</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//退出循环时-&gt; 基准元素左侧全部小于基准值，基准元素右侧全部大于基准值</span></span><br><span class="line">    arr[right] = pivot; <span class="comment">//将基准值归位</span></span><br><span class="line">    <span class="keyword">return</span> left; <span class="comment">//返回基准值的当前下标位置,为之后递归分区确定边界, 此时left == right 都指向基准值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>交换法实现分区方法</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">quickSort</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> L, <span class="keyword">int</span> R)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (L &gt; R) <span class="keyword">return</span>;  </span><br><span class="line">    <span class="keyword">int</span> pivotIndex = partition(arr, L, R);</span><br><span class="line">    quickSort(arr, L, pivotIndex - <span class="number">1</span>);</span><br><span class="line">    quickSort(arr, pivotIndex + <span class="number">1</span>, R);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">partition</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> L, <span class="keyword">int</span> R)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> left = L;</span><br><span class="line">    <span class="keyword">int</span> right = R;</span><br><span class="line">    <span class="keyword">int</span> pivot = arr[left]; <span class="comment">//定义基准值</span></span><br><span class="line">    <span class="keyword">while</span> (left != right) &#123;</span><br><span class="line">        <span class="keyword">while</span> (right &gt; left &amp;&amp; arr[right] &gt;= pivot) right--;</span><br><span class="line">        <span class="keyword">while</span> (left &lt; right &amp;&amp; arr[left] &lt;= pivot) left++;</span><br><span class="line">        swap(arr, left, right);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//退出循环后 left 及 right 相等 -&gt; 同时指向从左到右最后一个小于基准值的元素</span></span><br><span class="line">    swap(arr, left, L); <span class="comment">//将基准值归位 --&gt; 此时基准元素左侧全部小于基准值 基准元素右侧全部大于基准值</span></span><br><span class="line">    <span class="keyword">return</span> left;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> temp = arr[i];</span><br><span class="line">    arr[i] = arr[j];</span><br><span class="line">    arr[j] = temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h2><h4 id="基本思想-2"><a href="#基本思想-2" class="headerlink" title="基本思想"></a>基本思想</h4><p>把 n 个待排序的元素看成为<strong>一个有序表和一个无序表</strong>，开始时有序表中只包含一个元素，无序表中包含有 n-1 个元素，排序过程中每次从无序表中取出第一个元素，并依次与有序表中的元素值进行比较，将它插入到有序表中的适当位置，使之成为新的有序表。</p><h4 id="代码实现-2"><a href="#代码实现-2" class="headerlink" title="代码实现"></a>代码实现</h4><p><strong>交换法</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insertSort</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &gt;= <span class="number">1</span> &amp;&amp; arr[j] &lt; arr[j - <span class="number">1</span>]; j--) &#123;</span><br><span class="line">            <span class="keyword">int</span> temp = arr[j];</span><br><span class="line">            arr[j] = arr[j - <span class="number">1</span>];</span><br><span class="line">            arr[j - <span class="number">1</span>] = temp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>移动法</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">insertSort</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> curInsertValue = arr[i]; <span class="comment">//先将待插入的元素存储起来 --&gt; 前面的元素后移会覆盖它</span></span><br><span class="line">        <span class="keyword">int</span> j = i - <span class="number">1</span>; <span class="comment">//从待插入的元素前一个元素开始逐个遍历 并 与待插入元素比较 如果大于待插入元素则向后移动</span></span><br><span class="line">        <span class="keyword">while</span> (j &gt;= <span class="number">0</span> &amp;&amp; arr[j] &gt; curInsertValue) &#123;</span><br><span class="line">            arr[j + <span class="number">1</span>] = arr[j];</span><br><span class="line">            j--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//循环跳出后 --&gt;前面有序数列中空出的位置即为待插入元素的位置 --&gt; 直接赋值即可</span></span><br><span class="line">        arr[j + <span class="number">1</span>] = curInsertValue;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h2><h4 id="基本思想-3"><a href="#基本思想-3" class="headerlink" title="基本思想"></a>基本思想</h4><p>希尔排序是把记录按下标的一定增量分组，对每组使用直接插入排序算法排序；</p><p>随着增量逐渐减少，每组包含的元素越来越多，当增量减至 1 时，所有元素恰被分成一组。</p><h4 id="算法图解"><a href="#算法图解" class="headerlink" title="算法图解"></a>算法图解</h4><img src="/2021/07/21/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/1.png" alt="1" style="zoom: 80%;"><h4 id="代码实现-3"><a href="#代码实现-3" class="headerlink" title="代码实现"></a>代码实现</h4><p><strong>交换法 -&gt; 分组 + 冒泡交换</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">shellSort</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//分组 -&gt; 以间隔 gap 进行分组 [arr[0], arr[0 + gap], arr[0 + gap + gap], ....]</span></span><br><span class="line">    <span class="comment">//每组中共有 arr.length / gap 个元素</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> gap = arr.length / <span class="number">2</span>; gap &gt; <span class="number">0</span>; gap /= <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="comment">//对组内元素进行直接插入排序 -&gt; 从 gap 开始，按照顺序将每个元素依次向前插入自己所在的组</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = gap; i &lt; arr.length; i++) &#123; </span><br><span class="line">            <span class="comment">//在有序序列中依次与待插入元素进行比较，j + gap -&gt; 始终指向待插入元素</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i - gap; j &gt;= <span class="number">0</span>; j -= gap) &#123;</span><br><span class="line">                <span class="comment">//将待插入元素冒泡到当前分组的合适位置</span></span><br><span class="line">                <span class="keyword">if</span> (arr[j] &gt; arr[j + gap]) &#123;</span><br><span class="line">                    <span class="keyword">int</span> temp = arr[j];</span><br><span class="line">                    arr[j] = arr[j + gap];</span><br><span class="line">                    arr[j + gap] = temp;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>移动法 -&gt; 分组 + 插入移动 ==&gt; 真正的希尔排序</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">shellSort</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> gap = arr.length / <span class="number">2</span>; gap &gt; <span class="number">0</span>; gap /= <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = gap; i &lt; arr.length; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> curInsertValue = arr[i]; <span class="comment">//保存当前待插入的元素</span></span><br><span class="line">            <span class="keyword">int</span> j = i - gap; <span class="comment">//在当前分组中,从待插入元素的前一个元素进行比较</span></span><br><span class="line">            <span class="keyword">while</span> (j &gt;= <span class="number">0</span> &amp;&amp; arr[j] &gt; curInsertValue) &#123;</span><br><span class="line">                arr[j + gap] = arr[j]; <span class="comment">//将所有比待插入元素大的元素后移</span></span><br><span class="line">                j -= gap;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//循环退出后 j + gap 的指向即为 待插入元素的合适位置</span></span><br><span class="line">            arr[j + gap] = curInsertValue;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="简单选择排序"><a href="#简单选择排序" class="headerlink" title="简单选择排序"></a>简单选择排序</h2><h4 id="基本思想-4"><a href="#基本思想-4" class="headerlink" title="基本思想"></a>基本思想</h4><p>从欲排序的数据中，按指定的规则选出某一元素，再依规定交换位置后达到排序的目的。</p><p>同冒泡排序一样都是双层循环，只不过选择排序是每次选定外层循环为基准值 -&gt; 代表最小值；内层循环每次找到当前循环的最小值，并与外层的基准元素进行交换。每次都将最小值交换到序列头部，当外层循环结束的时，序列自然有序~</p><h4 id="代码实现-4"><a href="#代码实现-4" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">selectSort</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> minIndex = i; <span class="comment">//记录最小值下标</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; arr.length; j++) &#123; <span class="comment">//找到最小值下标</span></span><br><span class="line">            <span class="keyword">if</span> (arr[minIndex] &gt; arr[j]) &#123;</span><br><span class="line">                minIndex = j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//循环退出后  minIndex -&gt; 最小值下标 -&gt; 与基准值交换</span></span><br><span class="line">        <span class="keyword">int</span> temp = arr[i];</span><br><span class="line">        arr[i] = arr[minIndex];</span><br><span class="line">        arr[minIndex] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h2><h4 id="基本思想-5"><a href="#基本思想-5" class="headerlink" title="基本思想"></a>基本思想</h4><p>将无序序列构建成一个堆，根据升序或者降序要求选择大顶堆或者小顶堆</p><p>将堆顶元素与末尾元素交换 ==&gt; 将最大元素”沉”到数组的末端</p><p>每次交换之后重新调整结构 使其满足堆结构，然后继续交换堆顶元素与当前末尾元素 反复交换 + 调整 直到整个序列有序</p><p><strong>注意</strong></p><p>堆排序并不是要我们真的建立一颗二叉树 而是借助 顺序存储二叉树的思想 将数据存储从数组形式 ==&gt; 二叉树的存储形式</p><p>本质仍然是从一个数组的一般排序状态 ===&gt; 当前数组的特定排序状态</p><h4 id="与简单选择排序的区别"><a href="#与简单选择排序的区别" class="headerlink" title="与简单选择排序的区别"></a>与简单选择排序的区别</h4><p>选择排序每次通过全盘扫描的方式找到当前循环的最大值 而堆排序是通过创建堆结构的形式通过取出堆顶元素找到当前循环的最大值</p><h4 id="代码实现-5"><a href="#代码实现-5" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">heapSort</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//初始创建大顶堆 --&gt; 从右向左,自底向上构建</span></span><br><span class="line">    <span class="comment">//arr.length / 2 - 1 -&gt; 完全二叉树中最后一个非叶子节点的下标</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = arr.length / <span class="number">2</span> - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        adjustHeap(arr, i, arr.length);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = arr.length - <span class="number">1</span>; i &gt; <span class="number">0</span>; i--) &#123;</span><br><span class="line">        swap(arr, <span class="number">0</span>, i); <span class="comment">//将堆顶元素与末尾元素交换，将最大元素"沉"到数组末端</span></span><br><span class="line">        adjustHeap(arr, <span class="number">0</span>, i); <span class="comment">//在剩余数组空间上调整为大顶堆</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 将数组转换成 "局部大顶堆" --&gt;将以非叶子节点为根节点的子树调整为大顶堆</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> arr      待调整数组</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> i        非叶子节点在数组中的索引</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> heapSize 表示要对数组中多少个元素进行调整</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">adjustHeap</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> i, <span class="keyword">int</span> heapSize)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> l = <span class="number">2</span> * i + <span class="number">1</span>; <span class="comment">//左子节点</span></span><br><span class="line">    <span class="keyword">int</span> r = l + <span class="number">1</span>; <span class="comment">//右子节点</span></span><br><span class="line">    <span class="keyword">int</span> maxIndex = i; <span class="comment">//记录最大值的元素下标</span></span><br><span class="line">    <span class="keyword">if</span> (l &lt; heapSize &amp;&amp; arr[l] &gt; arr[maxIndex]) maxIndex = l;</span><br><span class="line">    <span class="keyword">if</span> (r &lt; heapSize &amp;&amp; arr[r] &gt; arr[maxIndex]) maxIndex = r;</span><br><span class="line">    <span class="keyword">if</span> (maxIndex != i) &#123;</span><br><span class="line">        swap(arr, i, maxIndex); <span class="comment">//将最大值交换为根节点</span></span><br><span class="line">        adjustHeap(arr, maxIndex, heapSize); <span class="comment">//保证交换后仍然是局部大顶堆</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> temp = arr[i];</span><br><span class="line">    arr[i] = arr[j];</span><br><span class="line">    arr[j] = temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h2><h4 id="基本思想-6"><a href="#基本思想-6" class="headerlink" title="基本思想"></a>基本思想</h4><p>归并排序（MERGE-SORT）是利用归并的思想实现的排序方法</p><p>先将整个待排序的数组向下分割成最小块，然后将最小单元按照排序规则向下逐渐进行组合</p><p><strong>注意：</strong></p><p>在拷贝到原数组时并不是只拷贝最后一次，而是从栈顶开始合并时就开始拷贝，一共合并<code>arr.length - 1</code> 次，所以也一共拷贝了<code>arr.length - 1</code>次</p><h4 id="算法图解-1"><a href="#算法图解-1" class="headerlink" title="算法图解"></a>算法图解</h4><img src="/2021/07/21/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/2.png" alt="2" style="zoom: 33%;"><h4 id="代码实现-6"><a href="#代码实现-6" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">mergeSort</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] temp = <span class="keyword">new</span> <span class="keyword">int</span>[arr.length];</span><br><span class="line">    mergeSort(arr, <span class="number">0</span>, arr.length - <span class="number">1</span>, temp);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">mergeSort</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> left, <span class="keyword">int</span> right, <span class="keyword">int</span>[] temp)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (left &lt; right) &#123;</span><br><span class="line">        <span class="keyword">int</span> mid = (left + right) / <span class="number">2</span>;</span><br><span class="line">        <span class="comment">//向左递归进行分解</span></span><br><span class="line">        mergeSort(arr, left, mid, temp);</span><br><span class="line">        <span class="comment">//向右递归进行分解</span></span><br><span class="line">        mergeSort(arr, mid + <span class="number">1</span>, right, temp);</span><br><span class="line">        <span class="comment">//从栈顶开始合并 一共合并 arr.length - 1 次</span></span><br><span class="line">        merge(arr, left, mid, right, temp);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 合并 + 拷贝</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> arr   待排序的原始数组</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> left  分区后的左边索引</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> mid   中间索引 -&gt; 左侧分区的最后一个元素下标</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> right 右侧索引</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> temp  辅助数组</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> left, <span class="keyword">int</span> mid, <span class="keyword">int</span> right, <span class="keyword">int</span>[] temp)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = left; <span class="comment">//初始化 i -&gt; 左边有序序列的初始索引</span></span><br><span class="line">    <span class="keyword">int</span> j = mid + <span class="number">1</span>; <span class="comment">// 初始化 j -&gt; 右边有序序列的初始索引</span></span><br><span class="line">    <span class="keyword">int</span> t = <span class="number">0</span>; <span class="comment">//t -&gt; 指向temp辅助数组的当前索引 初始为 0</span></span><br><span class="line">    <span class="comment">//1-&gt;如果左边有序序列的当前元素小于等于右边的有序序列的当前元素</span></span><br><span class="line">    <span class="comment">//即将左边的当前元素 填充到 temp数组中</span></span><br><span class="line">    <span class="keyword">while</span> (i &lt;= mid &amp;&amp; j &lt;= right) &#123;</span><br><span class="line">        <span class="keyword">if</span> (arr[i] &lt;= arr[j]) &#123;</span><br><span class="line">            temp[t] = arr[i];</span><br><span class="line">            t++;</span><br><span class="line">            i++;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123; <span class="comment">//反之 将右边的有序序列的当前元素 填充到 temp 数组中</span></span><br><span class="line">            temp[t] = arr[j];</span><br><span class="line">            t++;</span><br><span class="line">            j++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//2-&gt;将有剩余数据的一边的数据全部填充到temp</span></span><br><span class="line">    <span class="keyword">while</span> (i &lt;= mid) &#123; <span class="comment">//左边的有序序列还有剩余数据，就将全部的数据填充到temp中</span></span><br><span class="line">        temp[t] = arr[i];</span><br><span class="line">        t++;</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (j &lt;= right) &#123; <span class="comment">//右边的有序序列还有剩余数据，就将全部的数据填充到temp中</span></span><br><span class="line">        temp[t] = arr[j];</span><br><span class="line">        t++;</span><br><span class="line">        j++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//3-&gt;将temp数组的元素拷贝到arr</span></span><br><span class="line">    t = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> start = left; <span class="comment">//辅助拷贝指针 -&gt; 初始为 0</span></span><br><span class="line">    <span class="keyword">while</span> (start &lt;= right) &#123;</span><br><span class="line">        arr[start] = temp[t];</span><br><span class="line">        t++;</span><br><span class="line">        start++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="计数排序"><a href="#计数排序" class="headerlink" title="计数排序"></a>计数排序</h2><h4 id="直观的想法"><a href="#直观的想法" class="headerlink" title="直观的想法"></a>直观的想法</h4><ol><li>定义一个能够覆盖数组中最小值到最大值之间各数的数组 –&gt; 作为计数数组</li><li>从头到尾遍历数组中的各个元素，在计数数组中存储各个数字出现的次数</li><li>最后遍历计数数组，将每个元素输出，输出的次数就是对应位置记录的次数</li></ol><p><strong>[1,9]数字范围的代码实现如下：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">int</span>[] arr = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">9</span>, <span class="number">8</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">6</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">1</span>, <span class="number">8</span>, <span class="number">4</span>&#125;;</span><br><span class="line">       System.out.println(<span class="string">"排序前"</span> + Arrays.toString(arr));</span><br><span class="line">       countingSort(arr);</span><br><span class="line">       System.out.println(<span class="string">"排序后"</span> + Arrays.toString(arr));</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//对范围[1,9]的数进行排序</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">countingSort</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">int</span>[] count = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">9</span>];</span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> element : arr) &#123;</span><br><span class="line">           count[element - <span class="number">1</span>]++;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">9</span>; i++) &#123;</span><br><span class="line">           <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; count[i]; j++) &#123;</span><br><span class="line">               arr[index++] = i + <span class="number">1</span>;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p><strong>运行结果</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">排序前[1, 2, 3, 4, 5, 6, 9, 8, 2, 1, 1, 5, 7, 6, 4, 5, 6, 1, 8, 4]</span><br><span class="line">排序后[1, 1, 1, 1, 2, 2, 3, 4, 4, 4, 5, 5, 5, 6, 6, 6, 7, 8, 8, 9]</span><br></pre></td></tr></table></figure><p><strong>问题</strong></p><p>我们发现，在排序完成后，<code>arr</code> 中记录的元素已经不再是最开始的那个元素了，他们只是值相等，但却不是同一个对象。也就是说这样的算法实现是不稳定的—&gt; 因为被排序的对象往往都会携带其他的属性，但这份算法将被排序对象的其他属性都丢失了。</p><h4 id="计数排序的基本思想"><a href="#计数排序的基本思想" class="headerlink" title="计数排序的基本思想"></a>计数排序的基本思想</h4><p>通过上面的分析我们发现只是通过简单的统计然后按照下标来赋值这样的方式是不稳定的。那么我们可以通过计数的结果，先统计出每个元素在排序完成后的位置，然后将元素赋值到对应位置即可。</p><h4 id="算法图解-2"><a href="#算法图解-2" class="headerlink" title="算法图解"></a>算法图解</h4><img src="/2021/07/21/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/3.png" alt="3" style="zoom:80%;"><p><strong>[1,9]数字范围的代码实现如下：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">countingSort</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//定义一个长度为 9 的计数数组 -&gt; 对应元素 [1,9]</span></span><br><span class="line">    <span class="keyword">int</span>[] counting = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">9</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> element : arr) &#123;</span><br><span class="line">        <span class="comment">// 将每个整数出现的次数统计到计数数组中对应下标的位置</span></span><br><span class="line">        counting[element - <span class="number">1</span>]++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> pre = <span class="number">0</span>; <span class="comment">//pre -&gt; 记录前面比自己小的数字的总数</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; counting.length; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> temp = counting[i];</span><br><span class="line">        counting[i] = pre;</span><br><span class="line">        pre += temp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span>[] res = <span class="keyword">new</span> <span class="keyword">int</span>[arr.length];</span><br><span class="line">    <span class="comment">//将arr[]元素按照counting[]中存储的相应位置给res[]赋值</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> element : arr) &#123;</span><br><span class="line">        <span class="keyword">int</span> index = counting[element - <span class="number">1</span>];</span><br><span class="line">        res[index] = element;</span><br><span class="line">        <span class="comment">// 更新 counting[element - 1] -&gt; 特定</span></span><br><span class="line">        counting[element - <span class="number">1</span>]++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//将结果重新赋值回arr</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">        arr[i] = res[i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>优化代码使其适用于不同数字范围的的排序，代码实现如下：</p><h4 id="代码实现-gt-真正的计数排序"><a href="#代码实现-gt-真正的计数排序" class="headerlink" title="代码实现-&gt; 真正的计数排序"></a>代码实现-&gt; 真正的计数排序</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">countingSort</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (arr == <span class="keyword">null</span> || arr.length &lt;= <span class="number">1</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">int</span> max = arr[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">int</span> min = arr[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (arr[i] &gt; max) max = arr[i];</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (arr[i] &lt; min) min = arr[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> range = max - min + <span class="number">1</span>; <span class="comment">//确定计数范围</span></span><br><span class="line">    <span class="keyword">int</span>[] counting = <span class="keyword">new</span> <span class="keyword">int</span>[range];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> element : arr) &#123; <span class="comment">//统计各个元素个数</span></span><br><span class="line">        counting[element - min]++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> pre = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; range; i++) &#123; <span class="comment">//更新 counting -&gt; 确定位置</span></span><br><span class="line">        <span class="keyword">int</span> temp = counting[i];</span><br><span class="line">        counting[i] = pre;</span><br><span class="line">        pre += temp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span>[] res = <span class="keyword">new</span> <span class="keyword">int</span>[arr.length];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> element : arr) &#123;</span><br><span class="line">        res[counting[element - min]] = element;</span><br><span class="line">        counting[element - min]++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">        arr[i] = res[i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="桶排序"><a href="#桶排序" class="headerlink" title="桶排序"></a>桶排序</h2><h4 id="基本思想-7"><a href="#基本思想-7" class="headerlink" title="基本思想"></a>基本思想</h4><p>将数据集划分多个范围相同的区间，每个自区间自排序，最后合并。</p><h4 id="与计数排序的联系"><a href="#与计数排序的联系" class="headerlink" title="与计数排序的联系"></a>与计数排序的联系</h4><p>桶排序是对计数排序的改进，计数排序申请的额外空间跨度从最小元素值到最大元素值，若待排序集合中元素不是依次递增的，则必然有空间浪费情况。桶排序则是弱化了这种浪费情况，将最小值到最大值之间的每一个位置申请空间，更新为最小值到最大值之间每一个固定区域申请空间，尽量减少了元素值大小不连续情况下的空间浪费情况。</p><h4 id="实现步骤"><a href="#实现步骤" class="headerlink" title="实现步骤"></a>实现步骤</h4><ol><li>根据待排序集合中最大元素和最小元素的差值范围和映射规则，确定申请的桶个数；</li><li>遍历待排序集合，将每一个元素移动到对应的桶中；</li><li>对每一个桶中元素进行排序，并移动到已排序集合中；</li></ol><h4 id="算法图解-3"><a href="#算法图解-3" class="headerlink" title="算法图解"></a>算法图解</h4><p>将元素分配到桶中</p><img src="/2021/07/21/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/4.png" alt="4" style="zoom:150%;"><p>对桶中的元素进行排序</p><img src="/2021/07/21/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/5.png" alt="5" style="zoom: 25%;"><h4 id="代码实现-7"><a href="#代码实现-7" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">bucketSort</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//确定最大值,最小值</span></span><br><span class="line">    <span class="keyword">int</span> max = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> min = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">        max = Math.max(max, arr[i]);</span><br><span class="line">        min = Math.min(min, arr[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//计算桶的数量</span></span><br><span class="line">    <span class="keyword">int</span> bucketNum = (max - min) / arr.length + <span class="number">1</span>;</span><br><span class="line">    ArrayList&lt;ArrayList&lt;Integer&gt;&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="comment">//创建相应的桶</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; bucketNum; i++) &#123;</span><br><span class="line">        list.add(<span class="keyword">new</span> ArrayList&lt;&gt;());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//将各个元素放入到对应的桶中</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> element : arr) &#123;</span><br><span class="line">        <span class="keyword">int</span> bucketIndex = (element - min) / arr.length;</span><br><span class="line">        list.get(bucketIndex).add(element);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//对各个单独的桶进行排序 -&gt; 此处的内部排序算法可以自行选择</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; list.size(); i++) &#123;</span><br><span class="line">        Collections.sort(list.get(i));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//将已排序好的元素拷贝到原数组中</span></span><br><span class="line">    <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; list.size(); i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; list.get(i).size(); j++) &#123;</span><br><span class="line">            arr[index++] = list.get(i).get(j);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="基数排序"><a href="#基数排序" class="headerlink" title="基数排序"></a>基数排序</h2><h4 id="基本思想-8"><a href="#基本思想-8" class="headerlink" title="基本思想"></a>基本思想</h4><p>将所有待比较数值统一为同样的数位长度，数位较短的数前面补零</p><p>然后，从最低位开始，依次进行一次排序。 这样从最低位排序一直到最高位排序完成以后, 数列就变成一个有序序列</p><p><strong>主要步骤</strong></p><ul><li>找出数组中最大的数字的位数 <code>maxLength</code></li><li>获取数组中每个数字的基数</li><li>遍历 <code>maxLength</code> 轮数组，每轮按照基数对其进行排序</li></ul><h4 id="负数的处理"><a href="#负数的处理" class="headerlink" title="负数的处理"></a>负数的处理</h4><p>在对基数进行计数排序时，申请长度为 19 的二维数组数组–&gt; 申请19个桶，用来存储 [-9, 9] 这个区间内的所有整数。</p><p>在把每一位基数计算出来后，加上 9，就能对应上<code>bucketElementCounts</code> 数组的下标了，<code>bucketElementCounts</code> 数组的下标 [0, 18] 对应基数 [-9, 9]；</p><h4 id="代码实现-8"><a href="#代码实现-8" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">radixSort</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> max = arr[<span class="number">0</span>]; <span class="comment">//初始化数组的最大值</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[i] &gt; max) &#123;</span><br><span class="line">                max = arr[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//记录数组中最大值的位数</span></span><br><span class="line">        <span class="keyword">int</span> maxLength = (max + <span class="string">""</span>).length();</span><br><span class="line">        <span class="comment">//定义一个二维数组表示十个桶-&gt; 每个桶就是一个一维数组</span></span><br><span class="line">        <span class="comment">//防止数据溢出-&gt;每个桶的大小设置为 arr.length</span></span><br><span class="line">        <span class="keyword">int</span>[][] bucket = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>][arr.length];</span><br><span class="line">        <span class="comment">//为了记录每个桶中，实际存放了多少个数据,我们定义一个一维数组来记录各个桶的每次放入的数据个数</span></span><br><span class="line">        <span class="comment">//比如：bucketElementCounts[0] , 记录的就是  bucket[0] 桶的放入数据个数</span></span><br><span class="line">        <span class="keyword">int</span>[] bucketElementCounts = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>];</span><br><span class="line">        <span class="comment">//一共进行maxLength次循环-&gt;每次循环按照元素对应的数位,放入不同的桶中,在依次取出排序</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, n = <span class="number">1</span>; i &lt; maxLength; i++, n *= <span class="number">10</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; arr.length; j++) &#123;</span><br><span class="line">                <span class="comment">//取出每个元素对应位的值 -&gt; 123 ==&gt; 3, 2, 1 </span></span><br><span class="line">                <span class="keyword">int</span> digitOfElement = arr[j] / n % <span class="number">10</span>; </span><br><span class="line">                <span class="comment">//将元素按照个位、十位、百位...依次放入对应的桶中</span></span><br><span class="line">                bucket[digitOfElement][bucketElementCounts[digitOfElement]] = arr[j];</span><br><span class="line">                bucketElementCounts[digitOfElement]++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">            <span class="comment">//遍历十个桶,依次将将桶中的元素放入到原数组</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; <span class="number">10</span>; k++) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> l = <span class="number">0</span>; l &lt; bucketElementCounts[k]; l++) &#123;</span><br><span class="line">                    arr[index++] = bucket[k][l];</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//每轮处理后清空当前桶</span></span><br><span class="line">                bucketElementCounts[k] = <span class="number">0</span>; </span><br><span class="line">            &#125;</span><br><span class="line"><span class="comment">//            System.out.println("第" + (i + 1) + "轮的排序处理 arr =" + Arrays.toString(arr));</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;排序算法概述&quot;&gt;&lt;a href=&quot;#排序算法概述&quot; class=&quot;headerlink&quot; title=&quot;排序算法概述&quot;&gt;&lt;/a&gt;排序算法概述&lt;/h2&gt;&lt;p&gt;排序算法主要分为内部排序和外部排序两大类别&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;内部排序 ：将数据加载进内存进行排序&lt;/li&gt;
&lt;li&gt;外部排序 ：使用内存和外存相结合的方式对数据进行排序&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    
    <category term="算法" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>Java集合</title>
    <link href="http://yoursite.com/2021/07/15/Java%E9%9B%86%E5%90%88/"/>
    <id>http://yoursite.com/2021/07/15/Java%E9%9B%86%E5%90%88/</id>
    <published>2021-07-15T05:39:25.000Z</published>
    <updated>2021-07-26T13:05:20.931Z</updated>
    
    <content type="html"><![CDATA[<p>java集合也叫做容器，主要由<code>Collection</code> 和 <code>Map</code> 两大接口派生出来</p><ul><li>Collection : 单列集合，存放单一元素；</li><li>Map : 双列集合，存放 key - value键值对；</li></ul><p>其中 <code>Collection</code>接口继承自 <code>Iterable</code> 接口，并且主要派生出 <code>List</code> <code>Queue</code> <code>Set</code> 三个子接口，具体实现类如下图所示 :</p><a id="more"></a> <img src="/2021/07/15/Java%E9%9B%86%E5%90%88/0.png" alt="0" style="zoom: 80%;"><h2 id="List"><a href="#List" class="headerlink" title="List"></a>List</h2><p>List的特点主要就是 <strong>有序的</strong> 、<strong>可重复</strong></p><p>主要实现类有 ArrayList、 LinkedList、Vector;</p><table><thead><tr><th>实现类</th><th>底层实现</th><th>特点</th></tr></thead><tbody><tr><td>ArrayList</td><td><code>Object[]</code>数组</td><td>查找快、增删慢</td></tr><tr><td>Vector</td><td><code>Object[]</code>数组</td><td>底层方法由<code>synchronized</code>修饰，支持线程同步</td></tr><tr><td>LinkedList</td><td>双向链表(JDK1.6 之前为循环链表，JDK1.7 取消了循环)</td><td>查找慢、增删快，同时实现了<code>Deque</code> 接口可以当做栈及队列来使用</td></tr></tbody></table><h3 id="ArrayList"><a href="#ArrayList" class="headerlink" title="ArrayList"></a>ArrayList</h3><p>ArrayList 的底层是<code>Object[]</code>数组，与java基本的数组不同的是，ArrayList有<strong>扩容机制</strong>，在添加大量元素前，ArrayList扩容机制会先判断当前数组大小是否够用，如果不够用就进行扩容，这样就减少了数组因频繁创建拷贝而造成的资源浪费。</p><p><code>ArrayList</code>继承于 <strong><code>AbstractList</code></strong> ，实现了 <strong><code>List</code></strong>, <strong><code>RandomAccess</code></strong>, <strong><code>Cloneable</code></strong>, <strong><code>java.io.Serializable</code></strong> 这些接口。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayList</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractList</span>&lt;<span class="title">E</span>&gt; </span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">List</span>&lt;<span class="title">E</span>&gt;, <span class="title">RandomAccess</span>, <span class="title">Cloneable</span>, <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">8683452581122892189L</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_CAPACITY = <span class="number">10</span>; <span class="comment">//默认初始容量大小</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object[] EMPTY_ELEMENTDATA = <span class="keyword">new</span> Object[<span class="number">0</span>]; <span class="comment">//空数组 -&gt; 用于空参构造器</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = <span class="keyword">new</span> Object[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">transient</span> Object[] elementData; <span class="comment">//实际存储数据的数组</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> size; <span class="comment">//全局变量 -&gt; 数组的大小</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX_ARRAY_SIZE = <span class="number">2147483639</span>; <span class="comment">//定义数组最大容量 -&gt; 对数组扩容做限制</span></span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>RandomAccess</code> 是一个标志接口，表明实现这个这个接口的 List 集合是支持<strong>快速随机访问</strong>的。数组天然支持随机访问，时间复杂度为O(1)，所以称为快速随机访问，<code>RandomAccess</code>仅仅起到标识作用，并不是说实现了它才具有的快速随机访问功能。</li><li><code>ArrayList</code> 实现了 <code>Cloneable</code> 接口 ，即覆盖了函数<code>clone()</code>，能被克隆。</li><li><code>ArrayList</code> 实现了 <code>java.io.Serializable</code>接口，这意味着<code>ArrayList</code>支持序列化，能通过序列化去传输。</li></ul><h3 id="LinkedList"><a href="#LinkedList" class="headerlink" title="LinkedList"></a>LinkedList</h3><p>LinkedList是一个实现了List接口和Deque接口的双向链表。 LinkedList底层的链表结构使它支持高效的插入和删除操作。实现了Deque接口，使得LinkedList类也具有队列的特性;，同时LinkedList不是线程安全的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LinkedList</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractSequentialList</span>&lt;<span class="title">E</span>&gt; </span></span><br><span class="line"><span class="class"><span class="keyword">implements</span> <span class="title">List</span>&lt;<span class="title">E</span>&gt;, <span class="title">Deque</span>&lt;<span class="title">E</span>&gt;, <span class="title">Cloneable</span>, <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">transient</span> <span class="keyword">int</span> size; <span class="comment">//节点的数量</span></span><br><span class="line">    <span class="keyword">transient</span> LinkedList.Node&lt;E&gt; first; <span class="comment">//全局变量--&gt; 指向双向链表的头节点</span></span><br><span class="line">    <span class="keyword">transient</span> LinkedList.Node&lt;E&gt; last; <span class="comment">//全局变量--&gt; 指向双向链表的尾节点</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">876323262645176354L</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Node 内部私有类–&gt; 链表的节点   主要维护 三个变量</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">    E item; <span class="comment">//节点值</span></span><br><span class="line">    LinkedList.Node&lt;E&gt; next; <span class="comment">//后继指针 -&gt; 指向后继节点</span></span><br><span class="line">    LinkedList.Node&lt;E&gt; prev; <span class="comment">//前驱指针 -&gt; 指向前驱节点</span></span><br><span class="line"><span class="comment">//构造方法</span></span><br><span class="line">    Node(LinkedList.Node&lt;E&gt; prev, E element, LinkedList.Node&lt;E&gt; next) &#123;</span><br><span class="line">        <span class="keyword">this</span>.item = element;</span><br><span class="line">        <span class="keyword">this</span>.next = next;</span><br><span class="line">        <span class="keyword">this</span>.prev = prev;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h2><p>Set的特点主要就是 <strong>无序的</strong> 、<strong>不可重复</strong></p><table><thead><tr><th>实现类</th><th>底层实现</th><th>特点</th></tr></thead><tbody><tr><td><code>HashSet</code></td><td>基于 <code>HashMap</code> 实现的，底层采用 <code>HashMap</code> 来保存元素</td><td>无序，唯一</td></tr><tr><td><code>LinkedHashSet</code></td><td>继承于 <code>HashSet</code>、又是基于 <code>LinkedHashMap</code> 来实现的</td><td>有序，唯一</td></tr><tr><td><code>TreeSet</code></td><td>红黑树(自平衡的排序二叉树)</td><td>支持自然排序和定制排序</td></tr></tbody></table><h2 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h2><p><img src="/2021/07/15/Java%E9%9B%86%E5%90%88/1.png" alt="1"></p><table><thead><tr><th>实现类</th><th>底层实现</th><th>特点</th></tr></thead><tbody><tr><td><code>HashMap</code></td><td>JDK1.8 之前 数组+链表; JDK1.8之后 数组 + 链表 + 红黑树</td><td>允许有且仅有一个null键；可以有多个null值；</td></tr><tr><td><code>LinkedHashMap</code></td><td><code>LinkedHashMap</code> 继承自 <code>HashMap</code>，并在其基础上增加了一条双向链表</td><td>有序</td></tr><tr><td><code>HashTable</code></td><td>数组+链表 (链表解决哈希冲突)</td><td>不允许有null键和null值；线程安全，全表锁</td></tr><tr><td><code>ConcurrentHashMap</code></td><td>JDK1.7  Segment 数组 + HashEntry 数组 + 链表； JDK1.8 同<code>HashMap</code> 数组+链表/红黑二叉树</td><td>线程安全，分段锁</td></tr><tr><td><code>TreeMap</code></td><td>红黑树</td><td>有序，支持自然排序和定制排序</td></tr></tbody></table>]]></content>
    
    
    <summary type="html">&lt;p&gt;java集合也叫做容器，主要由&lt;code&gt;Collection&lt;/code&gt; 和 &lt;code&gt;Map&lt;/code&gt; 两大接口派生出来&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Collection : 单列集合，存放单一元素；&lt;/li&gt;
&lt;li&gt;Map : 双列集合，存放 key - value键值对；&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;其中 &lt;code&gt;Collection&lt;/code&gt;接口继承自 &lt;code&gt;Iterable&lt;/code&gt; 接口，并且主要派生出 &lt;code&gt;List&lt;/code&gt; &lt;code&gt;Queue&lt;/code&gt; &lt;code&gt;Set&lt;/code&gt; 三个子接口，具体实现类如下图所示 :&lt;/p&gt;</summary>
    
    
    
    
    <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>死锁</title>
    <link href="http://yoursite.com/2021/07/10/%E6%AD%BB%E9%94%81/"/>
    <id>http://yoursite.com/2021/07/10/%E6%AD%BB%E9%94%81/</id>
    <published>2021-07-10T01:48:32.000Z</published>
    <updated>2021-08-15T08:00:31.598Z</updated>
    
    <content type="html"><![CDATA[<h2 id="死锁的引入"><a href="#死锁的引入" class="headerlink" title="死锁的引入"></a>死锁的引入</h2><p>死锁处理是多进程图像产生的问题 -&gt; 多个进程在内存中同时出发交替执行的时候，如果控制不好就会出现互相死锁的情况。这种死锁就需要操作系统作出一定的处理，否则就会引发一些问题！</p><a id="more"></a><p><strong>再看一下生产者-消费者的信号量解法…</strong></p><p>生产者和消费者因为信号量的问题就会造成死锁，下面我们分析一下死锁产生的原因</p><p>如下图所示，生产者上来以后本应该是先申请 empty -&gt; 空闲缓冲区信号量，再申请 mutex -&gt; 互斥信号量。现在我们让生产者申请信号量的顺序反过来-&gt; 即先申请 mutex 再申请 empty，消费者也跟着改变；(为什么会反过来 -&gt; 生产者 和 消费者 的代码是用户写的，用户很完全可能给反过来，用户以为这样没什么，反正我就想申请两个信号量，两个都满足了我就进去了呗，但是这样会有本质的区别) 这样就造成了一些问题…</p><img src="/2021/07/10/%E6%AD%BB%E9%94%81/image-20210815101817001.png" alt="image-20210815101817001" style="zoom:67%;"><p>首先生产者进来，先申请mutex 将 mutex 从1变为0，表示已经有进程进入不再允许其他进程互斥进入，然后申请 empty, 假设此时的空闲缓冲区为 0-&gt; 资源已经满了，不需要生产，那么此时将 empty 从 0 变为 -1，生产者阻塞，此时CPU调度到 消费者执行，消费者一上来申请 mutex 发现 mutex 为 0-&gt; 已经有进程进入，那么就将 mutex 从 0 变为 -1并开始阻塞。此时生产者、消费者都开始阻塞，生产者想要生产 就依赖于消费者的 v(empty) ，而消费能执行到 v(empty) 的前提是它能下来执行 ，此时它还在上面等着呢，同时决定它能不能下来的条件是 生产者的 v(mutex) -&gt; 释放mutex ，而生产者能执行到 v(mutex) 的前提是它能够下来执行，可它刚上来就阻塞在上面了…. 所以信号量这样写完之后就引起了进程间互相等待的<strong>环路等待状态</strong>。</p><p>我们将这种<strong>多个进程由于互相等待对方持有的资源而造成的谁都无法执行的情况叫死锁</strong></p><h2 id="死锁造成的结果"><a href="#死锁造成的结果" class="headerlink" title="死锁造成的结果"></a>死锁造成的结果</h2><p>一旦出现了死锁，当有新的的进程申请”闭环资源”时同样要被阻塞，而它所持有的资源同样会陷入到这种死锁的局面中，这样就造成了资源锁的越来越多，进程锁的越来越多。我们知道操作系统的核心是多进程图像，只有进程执行了，计算机才能向前工作，那很进程都不执行了，计算机就不工作了呗，用户的最直观感受就是计算机特别慢。本质并不是CPU变慢了，而是CPU没干正经活，进程都在哪阻塞呢，CPU是没有程序可执行。</p><h2 id="死锁的成因"><a href="#死锁的成因" class="headerlink" title="死锁的成因"></a>死锁的成因</h2><p>要想处理死锁，我们应该先分析下死锁的成因</p><img src="/2021/07/10/%E6%AD%BB%E9%94%81/image-20210815140420262.png" alt="image-20210815140420262" style="zoom:67%;"><h4 id="死锁的4个必要条件"><a href="#死锁的4个必要条件" class="headerlink" title="死锁的4个必要条件"></a>死锁的4个必要条件</h4><ol><li><strong>互斥使用 (Mutual exclusion)</strong> : 资源的固有特性，一次只能被一个进程使用，如：道路、打印机</li><li><strong>不可抢占 (No preemption)</strong> : 资源只能自愿放弃</li><li><strong>请求和保持 (Hold and wait)</strong> : 进程必须占有资源，再去申请</li><li><strong>循环等待 (Circular wait)</strong> : 在资源分配图中存在一个环路，即出现环路等待</li></ol><h2 id="死锁的处理"><a href="#死锁的处理" class="headerlink" title="死锁的处理"></a>死锁的处理</h2><ol><li><strong>死锁预防</strong>：破坏死锁出现的条件  –&gt;  “no smoking” ,预防火灾</li><li><strong>死锁避免</strong> ：检测每个资源请求，如果造成死锁就拒绝  –&gt; 检测到煤气超标时，自动切断电源 </li><li><strong>死锁检测 + 恢复</strong> ：检测到死锁出现，让一些进程回滚，让出资源 –&gt; 发现火灾时，立刻拿起灭火器</li><li><strong>死锁忽略</strong> ：什么都不就好像没有出现死锁一样  -&gt; 重启，重新来过</li></ol><h4 id="死锁预防"><a href="#死锁预防" class="headerlink" title="死锁预防"></a>死锁预防</h4><p><strong>方法一：</strong>在进程执行前，一次性申请所有需要的资源，不会占有资源再去申请其他资源</p><ul><li>缺点1：需要预知未来，编程困难</li><li>缺点2：许多资源分配后很长时间后才使用，资源利用率低</li></ul><p><strong>方法二：</strong>对资源类型进行排序，资源申请必须按序进行，不会出现环路等待</p><ul><li>缺点1：仍然造成资源的浪费</li></ul><h4 id="死锁避免"><a href="#死锁避免" class="headerlink" title="死锁避免"></a>死锁避免</h4><p>如果系统中的所有进程存在一个可以完成的执行序列 P1,P2,…..Pn,则称系统处于<strong>安全状态</strong></p><p>那么安全序列如何找呢？ </p><img src="/2021/07/10/%E6%AD%BB%E9%94%81/image-20210815144949751.png" alt="image-20210815144949751" style="zoom: 50%;"><p>如上图所示，表示当前系统中进程与资源的关系，拿进程P0为例，此时进程持有(Allocation)A B C 三种资源 分别为 0 1 0 个，进程P0 想要执行还需要 (Need) 资源 A B C 各 7 4 3 个，而此时系统中还剩余(Available)  A B C 三种资源各 2 3 0 个。现在我们分析一下是否有一条执行序列能够让 这些进程都执行完。</p><p>首先系统剩余资源 2 3 0 ，可以将资源分配给 进程 P1,P3 我们假设先分配给进程 P1, 那么此时P1获得资源开始执行，P1执行完毕后释放所持有的资源 ，那么此时系统中的剩余资源变为 5 3 2 (2+3, 3+0, 0+2) ，接着将资源分配给 P3 ，P3执行完毕释放资源，此时系统中剩余 7 4 3 ,这样往复判断分配执行，再释放收回，最后所有进程都会有序执行完毕，并且安全序列有&lt; P1,P3,P2,P4,P0 &gt;等</p><p><strong>银行家算法</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> Available[<span class="number">1.</span>..m] ;<span class="comment">//每种资源剩余数量</span></span><br><span class="line"><span class="keyword">int</span> Allocation [ <span class="number">1.</span>..n, <span class="number">1.</span>..m] ;<span class="comment">//己分配资源数量</span></span><br><span class="line"><span class="keyword">int</span> Need [ <span class="number">1.</span>.n, <span class="number">1.</span>.ml;<span class="comment">//进程还需的各种资源数量</span></span><br><span class="line"><span class="keyword">int</span> Work [ <span class="number">1.</span>.m] ;<span class="comment">//工作向量</span></span><br><span class="line"><span class="keyword">bool</span> Finish  [ <span class="number">1.</span>.n] ;<span class="comment">//进程是否结束</span></span><br><span class="line"></span><br><span class="line">Work=Available;Finish[<span class="number">1.</span>.n]=<span class="literal">false</span>;</span><br><span class="line"><span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">    <span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;=n; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(Finish[i]==<span class="literal">false</span> &amp;&amp; Need [i] &lt;= Work[i] )</span><br><span class="line">&#123;</span><br><span class="line">Work=Work+Allocation[i];</span><br><span class="line">Finish[i]=<span class="literal">true</span>;  <span class="keyword">break</span>; </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">goto</span> <span class="built_in">end</span>;</span><br><span class="line">&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">End:</span><br><span class="line"><span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;=n; i++)</span><br><span class="line">  <span class="keyword">if</span>(Finish[i]==<span class="literal">false</span>)<span class="keyword">return</span> <span class="string">"deadlock"</span>;</span><br></pre></td></tr></table></figure><p>银行家算法是由Dijkstra 提出, 主要是寻找上面所提出的安全序列。T(n) = O(mn2) -&gt; m 表示资源数量，n表示进程个数。</p><p><strong>死锁避免之银行家算法实例：</strong></p><p>银行家算法只是判断系统是否可以有安全序列，那么它是如何避免死锁的呢？</p><img src="/2021/07/10/%E6%AD%BB%E9%94%81/image-20210815152203197.png" alt="image-20210815152203197" style="zoom:50%;"><p><strong>请求出现时，首先假装分配，然后调用银行家算法</strong></p><p>如上图所示：假设进程 P0 申请资源 (0,2,0)，那我们就假装给其分配一下，那么此时系统中的进程与资源的关系就要更新，然后根据分配后的进程资源关系调用银行家算法，判断看看是否有一条安全序列。如果此时没有安全序列-&gt; 表示如果给 P0分配资源，那么系统就会产生死锁，一个也别想执行了，所以就不该给 P0 分配资源，拒绝其申请。</p><p><strong>方法固然很好，但是每次申请资源都要进行调用判断，时间复杂度太高，系统开销太大；</strong></p><h4 id="死锁检测-恢复"><a href="#死锁检测-恢复" class="headerlink" title="死锁检测 + 恢复"></a>死锁检测 + 恢复</h4><p>既然银行家算法时间复杂度太高，每次申请资源都要调用，系统开销太大，那我们能不能不每次申请时都调用啊！反正死锁出现的概率很低，那就当每次出现问题，感觉系统慢了，再进行检测呗！</p><h5 id="定时检测或者发现资源利用率低时检测"><a href="#定时检测或者发现资源利用率低时检测" class="headerlink" title="定时检测或者发现资源利用率低时检测"></a>定时检测或者发现资源利用率低时检测</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Finish[<span class="number">1.</span>..n] = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">if</span> (Allocation[i] == <span class="number">0</span>) Finish[i] = <span class="literal">true</span>;</span><br><span class="line"><span class="comment">//和Banker 算法完全一致</span></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= n; i++) </span><br><span class="line"><span class="keyword">if</span> (Finish[i] == <span class="literal">false</span>)</span><br><span class="line"> deadlock = deadlock + &#123;i&#125;;</span><br></pre></td></tr></table></figure><h5 id="恢复"><a href="#恢复" class="headerlink" title="恢复"></a>恢复</h5><p><strong>通过抢占进行恢复</strong><br>在某些情况下，可能会临时将某个资源从它的持有者转移到另一个进程。比如在不通知原进程的情况下，将某个资源从进程中强制取走给其他进程使用，使用完后又送回。这种恢复方式一般比较困难而且有些简单粗暴，并不可取。</p><p><strong>通过回滚进行恢复</strong><br>如果系统设计者和机器操作员知道有可能发生死锁，那么就可以定期检查流程。进程的检测点意味着进程的状态可以被写入到文件以便后面进行恢复。检测点不仅包含存储映像(memory image)，还包含资源状态(resource state)。一种更有效的解决方式是不要覆盖原有的检测点，而是每出现一个检测点都要把它写入到文件中，这样当进程执行时，就会有一系列的检查点文件被累积起来。为了进行恢复，要从上一个较早的检查点上开始，这样所需要资源的进程会回滚到上一个时间点，在这个时间点上，死锁进程还没有获取所需要的资源，可以在此时对其进行资源分配。</p><p><strong>杀死进程恢复</strong><br>最简单有效的解决方案是直接杀死一个死锁进程。但是杀死一个进程可能照样行不通，这时候就需要杀死别的资源进行恢复。另外一种方式是选择一个环外的进程作为牺牲品来释放进程资源。</p><h4 id="死锁忽略"><a href="#死锁忽略" class="headerlink" title="死锁忽略"></a>死锁忽略</h4><p>许多通用操作系统，如PC 机上安装的 Windows 和 Linux,都采用死锁忽略的方法。</p><ul><li>死锁忽略的处理代价最小</li><li>这种机器上出现死锁的概率比其他机器低</li><li>死锁可以用重启来解决，PC重启造成的影响小</li><li>死锁预防让编程变得困难</li></ul><p><strong>参考资料</strong></p><ul><li><a href="https://www.bilibili.com/video/BV1d4411v7u7?p=19" target="_blank" rel="noopener">哈工大李治军-操作系统</a></li><li><a href="https://leetcode-cn.com/leetbook/read/awesome-os-guide/ez52iv/" target="_blank" rel="noopener">LeetCode - 死锁</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;死锁的引入&quot;&gt;&lt;a href=&quot;#死锁的引入&quot; class=&quot;headerlink&quot; title=&quot;死锁的引入&quot;&gt;&lt;/a&gt;死锁的引入&lt;/h2&gt;&lt;p&gt;死锁处理是多进程图像产生的问题 -&amp;gt; 多个进程在内存中同时出发交替执行的时候，如果控制不好就会出现互相死锁的情况。这种死锁就需要操作系统作出一定的处理，否则就会引发一些问题！&lt;/p&gt;</summary>
    
    
    
    
    <category term="操作系统" scheme="http://yoursite.com/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>进程同步与信号量</title>
    <link href="http://yoursite.com/2021/07/07/%E8%BF%9B%E7%A8%8B%E5%90%8C%E6%AD%A5%E4%B8%8E%E4%BF%A1%E5%8F%B7%E9%87%8F/"/>
    <id>http://yoursite.com/2021/07/07/%E8%BF%9B%E7%A8%8B%E5%90%8C%E6%AD%A5%E4%B8%8E%E4%BF%A1%E5%8F%B7%E9%87%8F/</id>
    <published>2021-07-07T02:36:22.000Z</published>
    <updated>2021-08-15T03:25:37.841Z</updated>
    
    <content type="html"><![CDATA[<h2 id="进程同步"><a href="#进程同步" class="headerlink" title="进程同步"></a>进程同步</h2><p>多进程图像除了交替执行向前推进之外，还存在进程之间的合作，进程同步就是让这种进程之间的合作变得合理有序。</p><a id="more"></a> <h2 id="生产者-消费者实例"><a href="#生产者-消费者实例" class="headerlink" title="生产者-消费者实例"></a>生产者-消费者实例</h2><p><strong>共享数据</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BUFFER_SIZE 10</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span>...&#125; item;</span><br><span class="line">item <span class="built_in">buffer</span>[BUFFER_SIZE];</span><br><span class="line"><span class="keyword">int</span> in = out = counter = <span class="number">0</span>;</span><br></pre></td></tr></table></figure><p>buffer是一块公共缓冲区，BUFFER_SIZE是这块缓冲区的大小</p><p><strong>生产者进程</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">while</span>(counter==BUFFER_SIZE)</span><br><span class="line">        ；</span><br><span class="line">  <span class="comment">//缓冲区满，生产者要停；</span></span><br><span class="line"><span class="built_in">buffer</span>[in]=item;</span><br><span class="line">in = (in+<span class="number">1</span>)%BUFFER_SIZE;</span><br><span class="line">counter++; <span class="comment">// 发信号让消费者走</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>消费者进程</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">while</span>(counter==<span class="number">0</span>)</span><br><span class="line">        ；</span><br><span class="line"><span class="comment">//缓冲区空，消费者要停；</span></span><br><span class="line">item=<span class="built_in">buffer</span>[out];</span><br><span class="line">out=(out+<span class="number">1</span>) % BUFFER_SIZE;</span><br><span class="line">counter--; <span class="comment">// 发信号让生产者走</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>需要让”进程走走停停” 来保证多进程合作的合理有序–&gt; 关键在于找到那些地方要停，什么时候走？</p><p>两个进程之间的合作都需要一个等待的过程，在条件未满足的情况下，另外一个进程不能执行； 需要等待另外一个进程给该进程发<strong>信号</strong>才能继续执行。</p><h2 id="从信号到信号量"><a href="#从信号到信号量" class="headerlink" title="从信号到信号量"></a>从信号到信号量</h2><p>单单发信号并不能解决全部问题，信号所的表达的信息太少了-&gt; 走 和 停 嘛！</p><p>我们需要引出信号量来表达更多的信息。</p><p><strong>生产者进程</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(counter==BUFFER_ SIZE)</span><br><span class="line">        sleep():<span class="comment">// 当缓冲区满了之后如果再来一个生产者进程，进入sleep</span></span><br><span class="line">    counter ++;</span><br><span class="line">    <span class="keyword">if</span>(counter==<span class="number">1</span>) <span class="comment">// 当counter==1，说明之前缓冲区里面是没有资源的，唤醒消费者进程</span></span><br><span class="line">    wakeup(消费者);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>消费者进程</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(counter==<span class="number">0</span>)<span class="comment">// 如果缓冲区里面没有资源，再来一个消费者，进入sleep()</span></span><br><span class="line">sleep();</span><br><span class="line">counter --;</span><br><span class="line"><span class="keyword">if</span>(counter == BUFFER_ SIZE<span class="number">-1</span>)<span class="comment">// 说明之前缓冲区是满，则唤醒生产者进程</span></span><br><span class="line">wakeup(生产者);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>问题的引出</strong></p><ol><li>缓冲区满以后生产者P1生产一个item放入，会sleep</li><li>又一个生产者P2生产一个item放入，会sleep</li><li>消费者C执行1次循环，counter==BUFFER_ SIZE-1,发信号给P1, P1 wakeup</li><li>消费者C再执行1次循环，counter==BUFFER_ SIZE-1，不能wakeupP2，P2不能被唤醒</li></ol><p>通过上面的情况我们可以分析出，一旦发生这种情况，那么P2是永远都无法被唤醒的，单纯的依靠counter来进行语义的判断是远远不够的，因为counter 仅仅反映的是缓冲区中的空闲的个数。实际上不仅需要缓冲区中空闲的个数还要知道有多少个进程在这里睡眠。counter 一旦加到 BUFFER_ SIZE 之后就不往上累加了，也就导致counter 根本无法完全表示究竟睡眠一个进程还是两个进程–&gt; 即无法记录有几个生产者在这里睡眠。</p><p>所以单单通过一个信号是不足以解决全部问题啦，我们需要一个量来记录更多的信息，如到底有几个进程在阻塞，并通过这个量来判断是否要发信号</p><p><strong>模拟信号量，假设信号量为 sem</strong></p><ol><li>缓冲区满，P1执行， P1 sleep， 此时 sem=-1</li><li>P2执行，P2 sleep， 此时 sem=-2</li><li>C执行一次循环， wakeup(P1)，此时 sem=-1</li><li>C再次执行一次循环，wakeup(P2)，此时 sem=0</li><li>C再次执行一次循环， 此时 sem=1</li><li>P3执行， 此时 sem=0</li></ol><p>引入信号量sem，此时通过信号量的值来发信号。当缓冲区满时，如果再来一个生产者进程，则睡眠，同时sem-1.当缓冲区为空，如果再来一个消费者进程，则睡眠，同时sem+1</p><h2 id="信号量"><a href="#信号量" class="headerlink" title="信号量"></a>信号量</h2><p>信号量：1965年，由荷兰学者 Dijkstra 提出的一种特殊整型变量，用来控制进程的 sleep 和 wakeup</p><p>P：荷兰语 proberen 即 test</p><p>V：荷兰语 verhogen 即 increment</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">semaphore</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">int</span> value;<span class="comment">// 记录资源个数</span></span><br><span class="line">PCB *<span class="built_in">queue</span>;<span class="comment">// 记录等待在该信号量上的进程-&gt; 每个信号量对应一个队列</span></span><br><span class="line">&#125;</span><br><span class="line">P(semaphore s)</span><br><span class="line">&#123;</span><br><span class="line">s.value --;</span><br><span class="line"><span class="keyword">if</span> (s.value &lt; <span class="number">0</span>)<span class="comment">// 说明没资源了 又来一个消费者</span></span><br><span class="line">&#123;</span><br><span class="line">sleep(s.<span class="built_in">queue</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">V(semaphore s)</span><br><span class="line">&#123;</span><br><span class="line">s.value ++;</span><br><span class="line"><span class="keyword">if</span>(s.value &lt;= <span class="number">0</span>)<span class="comment">// +1之后&lt;=0就说明有进程在sleep</span></span><br><span class="line">&#123;</span><br><span class="line">wakeup(s.<span class="built_in">queue</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>用信号量解决生产者消费者问题</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">semaphore empty = BUFFER_SIZE<span class="comment">//空闲缓冲区个数</span></span><br><span class="line">semaphore full = <span class="number">0</span>;<span class="comment">//资源个数</span></span><br><span class="line"></span><br><span class="line">生产者：</span><br><span class="line">Producer(item)</span><br><span class="line">&#123;</span><br><span class="line">P(empty);<span class="comment">// 空闲缓冲区是不是为零</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//代码区</span></span><br><span class="line"></span><br><span class="line">V(full);<span class="comment">// 生产者执行一次之后，肯定要增加一次资源个数</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">消费者：</span><br><span class="line">Consumer()</span><br><span class="line">&#123;</span><br><span class="line">P(full);<span class="comment">// 资源是不是为零</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 代码区</span></span><br><span class="line"></span><br><span class="line">V(empty);<span class="comment">// 消费者执行一次之后，肯定要增加一次空闲缓冲区个数</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>定义空闲缓冲区 empty 初始化为 BUFFER_SIZE 生产者一上来就p(empty) 测一下空闲缓冲区的大小看看是否为0-&gt; 即满了，如果为0则阻塞，对应着消费者会增加该空闲缓冲区的大小即每次执行完要执行V(empty);</p><p>同样消费者在生产出内容为0的时候停止，所以我们还要定义一个量来表示生产出的内容有多少-&gt; full 初始化为 0。消费者每次上来测一下 full 是否为 0 ，如果为 0 则表示没有内容可供消费，所以就阻塞，当然由生产者增加这个内容，即生产者每次执行完生产要执行 V(full) 操作。</p><h2 id="信号量临界区保护"><a href="#信号量临界区保护" class="headerlink" title="信号量临界区保护"></a>信号量临界区保护</h2><p><strong>信号量为什么需要被保护？</strong></p><p>因为多进程的竞争导致和调度有关的共享数据可能发生语义错误</p><p>多进程同时操控信号量</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">P1</span><br><span class="line"></span><br><span class="line">P1.<span class="keyword">register</span> = empty;</span><br><span class="line">P1.<span class="keyword">register</span> = P1.<span class="keyword">register</span> - <span class="number">1</span>;</span><br><span class="line">empty = P1.<span class="keyword">register</span>;</span><br><span class="line"></span><br><span class="line">P2</span><br><span class="line"></span><br><span class="line">P2.<span class="keyword">register</span> = empty;</span><br><span class="line">P2.<span class="keyword">register</span> = P2.<span class="keyword">register</span> - <span class="number">1</span>;</span><br><span class="line">empty = P2.<span class="keyword">register</span>;</span><br></pre></td></tr></table></figure><p>empty这个信号量是存储在内存里面的，内存里面是不可以进行算数运算的，只能先将这个值放到寄存器里面运算完在赋值回来。如果同时有两个生产者进程P1和P2。</p><p>假设empty=-1，经过P1和P2之后empty应该为-3；一种可能的调度是这样：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">P1.<span class="keyword">register</span>=empty;<span class="comment">// P1.register = -1</span></span><br><span class="line">P1.<span class="keyword">register</span>=P1.<span class="keyword">register</span><span class="number">-1</span>;<span class="comment">// P1.register = -2</span></span><br><span class="line">P2.<span class="keyword">register</span>=empty;<span class="comment">// P2.register = -1</span></span><br><span class="line">P2.<span class="keyword">register</span>=P2.<span class="keyword">register</span><span class="number">-1</span>;<span class="comment">// P2.register = -2</span></span><br><span class="line">empty=P1.<span class="keyword">register</span>;<span class="comment">// empty = -2</span></span><br><span class="line">empty=P2.<span class="keyword">register</span>;<span class="comment">// empty = -2</span></span><br></pre></td></tr></table></figure><p>也就是运行完之后empty的值为-2，这样与预期结果不一样，这个结果是错误的，为什么会错误，因为执行顺序发生了改变，进程会随时切换，谁也不知道时间片什么时候会用完。其实这种错误很常见，因为多个进程操作一个共享变量执行一段时间出问题的可能很大；程序是没问题的，而是由于对共享数据的竞争产生的错误。这种错误是很难发现的。我们期望程序的执行顺序应该是这样：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">P1.<span class="keyword">register</span> = empty;</span><br><span class="line">P1.<span class="keyword">register</span> = P1.<span class="keyword">register</span> - <span class="number">1</span>;</span><br><span class="line">empty = P1.<span class="keyword">register</span>;<span class="comment">// -2</span></span><br><span class="line">P2.<span class="keyword">register</span> = empty;</span><br><span class="line">P2.<span class="keyword">register</span> = P2.<span class="keyword">register</span> - <span class="number">1</span>;</span><br><span class="line">empty = P2.<span class="keyword">register</span>;<span class="comment">// -3</span></span><br></pre></td></tr></table></figure><p>也就是当P1进程执行的时候就不允许切换出去执行其他进程，只能执行完P1之后才能执行P2(原子操作)。那如何保护呢？使用临界区</p><h2 id="临界区的实现"><a href="#临界区的实现" class="headerlink" title="临界区的实现"></a>临界区的实现</h2><p><strong>基本原则</strong></p><ul><li><strong>互斥进入:如果一个进程在临界区中执行，则其他进程不允许进入其对应的那一段临界区代码</strong></li><li>有空让进:若干进程要求进入空闲临界区时，应尽快使一进程进入临界区</li><li>有限等待:从进程发出进入请求到允许进入，不能无限等待</li></ul><img src="/2021/07/07/%E8%BF%9B%E7%A8%8B%E5%90%8C%E6%AD%A5%E4%B8%8E%E4%BF%A1%E5%8F%B7%E9%87%8F/10.png" alt="10" style="zoom: 67%;"><h4 id="轮换法"><a href="#轮换法" class="headerlink" title="轮换法"></a>轮换法</h4><p>轮换法就是借助生活中的例子，两个人轮流值日，如下图所示两个进程 P0,P1</p><p>当turn = 0 的时候，进程 P0 进入临界区，因为 turn = 0， turn ！= 1 所有 进程p1一直空转等待无法进入其对应的临界区，当进程P1执行完毕后，turn 置为 1，进程P2才执行，所以轮换法满足了互斥进入的基本条件。</p><p>但是轮换法并不满足有空让进的原则，设想一下，如果 P1 由于某种原因阻塞，无法执行，但是此时turn = 1，进程P0 想进入却无法进入，这样就造成了两个进程都无法执行的后果。</p><img src="/2021/07/07/%E8%BF%9B%E7%A8%8B%E5%90%8C%E6%AD%A5%E4%B8%8E%E4%BF%A1%E5%8F%B7%E9%87%8F/image-20210814082959260.png" alt="image-20210814082959260" style="zoom:67%;"><h4 id="标记法"><a href="#标记法" class="headerlink" title="标记法"></a>标记法</h4><p>我想进入临界区前我就先打一个标记，然后判断另外一个是否在临界区，如下图所示：P0 在进入临界区之前将 flag[0] = true, 然后判断 flag[1] ，如果flag[1] = true -&gt; 进程 p1正在访问临界区，则空转等待。若 flag[1] = false -&gt; 则临界区无进程访问 直接进入。</p><p>如果在进程 P0 标记的时候 即 flag[0] = true，此时进程P1 进来了也同时打了标记，进程P0,P1发现对方都打了标记，虽然临界区空闲，但是大家都无法进入，而且造成了无限等待，所以标记法也不行。</p><img src="/2021/07/07/%E8%BF%9B%E7%A8%8B%E5%90%8C%E6%AD%A5%E4%B8%8E%E4%BF%A1%E5%8F%B7%E9%87%8F/image-20210814084455927.png" alt="image-20210814084455927" style="zoom:67%;"><h4 id="Peterson-算法"><a href="#Peterson-算法" class="headerlink" title="Peterson 算法"></a>Peterson 算法</h4><p>Peterson 算法结合了标记和轮转两种思想</p><img src="/2021/07/07/%E8%BF%9B%E7%A8%8B%E5%90%8C%E6%AD%A5%E4%B8%8E%E4%BF%A1%E5%8F%B7%E9%87%8F/image-20210814090322347.png" alt="image-20210814090322347" style="zoom:67%;"><p>满足互斥进入：如果两个进程都进入，则flag[0] = flag[1] = true, turn == 0== 1，矛盾！</p><p>满足有空让进：如果进程 P1不在临界区，则flag[1] = false, 或者 turn = 0 都能使P0进入。</p><p>满足有限等待：P0 要求进入，flag[0] = true; 后面的P1不可能一直进入，因为 P1执行一次就会让 turn = 0</p><p><strong>以上都是考虑两个进程之间的调度，如果有n个进程呢？</strong></p><h4 id="面包店算法"><a href="#面包店算法" class="headerlink" title="面包店算法"></a>面包店算法</h4><p>面包店算法仍然是标记 + 轮转相结合的方式</p><p>如何轮转：每个进程都获得一个序号，序号最小的进入</p><p>如何标记：进程离开时序号为0，不为0的序号即标记</p><img src="/2021/07/07/%E8%BF%9B%E7%A8%8B%E5%90%8C%E6%AD%A5%E4%B8%8E%E4%BF%A1%E5%8F%B7%E9%87%8F/image-20210814093027944.png" alt="image-20210814093027944" style="zoom:67%;"><p>互斥进入：Pi 在临界区内，Pk 试图进入，一定有(num[i],i) &lt; (num[k],k), Pk 循环等待。</p><p>有空让进：如果没有进程在临界区中，最小序号的进程一定能够进入。</p><p>有限等待：离开临界区的进程再次进入一定排在最后(FIFO)，所以任一个想进入进程至多等待n 个进程。</p><p><strong>面包店算法有优点也有其缺点，优点前面已经说了，对于多进程的调度实现的比较好，而且是纯软件的不需要硬件支持；缺点就是太麻烦了，代码复杂。</strong></p><h4 id="通过开关中断来实现"><a href="#通过开关中断来实现" class="headerlink" title="通过开关中断来实现"></a>通过开关中断来实现</h4><p>临界区保护的另一类解法</p><p>临界区主要是为了保护信号量，为什么一次只允许一个进程进入临界区？是因为CPU调度导致多进程竞争共享资源。那么我们能不能阻止调度呢？？调度的先决条件是中断，那我们阻止中断也就阻止调度了。</p><img src="/2021/07/07/%E8%BF%9B%E7%A8%8B%E5%90%8C%E6%AD%A5%E4%B8%8E%E4%BF%A1%E5%8F%B7%E9%87%8F/image-20210814135759102.png" alt="image-20210814135759102" style="zoom:67%;"><p>cin()表示关中断，sti()开中断。当一个进程Pi进入临界区之前关闭中断，这样CPU就不会调度，其他的进程也就无法再访问该临界区啦，执行完毕再打开中断。</p><p>CPU中断的原理：CPU旁边有个INTR寄存器，如果有中断来，就将INTR的某一位置为1，CPU每执行完一条指令之后就看一下是不是有中断来，如果有就执行；cin()函数的作用就是让CPU不看INTR寄存器，这样不管有没有中断来，CPU都不管。</p><p>但是这种方式对于多核不好使，因为你只能控制一个CPU，其他的CPU控制不了，而现在的计算机基本上都是多核了。这种方式只适用于单核的小系统。</p><h4 id="硬件原子指令法"><a href="#硬件原子指令法" class="headerlink" title="硬件原子指令法"></a>硬件原子指令法</h4><p>我们说保护信号量就好像给其上锁，锁是现实时间中直观的东西，但是在计算机中锁就是变量，该信号量上锁就好比给 empty 变量 通过 mutex 变量来保护，每个进程进来的时候，通过判断mutex 变量的值来决定是否有资源，是否可以进入。但是关键的是 mutex 又无法进行保护，难道是用mutex 来保护 empty ，再找个变量来保护 mutex ，那保护mutex 的变量又用谁来保护？？</p><p>我们先前的所有分析方法都是通过软件的方式来保护信号量，那我们能不能通过硬件，让硬件帮我们做好这个 mutex 。通过硬件的原子指令保证修改mutex 只需要一条指令，那执行的中间就不会被打断了，那么不就完美了嘛！</p><img src="/2021/07/07/%E8%BF%9B%E7%A8%8B%E5%90%8C%E6%AD%A5%E4%B8%8E%E4%BF%A1%E5%8F%B7%E9%87%8F/image-20210814142943314.png" alt="image-20210814142943314" style="zoom:67%;"><p>关键就是上面代码中–&gt; <code>while (TestAndSet(&amp;lock))</code> 这条指令能够完整的执行，当有进程进来了就一次执行(瞬间执行完毕)判断是否”加了锁”，如果判断有进程在临界区就开始空转，直到其退出临界区。 </p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>多进程之间的通信需要信号量，同时需要用临界区来保护信号量，临界区可以用面包店、开关中断以及原子指令(根据合适的场景选择)。一旦用临界区保护住了信号量，信号量在执行过程中的语义就一定会正确，语义正确之后，根据这个语义就可以准确的实现进程间的同步。</p><p><strong>用临界区去保护信号量，用信号量实现同步！</strong></p><p><strong>参考资料</strong></p><ul><li><a href="https://www.bilibili.com/video/BV1d4411v7u7?p=16" target="_blank" rel="noopener">哈工大李治军-操作系统</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;进程同步&quot;&gt;&lt;a href=&quot;#进程同步&quot; class=&quot;headerlink&quot; title=&quot;进程同步&quot;&gt;&lt;/a&gt;进程同步&lt;/h2&gt;&lt;p&gt;多进程图像除了交替执行向前推进之外，还存在进程之间的合作，进程同步就是让这种进程之间的合作变得合理有序。&lt;/p&gt;</summary>
    
    
    
    
    <category term="操作系统" scheme="http://yoursite.com/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>CPU的调度策略</title>
    <link href="http://yoursite.com/2021/07/02/CPU%E7%9A%84%E8%B0%83%E5%BA%A6%E7%AD%96%E7%95%A5/"/>
    <id>http://yoursite.com/2021/07/02/CPU%E7%9A%84%E8%B0%83%E5%BA%A6%E7%AD%96%E7%95%A5/</id>
    <published>2021-07-02T02:13:22.000Z</published>
    <updated>2021-07-12T07:15:43.738Z</updated>
    
    <content type="html"><![CDATA[<h2 id="什么是CPU调度？"><a href="#什么是CPU调度？" class="headerlink" title="什么是CPU调度？"></a>什么是CPU调度？</h2><p>调度即为切换-&gt; 获取到 switch_to(cur, next) 中的 next，一旦获得到next 便切换到 next；</p><p>如下图所示：PID1的进程正在执行，当执行到一定程度后由于阻塞或者时间片到时等原因，不让它继续执行了。现在操作系统需要切换另外一个进程去执行，但是现在就绪队列中有两个进程分别为PID2、PID3。PID2是先前read() 引发磁盘读阻塞现在又处于就绪了，PID3是先前时间片到时而阻塞现在又就绪了，那么此是PID2、PID3都处于就绪状态，<strong>CPU接下来该切换到PID2好呢还是切换到PID3好呢？？</strong></p><a id="more"></a><img src="/2021/07/02/CPU%E7%9A%84%E8%B0%83%E5%BA%A6%E7%AD%96%E7%95%A5/1.png" alt="1" style="zoom:67%;"><h2 id="CPU调度的直观想法"><a href="#CPU调度的直观想法" class="headerlink" title="CPU调度的直观想法"></a>CPU调度的直观想法</h2><p><strong>FIFO</strong></p><p>先入先出，根据就绪队列的先后顺序执行。</p><p>类似于银行排队办理业务，结合生活我们可以发现如果一个人仅仅是简单的询问并不办理手续那他也要跟着后面排队嘛？？显然这种策略是不合理的！</p><p><strong>Priority</strong></p><p>优先级 –&gt; 给每个进程都设置优先级，根据优先级来选取下一个执行的进程。对于一些时间短的任务可以适当增加它的优先级 ，先让它执行。但是你怎么知道这个任务将来会执行多长时间呢？–&gt; 如果上面那个人询问的越来越长，那怎么办呢？同样难道就因为我的执行任务很长就把我一直排在后面，这也不合适吧 ！</p><h2 id="面对诸多场景如果设计调度算法呢？"><a href="#面对诸多场景如果设计调度算法呢？" class="headerlink" title="面对诸多场景如果设计调度算法呢？"></a>面对诸多场景如果设计调度算法呢？</h2><h3 id="如何让进程满意？-gt-时间复杂度"><a href="#如何让进程满意？-gt-时间复杂度" class="headerlink" title="如何让进程满意？-&gt; 时间复杂度"></a><strong>如何让进程满意</strong>？-&gt; <strong>时间复杂度</strong></h3><ul><li>尽快结束任务：周转时间短(从任务进入到任务结束) </li><li>用户操作尽快响应：响应时间短(从操作发生到响应)</li><li>系统内耗时间少：吞吐量大(完成的任务量)</li></ul><p>总原则：系统专注于任务执行，又能合理调配任务；</p><h3 id="如何做到合理呢？"><a href="#如何做到合理呢？" class="headerlink" title="如何做到合理呢？"></a><strong>如何做到合理呢？</strong></h3><p>操作系统做CPU调度的时关键在于<strong>折中</strong>和<strong>综合</strong></p><p>通常一个系统中往往既有前台任务又有后台任务，并且前台任务和后台任务的关注点不同 -&gt; <strong>前台任务关注响应时间，后台任务关注周转时间</strong>然而<strong>吞吐量和响应时间之间存在矛盾</strong></p><img src="/2021/07/02/CPU%E7%9A%84%E8%B0%83%E5%BA%A6%E7%AD%96%E7%95%A5/2.png" alt="2" style="zoom: 67%;"><p><strong>响应时间小 -&gt; 切换次数多 -&gt; 系统内耗大 -&gt; 吞吐量小</strong></p><p>即如果想保证用户的体验，前台的响应时间就要短，那就需要频繁的切换，因为CPU的切换是需要时间的，频繁的切换会造成大量的系统内耗。想一想如果CPU的工作都花在切换上了，正经活不干了，那吞吐量自然就小了，后台的周转时间自然会受到影响。</p><p><strong>IO约束型和CPU约束性任务有各自的特点</strong></p><ul><li>IO约束型即CPU执行区间短的切换的频率特别大，比如银行的出纳、word文档总是需要写入磁盘，等待键盘的输入，典型的IO约束型。</li><li>CPU约束型即很长一段时间没有IO,CPU的执行区间很长，一顿在完成计算，比如Matlab计算矩阵的时是典型的CPU约束型任务。</li></ul><p>因为它们都有各自的特点，那么在折中和综合后的优先级设置中，<strong>IO约束型任务的优先级往往要高一些</strong>。因为IO约束型任务优先级高的话就会先执行，它稍微执行一段之后IO就启动了，然后就紧接着切出去执行CPU约束型任务，现在IO和CPU就并行起来了，两种任务就都能很高效地执行。而如果是CPU约束型任务优先级很高的话，那它先执行，CPU就会一直执行很少给IO约束型任务调度的机会，那么IO约束型进程就会饥饿。通过分析我们发现<strong>IO约束型任务往往是前台任务，和用户的交互很多，CPU约束型任务往往是后台任务。</strong></p><p>所以折中和综合让操作系统的调度变得异常的复杂……</p><h2 id="常用的CPU调度算法"><a href="#常用的CPU调度算法" class="headerlink" title="常用的CPU调度算法"></a>常用的CPU调度算法</h2><h4 id="FCFS-gt-First-Come-First-Served"><a href="#FCFS-gt-First-Come-First-Served" class="headerlink" title="FCFS-&gt; First Come, First Served"></a><strong>FCFS-&gt; First Come, First Served</strong></h4><p>先来先服务</p><h4 id="SJF：短作业优先"><a href="#SJF：短作业优先" class="headerlink" title="SJF：短作业优先"></a><strong>SJF：短作业优先</strong></h4><p>如何将完成所需时间小的任务提前，那么它的周转时间就会缩短，平均周转时间也就减少。系统的平均满意度提高。但是这样所需时间长的任务总是被排在后面，导致响应时间又很长？？</p><h4 id="RR-按照时间片来轮转调度"><a href="#RR-按照时间片来轮转调度" class="headerlink" title="RR: 按照时间片来轮转调度"></a><strong>RR: 按照时间片来轮转调度</strong></h4><p>按照时间片可以很好的满足响应时间，但是时间片的设置需要好好考虑</p><p>时间片太大 -&gt; 响应时间太长； 时间片小 -&gt; 切换频繁内耗大，吞吐量小；</p><p>折衷：进程的个数要有所限制 ；时间片10 ~ 100ms，切换时间0.1~1ms（1%）</p><h4 id="一些问题的思考"><a href="#一些问题的思考" class="headerlink" title="一些问题的思考"></a>一些问题的思考</h4><p>SJF解决了周转时间，RR解决了响应时间，<strong>但是如果响应时间和周转时间同时存在呢？</strong>就比如word很关心响应时间，而gcc很关心周转时间，这两类任务同时存在怎么办呢？</p><p>直观想法：定义前台任务和后台任务两个队列，因为前台任务更看重响应时间，所以使用RR，后台任务更看重周转时间，采用SJF。它们之间使用优先级调度 -&gt; 只有当前台任务没有的时候才调度后台任务</p><img src="/2021/07/02/CPU%E7%9A%84%E8%B0%83%E5%BA%A6%E7%AD%96%E7%95%A5/3.png" alt="3" style="zoom:67%;"><p>那么问题就又出现了，如果前后台任务切换是绝对的优先级调度，如果前台任务总是不停的出现，那么前台任务就总是先执行，那很可能后台的任务永远也得不到执行，就会造成后台进程饥饿。这显然又不合理了，那该怎么解决呢？？</p><p>优先级动态的调整–&gt; 后台任务优先级动态的升高</p><p>但是后台任务优先级提升上来之后，因为后台任务往往是CPU约束型任务又采用的SJF策略，一旦执行就很难再停下来去执行前台任务，前台任务的响应时间就又没法得到保证了？？啊这……</p><p>为了保证前台任务，后台任务也不能让它一直执行，后台任务你可以上来，但你执行完一段时间优先级应该再下去，释放CPU执行权，所以后台任务也要有时间片。但是如果前后台任务都是单纯的只有时间片就又退化成了RR，也就又没有了优先级的概念？？？</p><p><strong>所以既要以轮转调度RR为核心，又要在轮转调度的基础增加一些优先级。</strong></p><p>除此之外还有很多其他的问题，比如：</p><ul><li>我们怎么知道哪些是前台任务，哪些是后台任务，fork时告诉我们吗?</li><li>gcc就一点不需要交互吗? Ctrl+C按键怎么工作?</li><li>word就不会执行一段批处理吗? Ctrl+F按键?</li><li>SJF中的短作业优先如何体现? 如何判断作业的长度?</li></ul><p>所以我们需要设计一个调度算法，这个调度算法要有一定的学习能力，它能识别不同的任务，并且可以根据任务的变化自身作出调整，同时这个算法还要尽可能的简单，既要考虑前台任务又要考虑后台任务。从而达到操纵系统对整体任务的折中以及综合。</p><h2 id="Linux-0-11-的调度函数schedule"><a href="#Linux-0-11-的调度函数schedule" class="headerlink" title="Linux 0.11 的调度函数schedule()"></a>Linux 0.11 的调度函数schedule()</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//在kernel/sched.c中</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Schedule</span><span class="params">(<span class="keyword">void</span>)</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>) </span><br><span class="line">&#123; </span><br><span class="line">c=<span class="number">-1</span>; next=<span class="number">0</span>; i=NR_TASKS;</span><br><span class="line">p=&amp;task[NR_TASKS];</span><br><span class="line"><span class="keyword">while</span>(--i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>((*p-&gt;state == TASK_RUNNING &amp;&amp; (*p)-&gt;counter&gt;c) <span class="comment">//TASK_RUNNING -&gt;就绪队列 </span></span><br><span class="line">c=(*p)-&gt;counter, next=i; <span class="comment">//找到最大的counter</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(c) <span class="keyword">break</span>;  <span class="comment">//如果最大的counter &gt; 0 就跳出去执行switch_to(next);</span></span><br><span class="line"><span class="keyword">for</span>(p=&amp;LAST_TASK;p&gt;&amp;FIRST_TASK;--p)</span><br><span class="line">(*p)-&gt;counter=((*p)-&gt;counter&gt;&gt;<span class="number">1</span>)+(*p)-&gt;priority; </span><br><span class="line">&#125;</span><br><span class="line">switch_to(next);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在Linux中，将PCB做成了一个数组，NR_TASKS就是数组的范围。首先将p指向PCB的最后一个元素，然后遍历整个就绪队列找到counter最大的进程，如果counter &gt; 0则直接跳出循环执行 switch_to(next)，跳到next进程去执行。如果counter &lt;= 0 则更新所有进程的优先级；</p><h3 id="counter的两个作用"><a href="#counter的两个作用" class="headerlink" title="counter的两个作用"></a>counter的两个作用</h3><h4 id="优先级"><a href="#优先级" class="headerlink" title="优先级"></a>优先级</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(--i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>((*p-&gt;state == TASK_RUNNING &amp;&amp; (*p)-&gt;counter&gt;c)</span><br><span class="line">c=(*p)-&gt;counter, next=i; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过分析我们发现，此时的counter类似于优先级的概念，即我们<strong>从就绪队列中找到一个优先级最大的进程并跳去执行</strong>。</p><p>如果当循环遍历结束找到的counter 不大于零 –&gt;说明就绪队列中进程的时间片用光了。此时重置一下所有进程(就绪队列 + 阻塞队列) 的counter。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(p=&amp;LAST_TASK;p&gt;&amp;FIRST_TASK;--p)</span><br><span class="line">(*p)-&gt;counter=((*p)-&gt;counter&gt;&gt;<span class="number">1</span>)+(*p)-&gt;priority;</span><br></pre></td></tr></table></figure><p>此时各个进程的counter = counter(当前) / 2 + priority(初始)；当进程一直阻塞，其counter = 1+1/2 +1/4 + 1/8 …最后会收敛于<strong>2*p</strong></p><p>我们知道<strong>先前经过IO阻塞的进程的counter一定要比经过就绪队列执行后的进程的counter要大</strong>，所以当重置后，其counter也一定更大，那么当IO阻塞型的进程再次回到就绪队列后，其优先级一定更高，就会优先执行，所以在一定程度上就照顾了IO型任务。</p><h4 id="时间片"><a href="#时间片" class="headerlink" title="时间片"></a>时间片</h4><p>counter又是典型的时间片，所以是轮转调度，保证了响应</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">do_timer</span><span class="params">(...)</span> <span class="comment">//在kernel/sched.c中</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>((--current-&gt;counter&gt;<span class="number">0</span>) </span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">current-&gt;counter=<span class="number">0</span>;</span><br><span class="line">schedule(); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果当前进程的counter大于0，就减1并且结束函数。如果小于等于0，就将当前进程的counter置为0，执行schedule函数。</p><p><strong>总结</strong></p><ul><li>通过counter实现了优先级动态的调整，同时保证了响应时间的界；</li><li>经过IO后，counter就会变大；IO时间越长，counter越大，照顾了IO进程，变相的照顾了前台任务；</li><li>后台进程一直按照counter轮转，近似于SJF调度；</li><li>每个进程只用维护一个变量counter，简单、高效，简直完美！</li></ul><p><strong>参考资料</strong></p><p><a href="https://www.bilibili.com/video/BV1d4411v7u7?p=15" target="_blank" rel="noopener">哈工大李治军操作系统</a></p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;什么是CPU调度？&quot;&gt;&lt;a href=&quot;#什么是CPU调度？&quot; class=&quot;headerlink&quot; title=&quot;什么是CPU调度？&quot;&gt;&lt;/a&gt;什么是CPU调度？&lt;/h2&gt;&lt;p&gt;调度即为切换-&amp;gt; 获取到 switch_to(cur, next) 中的 next，一旦获得到next 便切换到 next；&lt;/p&gt;
&lt;p&gt;如下图所示：PID1的进程正在执行，当执行到一定程度后由于阻塞或者时间片到时等原因，不让它继续执行了。现在操作系统需要切换另外一个进程去执行，但是现在就绪队列中有两个进程分别为PID2、PID3。PID2是先前read() 引发磁盘读阻塞现在又处于就绪了，PID3是先前时间片到时而阻塞现在又就绪了，那么此是PID2、PID3都处于就绪状态，&lt;strong&gt;CPU接下来该切换到PID2好呢还是切换到PID3好呢？？&lt;/strong&gt;&lt;/p&gt;</summary>
    
    
    
    
    <category term="操作系统" scheme="http://yoursite.com/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>用户级线程与内核级线程</title>
    <link href="http://yoursite.com/2021/06/24/%E7%94%A8%E6%88%B7%E7%BA%A7%E7%BA%BF%E7%A8%8B%E4%B8%8E%E5%86%85%E6%A0%B8%E7%BA%A7%E7%BA%BF%E7%A8%8B/"/>
    <id>http://yoursite.com/2021/06/24/%E7%94%A8%E6%88%B7%E7%BA%A7%E7%BA%BF%E7%A8%8B%E4%B8%8E%E5%86%85%E6%A0%B8%E7%BA%A7%E7%BA%BF%E7%A8%8B/</id>
    <published>2021-06-24T12:04:40.000Z</published>
    <updated>2021-08-09T03:18:56.916Z</updated>
    
    <content type="html"><![CDATA[<h1 id="用户级线程"><a href="#用户级线程" class="headerlink" title="用户级线程"></a>用户级线程</h1><h3 id="进程切换与线程切换的联系"><a href="#进程切换与线程切换的联系" class="headerlink" title="进程切换与线程切换的联系"></a>进程切换与线程切换的联系</h3><p>进程切换——&gt; 资源 (内存)+ 指令执行序列</p><p>线程切换——&gt;保留了并发的优点同时又避免了进程切换的代价(实质上就是映射表不变而PC指针变)</p><p>每个进程都包含一个映射表，如果进程切换了，那么程序选择的映射表也要跟着换。进程的切换主要包含两个部分即<strong>指令的切换</strong> + <strong>映射表的切换</strong>。其中指令的切换就是从这段程序跳到另外一段程序去执行，映射表的切换就是内存资源的切换。而<strong>线程的切换同属于一个进程里，不存在映射表的切换，只是指令的切换</strong>。所以在了解进程的切换之前，我们先来了解线程的切换，进程的切换就是在线程切换的基础上加上映射表的切换。</p><a id="more"></a> <h3 id="多线程实现浏览器网页的加载"><a href="#多线程实现浏览器网页的加载" class="headerlink" title="多线程实现浏览器网页的加载"></a>多线程实现浏览器网页的加载</h3><p>为什么 通常在网速比较慢的时候我们访问一个网站时，网页的加载过程通常是先出现一些文本，过了一会再出现图片、视频呢？</p><p>因为浏览器向服务器发起访问的程序是一个进程，它包含多个线程，如：用来从服务器接收数据的线程、显示文本的线程、用来处理图片的线程以及用来显示图片的线程。设想一下，如果这些线程变成一个程序顺序执行会怎么样？</p><p>如果依次执行，那么通常向服务器接收数据的线程会比较慢，只有在当前线程执行完毕才开始渲染显示，那么将有一段时间网页是空的，影响用户体验。那么网页的加载是如何实现的呢？</p><p>多线程并发交替执行，当接收数据线程接收完文本数据后就切换到显示文本线程加载文本信息，之后再切换回去接收图片等数据再加载，交替执行。那么为什么加载网页的是多个线程的协同而不是多个进程呢？</p><p>浏览器接收服务器的数据肯定都是存储在一个缓冲区中的，并且缓冲区是线程共享的。如果是多进程实现的话，那就必然会有多个映射表，接收数据的进程需要把数据写到自己的缓冲区上，而显示处理进程又需要从该缓冲区中拿到数据，因为地址是分离的，取数据时就会有数据拷贝的问题，特别麻烦。因为这些程序本身就涉及合作需要共享数据，所以就没有必要进行地址分离，完全可以在一块地址上进行。因此通过多线程实现就是最好的选择。</p><h3 id="用户级线程切换的实现"><a href="#用户级线程切换的实现" class="headerlink" title="用户级线程切换的实现"></a>用户级线程切换的实现</h3><ul><li><p>Yield——&gt; 核心切换</p></li><li><p>Create——&gt; 创造出第一次切换的样子</p></li></ul><p><strong>要实现线程的切换我们首先需要创建两个线程</strong></p><p><strong>线程1</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">100</span>:A()</span><br><span class="line">&#123;</span><br><span class="line">B();</span><br><span class="line"><span class="number">104</span>:</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">200</span>: B()</span><br><span class="line">&#123;</span><br><span class="line">Yield1();</span><br><span class="line"><span class="number">204</span>:</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Yield1</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">find</span> <span class="number">300</span>;</span><br><span class="line">jmp <span class="number">300</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>线程2</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">300</span>:C()</span><br><span class="line">&#123;</span><br><span class="line">D();</span><br><span class="line"><span class="number">304</span>:</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">400</span>: D()</span><br><span class="line">&#123;</span><br><span class="line">Yield2();</span><br><span class="line"><span class="number">404</span>:</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Yield2</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">find</span> <span class="number">204</span>;</span><br><span class="line">jmp <span class="number">204</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>两个执行序列与一个栈 实现两个线程的切换</strong></p><p>首先线程1中A()执行，然后跳到B()执行 ，并将函数返回地址104压栈。进入到B()之后将调用Yield1()，并将返回地址压栈，执行Yield1()函数将会跳到300处到线程2去执行，然后在C()函数中执行D()函数并将304压栈，跳到D()函数去执行。接着执行Yield2(),并将404压栈。此时栈中元素如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">104，204，304，404 &lt;(栈顶)</span><br></pre></td></tr></table></figure><p>此时执行Yield2()函数，将跳到204，回到线程1处去执行。现在看似实现了两个线程的切换，但是继续执行将出大问题了？</p><p>因为当跳回线程1中204的位置来执行。紧接着遇到了就是B()函数的 <code>}</code>，<strong>此处的 <code>}</code> 将会编译成一段汇编指令 <code>ret</code> 执行弹栈的操作。</strong>此时栈顶元素为404,执行弹栈操作后将会跳到404处即线程2去执行，所以问题就出现了。本来B()函数返回要回到当前线程的104处去执行，但是反而跑去线程2去执行了。为什么呢？？ ——&gt; <strong>两个线程共用了一个栈就是原罪</strong>，所以要想解决这个问题就要把一个栈变成两个栈，让两个线程在各自的栈中玩自己的就好了啊。这也是为什么一个进程中的多个线程要有自己私有的栈了~</p><p><strong>从一个栈到两个栈</strong></p><p>当从一个栈到两个栈转换后，执行以上操作此时栈中元素情况如下：</p><p>线程1的栈</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">104，204 &lt;(栈顶)</span><br></pre></td></tr></table></figure><p>TCB1</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">esp &#x3D; 1000</span><br></pre></td></tr></table></figure><p>线程2的栈</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">304， 404 &lt;(栈顶)</span><br></pre></td></tr></table></figure><p>TCB2</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">esp &#x3D; 2000</span><br></pre></td></tr></table></figure><p><strong>此时每个线程各用一套栈</strong>，那么要想实现线程的切换就要考虑两套栈的切换。两套栈的切换这种动态的过程就需要记录存储当前状态的信息，即栈的信息要存放起来保证日后切回来的时候能找得到，这就需要一个数据结构来存储两套栈的地址信息了，此时<strong>线程控制块TCB</strong>出现了，<strong>TCB是一个全局的数据结构</strong>，专门用来记录两套栈的信息。 <code>esp</code>是物理寄存器，在CPU中,<code>esp</code>指向的即是当前栈的地址，把栈切换实质上就是<code>esp</code>寄存器的改变。</p><p><strong>因为涉及到<code>esp</code>的改变所以我们要重写Yield()函数</strong>，我们主要分析下Yiele2()函数，重写后的Yield2()函数如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Yield2</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">TCB2.esp = esp;<span class="comment">// 保存当前栈顶地址 当前esp -&gt; 2000</span></span><br><span class="line">esp = TCB1.esp;<span class="comment">// 切换栈 切换后 esp -&gt; 1000</span></span><br><span class="line">jmp <span class="number">204</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当前<code>esp</code>指向2000即线程2的栈顶元素地址，要想改变<code>esp</code>，首先要将2000保存在 TCB2中，然后将1000赋给<code>esp</code>，(1000为之前线程1跳到线程2时所保存在TCB1中的地址信息)。此时栈就已经切换回到线程1了。栈切换后接着就是PC的切换，PC切换后就要跳到204去执行。跳到204去执行紧接着就又会遇到B()函数的返回 <code>}</code>，此时又将执行弹栈操作，当前<code>esp</code>-&gt;1000 栈顶元素为204，<strong>所以弹栈204，并再次跳到204去执行</strong>(每次弹栈就要跳去执行)。<strong>那么问题又出现了，我们不是刚刚从线程2切换回线程1执行完B()函数并返回嘛？？</strong>B()函数执行完应该回到104处去执行啊？，怎么又要跳回204重新执行一遍呢？？</p><p>因为在Yield2()这个函数中 jump 204是跳到204去执行，那么Yield2()函数就无法执行到 <code>}</code>，所以也就无法将204弹栈，因此导致204处多次执行。那么我们怎么办呢？？ ——&gt; <strong>再次修改Yield2()函数</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Yield2</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">TCB2.esp = esp;</span><br><span class="line">esp = TCB1.esp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当前Yield2()函数如上，删去了jump204; 仅仅保留了 栈的<code>esp</code>指针的切换。此时执行完Yield2()函数即执行完 <code>}</code>后，将执行弹栈操作，而此时栈已经切换回TCB1，栈顶元素正好是204，那就直接跳到204处去执行，204处执行完后，B()函数返回 <code>}</code>, 接着弹栈 104 再跳回 A() 函数中去执行。<strong>一切都变得完美了！！</strong></p><p>通过上面的分析我们发现，两个线程的样子即为<strong>1.两个栈、2.两个TCB、3.切换的PC在栈中</strong>。 <strong>TCB和栈相互配合即为线程切换的核心</strong>。 实现<code>TreadCreate</code> 的核心就是用程序做出这三样东西。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TreadCreate</span><span class="params">(A)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">TCB *tcb = <span class="built_in">malloc</span>();</span><br><span class="line">*<span class="built_in">stack</span> = <span class="built_in">malloc</span>();</span><br><span class="line">*<span class="built_in">stack</span> = A; <span class="comment">//初始化栈顶即为A()函数100位置处</span></span><br><span class="line">tcb.esp = <span class="built_in">stack</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 至此我们便可以通过 <code>ThreadCreate</code> 与 <code>Yield</code> 两个函数的配合实现用户级线程的切换了！</p><h3 id="用户级线程的缺点"><a href="#用户级线程的缺点" class="headerlink" title="用户级线程的缺点"></a>用户级线程的缺点</h3><p>用户级线程是在用户态中切来切去，一般并不需要进入到内核，操作系统就感知不到其存在。当需要管理硬件的时候就要进入到内核，一旦遇到IO后操作系统CPU就会切换，因为操作系统感知不到用户级线程的存在也就不会将CPU执行权重新交回到当前进程去执行，而是去执行其他的进程，那么当前进程就要等待，对于一些实时性比较强的应用，用户体验会很差。这也是<code>Chrom</code>浏览器打开新标签采用多进程的原因</p> <img src="/2021/06/24/%E7%94%A8%E6%88%B7%E7%BA%A7%E7%BA%BF%E7%A8%8B%E4%B8%8E%E5%86%85%E6%A0%B8%E7%BA%A7%E7%BA%BF%E7%A8%8B/1.png" alt="1" style="zoom: 50%;"><h1 id="核心级线程"><a href="#核心级线程" class="headerlink" title="核心级线程"></a>核心级线程</h1><h2 id="多处理器和多核的区别"><a href="#多处理器和多核的区别" class="headerlink" title="多处理器和多核的区别"></a>多处理器和多核的区别</h2><img src="/2021/06/24/%E7%94%A8%E6%88%B7%E7%BA%A7%E7%BA%BF%E7%A8%8B%E4%B8%8E%E5%86%85%E6%A0%B8%E7%BA%A7%E7%BA%BF%E7%A8%8B/2.png" alt="2"><ul><li><p>多处理器：每一个CPU有自己的一套映射即MMU(MMU-&gt; 内存映射)     </p></li><li><p>多核：多个CPU共用一套MMU =&gt;  <strong>并行</strong> -&gt; 类似于线程</p></li></ul><p>一个系统中往往是用户级线程和核心级线程同时存在的</p><p> 一个系统如果不实现核心级线程，那多核实质上是没有用的，多核是建立在核心级线程的基础上的</p><h2 id="从两个栈到两套栈"><a href="#从两个栈到两套栈" class="headerlink" title="从两个栈到两套栈"></a>从两个栈到两套栈</h2><p>核心级线程既能在用户态中跑，又能在内核态中跑，那就意味着要进入到内核。先前我们了解到用户级线程需要用户栈来记录函数的调用信息，那核心级线程在用户态执行的时候需要用户栈去记录用户态的函数调用，到内核中执行时必然也会进行系统函数调用，那自然也需要一个内核栈来记录其在核心态中执行的函数调用信息。所以<strong>核心级线程就需要一套栈，相应的线程切换就会从两个栈变成两套栈。</strong> 同样此前用户级线程中一个TCB关联一个栈，TCB的切换引起<strong>两个</strong>用户栈的切换，而现在<strong>核心级线程中一个TCB就应该关联一套栈</strong>，并且TCB在内核中，在内核中切换TCB就会切换<strong>两套</strong>栈。</p><h2 id="用户栈与内核栈的关联"><a href="#用户栈与内核栈的关联" class="headerlink" title="用户栈与内核栈的关联"></a>用户栈与内核栈的关联</h2><img src="/2021/06/24/%E7%94%A8%E6%88%B7%E7%BA%A7%E7%BA%BF%E7%A8%8B%E4%B8%8E%E5%86%85%E6%A0%B8%E7%BA%A7%E7%BA%BF%E7%A8%8B/3.png" alt="3" style="zoom: 50%;"><p>起先是在用户态中执行，就会在用户栈中来回折腾，一旦有了中断(INT、鼠标、键盘、时钟中断)就会到内核态并启用内核栈(intel 硬件做好了的)。即每个用户栈关联一个内核栈，起先在用户栈执行的时候就用用户栈，<strong>一旦经过系统中断进入内核态，操作系统便会通过硬件寄存器找到这个线程所对应的内核栈并启用内核栈。</strong></p><p>启用内核栈后，首先就会压入<code>源SS</code>和<code>源SP</code> (在用户态执行的栈)，同时压入<code>源PC</code>、<code>源CS</code> (在用户态执行的指令-&gt; 执行到哪里了-&gt; 方便跳回来后继续执行)。</p><p>通过将用户栈的信息压栈就实现了用户栈与内核栈的相关联-&gt; 相当于从内核态向上拉了一条连接到用户态的链。</p><p>同样当在内核栈中执行完需要返回到用户栈的时候便通过 <code>IRET</code>(中断)指令执行弹栈操作，根据栈底压入的用户栈信息就又返回到用户栈去执行了。</p><h2 id="实例解析核心级线程的切换"><a href="#实例解析核心级线程的切换" class="headerlink" title="实例解析核心级线程的切换"></a>实例解析核心级线程的切换</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">100</span>:A()</span><br><span class="line">&#123;</span><br><span class="line">B();</span><br><span class="line"><span class="number">104</span>:</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">200</span>:B()</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">read</span>();</span><br><span class="line"><span class="number">204</span>:</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">300</span>:<span class="built_in">read</span>()</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> <span class="number">0x80</span>;</span><br><span class="line"><span class="number">304</span>:</span><br><span class="line">&#125;</span><br><span class="line">---------------------------------</span><br><span class="line">system_call:</span><br><span class="line">call sys_read;</span><br><span class="line"><span class="number">1000</span>:</span><br><span class="line"><span class="number">2000</span>:sys_read()&#123;&#125;</span><br></pre></td></tr></table></figure><p>首先A()函数调用B()函数将104压栈，执行B()函数并在B()函数中调用read()函数，read()是一个库函数，所以就会展开成一  段包含<code>int 0x80</code>的中断代码，此时该核心级线程从用户态跳到内核态去执行，同时用户栈将204压栈，并根据硬件寄存器启用对应的内核栈。</p><img src="/2021/06/24/%E7%94%A8%E6%88%B7%E7%BA%A7%E7%BA%BF%E7%A8%8B%E4%B8%8E%E5%86%85%E6%A0%B8%E7%BA%A7%E7%BA%BF%E7%A8%8B/4.png" alt="4" style="zoom: 50%;"><p>此时用户栈信息如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">104, 204 &lt; (栈顶)</span><br></pre></td></tr></table></figure><p><code>int</code>指令执行完毕紧接着将304压入内核栈，并将CS(段基址)压入栈，接着跳到system_call去执行，在system_call中查表调用系统函数sys_read(),同时将1000压栈。 此时内核栈信息如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SS : SP , EFLAGS , 304 , CS , 1000 &lt;(栈顶)</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sys_read()&#123;</span><br><span class="line">启动磁盘读；将自己变成阻塞；找到 next;</span><br><span class="line">switch_to(cur, next);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时已经进入内核并执行系统函数 sys_read()，一旦执行sys_read()便会启动磁盘读，启动磁盘读自己就变成阻塞了，一阻塞就会让出CPU执行权引起调度。紧接着操作系统就会switch_to(cur，next)找到下一个线程并跳去执行。其中 - &gt; cur : 当前线程的TCB  next : 下一个线程的TCB (TCB中存储的即为各自内核栈的<code>esp</code>)</p><img src="/2021/06/24/%E7%94%A8%E6%88%B7%E7%BA%A7%E7%BA%BF%E7%A8%8B%E4%B8%8E%E5%86%85%E6%A0%B8%E7%BA%A7%E7%BA%BF%E7%A8%8B/5.png" alt="5" style="zoom:67%;"><p> 如上图所示，我们根据TCB中的<code>esp</code> 切换TCB，此时便从线程S跳到线程T去执行了，紧接着执行的就是线程T的内核态代码，<strong>我们知道一个线程在执行的过程中一般绝大部分时间是在用户态执行的，只有当调用系统接口的时候才会进入到内核中去执行，溜达一圈之后会继续回到用户态去执行。</strong>所以此时线程T在内核态执行完后一定会回到用户态去执行。<strong>那么它如何返回到用户态去执行呢？</strong></p><p><code>iret</code>中断返回 –&gt; 上图 线程T 的 “????” 处即为一段包含 <code>iret</code>的代码，根据中断返回-&gt;弹栈操作将线程T用户态的执行指令信息以及用户栈信息弹出并跳到用户态去执行即可！！！</p><h2 id="内核级线程切换核心思想—switch-to五段论"><a href="#内核级线程切换核心思想—switch-to五段论" class="headerlink" title="内核级线程切换核心思想—switch_to五段论"></a>内核级线程切换核心思想—switch_to五段论</h2><img src="/2021/06/24/%E7%94%A8%E6%88%B7%E7%BA%A7%E7%BA%BF%E7%A8%8B%E4%B8%8E%E5%86%85%E6%A0%B8%E7%BA%A7%E7%BA%BF%E7%A8%8B/6.png" alt="6" style="zoom:67%;"><p><strong>switch_to(cur, next)五段论</strong></p><ol><li>首先要通过中断进入到内核；</li><li>当需要切换时就要找到相应的TCB；</li><li>完成TCB的切换；</li><li>当TCB切换完之后就要 根据TCB完成内核栈的切换；</li><li>内核栈切换完毕之后在通过<code>IRET</code>中断返回指令将相应的用户栈切回来；</li></ol><p>首先是线程S在用户态中执行，一旦经过系统中断便进入到内核态去执行，就会用内核栈，同时内核栈又与TCB相关联。一旦需要切换，就会根据线程S的TCB找到下一个线程的TCB即线程T的TCB，所以就完成了TCB的切换。而线程T的TCB对应有线程T的内核栈，也就同样可以根据TCB完成内核栈的切换。线程T的内核栈又关联着线程T的用户栈，就可以根据<code>IRET</code>中断返回指令切回到用户态去执行。以上便是核心级线程切换的思路！！</p><h2 id="用户级线程VS核心级线程"><a href="#用户级线程VS核心级线程" class="headerlink" title="用户级线程VS核心级线程"></a>用户级线程VS核心级线程</h2><table><thead><tr><th align="center">TYPE</th><th align="center">用户级线程</th><th align="center">核心级线程</th><th align="center">用户+核心级线程</th></tr></thead><tbody><tr><td align="center">利用多核</td><td align="center">差</td><td align="center">好</td><td align="center">好</td></tr><tr><td align="center">并发度</td><td align="center">低</td><td align="center">高</td><td align="center">高</td></tr><tr><td align="center">代价</td><td align="center">小</td><td align="center">大</td><td align="center">中</td></tr><tr><td align="center">内核改动</td><td align="center">无</td><td align="center">大</td><td align="center">大</td></tr><tr><td align="center">用户灵活性</td><td align="center">大</td><td align="center">小</td><td align="center">大</td></tr></tbody></table><p><strong>参考资料</strong></p><ul><li><a href="https://www.bilibili.com/video/BV1d4411v7u7?p=10" target="_blank" rel="noopener">哈工大李治军操作系统</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;用户级线程&quot;&gt;&lt;a href=&quot;#用户级线程&quot; class=&quot;headerlink&quot; title=&quot;用户级线程&quot;&gt;&lt;/a&gt;用户级线程&lt;/h1&gt;&lt;h3 id=&quot;进程切换与线程切换的联系&quot;&gt;&lt;a href=&quot;#进程切换与线程切换的联系&quot; class=&quot;headerlink&quot; title=&quot;进程切换与线程切换的联系&quot;&gt;&lt;/a&gt;进程切换与线程切换的联系&lt;/h3&gt;&lt;p&gt;进程切换——&amp;gt; 资源 (内存)+ 指令执行序列&lt;/p&gt;
&lt;p&gt;线程切换——&amp;gt;保留了并发的优点同时又避免了进程切换的代价(实质上就是映射表不变而PC指针变)&lt;/p&gt;
&lt;p&gt;每个进程都包含一个映射表，如果进程切换了，那么程序选择的映射表也要跟着换。进程的切换主要包含两个部分即&lt;strong&gt;指令的切换&lt;/strong&gt; + &lt;strong&gt;映射表的切换&lt;/strong&gt;。其中指令的切换就是从这段程序跳到另外一段程序去执行，映射表的切换就是内存资源的切换。而&lt;strong&gt;线程的切换同属于一个进程里，不存在映射表的切换，只是指令的切换&lt;/strong&gt;。所以在了解进程的切换之前，我们先来了解线程的切换，进程的切换就是在线程切换的基础上加上映射表的切换。&lt;/p&gt;</summary>
    
    
    
    
    <category term="操作系统" scheme="http://yoursite.com/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>MySQL索引 锁 存储引擎</title>
    <link href="http://yoursite.com/2021/06/18/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A/"/>
    <id>http://yoursite.com/2021/06/18/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A/</id>
    <published>2021-06-18T02:42:30.000Z</published>
    <updated>2021-10-07T08:24:27.218Z</updated>
    
    <content type="html"><![CDATA[<h1 id="数据库索引"><a href="#数据库索引" class="headerlink" title="数据库索引"></a>数据库索引</h1><h2 id="何为索引？为什么要使用索引？"><a href="#何为索引？为什么要使用索引？" class="headerlink" title="何为索引？为什么要使用索引？"></a>何为索引？为什么要使用索引？</h2><p><strong>索引是一种用于快速查询和检索数据的数据结构。常见的索引结构有: B 树， B+树和 Hash。</strong></p><p>查询数据最基本的方式为全表扫描，即将整张表的数据全部或者分批次加载到内存中，<strong>磁盘存储的最小单位为块</strong>(512Byte)，由多行数据来组成。我们在查询数据时将块加载进内存，<strong>然后逐个块的去轮寻</strong>，找到目标数据即返回，这种查询方式是非常慢的，所以我们就需要引入一种更高效的查询机制即索引。<strong>索引的灵感来源于字典，类似于字典的目录</strong>。</p><a id="more"></a><h2 id="索引的优缺点"><a href="#索引的优缺点" class="headerlink" title="索引的优缺点"></a>索引的优缺点</h2><p><strong>优点</strong></p><ul><li>使用索引可以大大加快 数据的检索速度（大大减少了检索的数据量）, 这也是创建索引的最主要的原因。</li><li>通过创建唯一性索引，可以保证数据库表中每一行数据的唯一性。</li></ul><p><strong>缺点</strong></p><ul><li>创建索引和维护索引需要消耗许多资源，当对表中的数据进行增删改的时候，如果数据有索引，那么索引也需要动态的修改，会降低 SQL 执行效率。</li><li>在数据量比较小的时候，直接加载进内存全表扫描要比索引查询方式更好。</li></ul><h2 id="索引底层的数据结构"><a href="#索引底层的数据结构" class="headerlink" title="索引底层的数据结构"></a>索引底层的数据结构</h2><h3 id="二叉查找树"><a href="#二叉查找树" class="headerlink" title="二叉查找树"></a>二叉查找树</h3><p><strong>索引结构为什么不使用二叉查找树</strong></p><p>影响数据库查询效率的因素主要与时间复杂度和IO次数有关。二叉树会面临特殊的情况即向一侧倾斜，这样就增加了时间复杂度。虽然采用平衡二叉树可以解决二叉树向一侧倾斜的情况，但是仍然存在效率问题。即索引块都在磁盘中，查询数据时会首先将根数据读入内存中， 之后再逐渐二分查找读入数据发生IO，即检索的深度每增加1就会增加一次IO，平衡二叉树或者红黑树每个节点最多有2个孩子，但实际上数据库的数据块会非常多，因此树的深度会非常深，IO的次数自然巨大，这样一来检索的性能甚至会比全表扫描慢很多，无法满足优化查询的需求。</p><h3 id="B-树-amp-B-树"><a href="#B-树-amp-B-树" class="headerlink" title="B 树 &amp; B+树"></a>B 树 &amp; B+树</h3><p>B 树也称 B-树,全称为 <strong>多路平衡查找树</strong> ，B+ 树是 B 树的一种变体，其中B 即为 <code>Balanced</code>的意思。<strong>目前大部分数据库系统及文件系统都采用 B-Tree 或其变种 B+Tree 作为索引结构。</strong></p><p><strong>B树</strong></p><ul><li>B树根节点至少包含两个孩子</li><li>树中每一个节点最多包含m个孩子<code>(m &gt;= 2)</code></li><li>除根节点和叶子节点外，其他每个节点至少有<code>ceil(m / 2)</code> 个孩子(ceil -&gt; 向上取整)</li><li>所有的叶子节点都位于同一层</li></ul><p><strong>B+树</strong></p><ul><li>非叶子节点的子树指针与关键字个数相同</li><li>非叶子节点的子树指针<code>P[i]</code>，指向关键字值 <code>(k[i], k[i + 1])</code>的子树</li><li>非叶子节点仅用来索引数据，数据都保存在叶子节点中</li><li>所有叶子节点均有一个链指针指向下一个叶子节点</li></ul><img src="/2021/06/18/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A/2.png" alt="2" style="zoom: 67%;"><h3 id="相比于B树，B-树更适合做存储索引"><a href="#相比于B树，B-树更适合做存储索引" class="headerlink" title="相比于B树，B+树更适合做存储索引"></a>相比于B树，B+树更适合做存储索引</h3><ul><li>B+树的磁盘读写代价更低</li><li>B+树的查询效率更稳定</li><li>B+树更有利于对数据库的扫描</li></ul><p>B+-树内部结构并没有指向关键字具体信息的指针，即不存放数据只存放索引信息。因此内部节点相对于B-树更少，如果把所有同一内部节点的关键字放在同一盘块中，该盘块所能容纳的关键字个数也越多，一次性读入内存中需要查找的关键字也就越多，相对来说IO读写次数就降低了。</p><p>B+-树内部的节点并不是最终指向文件内容的节点，而只是叶子节点中关键字的索引。任何关键字的索引必须走一条从根节点到叶子节点的路径，所有关键字查找的路径长度相同，所以几乎每一个数据的查询效率都相同(<code>O(logn)</code>).</p><p>B树在提高了磁盘的IO性能的同时，并没有解决元素遍历效率的问题。而B+-Tree只需要遍历叶子节点就可以解决对全部关键字信息的扫描，所以对于数据库中频繁使用的范围查询B+-Tree更合适。</p><h3 id="Hash表"><a href="#Hash表" class="headerlink" title="Hash表"></a>Hash表</h3><p>哈希表是键值对的集合，通过键(key)即可快速取出对应的值(value)，因此哈希表可以快速检索数据(时间复杂度接近<code>O(1)</code>)</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hash = hashfunc(key)</span><br><span class="line">index = hash % array_size</span><br></pre></td></tr></table></figure><img src="/2021/06/18/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A/3.png" alt="3" style="zoom:80%;"><p>Hash索引根据Hash函数计算，只需要一次计算，便能够找到查询数据所在的头，并不像B+树从根节点再到叶子节点的定位。理论上Hash索引的查询效率更高，但是<strong>由于Hash本身的特性也带来了很多的局限和弊端</strong>：</p><ul><li>仅仅能满足“=” ，“IN” ，不能使用范围查询</li><li>无法被用来避免数据的排序操作</li><li>不能利用部分索引键查询</li><li>不能避免全表扫描</li><li>遇到大量的Hash值相等的情况后性能并不一定就会比B+-Tree索引高</li></ul><p>Hash索引比较的是进行哈希运算之后的hash值，所以只能用于等值的过滤，并不适用于基于范围的查询。因为<strong>经过相应hash算法处理后的hash值的大小关系并不能保证和hash运算前的大小关系一致</strong>。索引也同样不能进行排序操作。</p><p>对于组合索引，Hash索引在计算hash值的时候是组合键(即将组合索引键合并之后再一起运算的hash值，而不是单独计算hash值)，所以利用组合索引的前面一个或几个索引键进行查询的时候，Hash索引也无法被利用。而B+树是支持利用组合索引中的部分索引的。</p><p>Hash索引是将索引键通过hash运算后将<strong>运算结果的hash值</strong>和所对应的<strong>行指针信息</strong>存放在一个<strong>bucket</strong>中。由于不同的索引键存在相同的hash值，所以即使取出满足某个hash键的数据也无法从hash索引中直接完成查询，还是要通过访问bucket中的实际数据进行相应的比较。</p><p>对于选择性比较低的索引键，如果创建Hash索引会出现大量记录指针信息存放于同一个bucket中的情况，从而造成整体性能低下。在极端的情况下，所有的键计算出来的hash值都是相同的，都存放在同一个bucket中，就变成了线性存储，查询效率极低。Hash索引的不稳定也正是它无法成为主流索引的原因。</p><h3 id="BitMap索引"><a href="#BitMap索引" class="headerlink" title="BitMap索引"></a>BitMap索引</h3><ul><li>某个字段有几种状态时适合位图索引</li><li>Oracle为主流的支持位图索引的数据库</li><li>位图索引锁的粒度大，封锁范围广，并发度低</li></ul><h2 id="索引的类型"><a href="#索引的类型" class="headerlink" title="索引的类型"></a>索引的类型</h2><ol><li>数据结构分类可分为：<strong>B+tree索引、Hash索引、Full-text索引 、R-tree索引</strong> </li><li>物理存储分类可分为：<strong>聚簇索引、二级索引（辅助索引）</strong></li><li>字段特性分类可分为：<strong>主键索引、唯一键索引、普通索引、前缀索引</strong></li><li>字段个数分类可分为：<strong>单列索引、联合索引（复合索引、组合索引）</strong></li></ol><h3 id="主键索引-Primary-Key"><a href="#主键索引-Primary-Key" class="headerlink" title="主键索引(Primary Key)"></a>主键索引(Primary Key)</h3><p>数据表的主键列使用的就是主键索引。一张数据表有只能有一个主键，并且主键不能为 null，不能重复。在 MySQL 的 <code>InnoDB</code> 的表中，当没有显示的指定表的主键时，<code>InnoDB</code> 会自动先检查表中是否有唯一索引的字段，如果有，则选择该字段为默认的主键，否则 <code>InnoDB</code> 将会自动创建一个 6Byte 的自增主键。</p><h3 id="二级索引-辅助索引"><a href="#二级索引-辅助索引" class="headerlink" title="二级索引(辅助索引)"></a>二级索引(辅助索引)</h3><p>二级索引又称为辅助索引，是因为二级索引的叶子节点存储的数据是主键。也就是说，通过二级索引，可以定位主键的位置。</p><ol><li><strong>唯一索引(Unique Key)</strong> ：唯一索引也是一种约束。<strong>唯一索引的属性列不能出现重复的数据，但是允许数据为 NULL，一张表允许创建多个唯一索引。</strong> 建立唯一索引的目的大部分时候都是为了该属性列的数据的唯一性，而不是为了查询效率。</li><li><strong>普通索引(Index)</strong> ：普通索引的唯一作用就是为了快速查询数据，一张表允许创建多个普通索引，并允许数据重复和 NULL。</li><li><strong>前缀索引(Prefix)</strong> ：前缀索引只适用于字符串类型的数据。前缀索引是对文本的前几个字符创建索引，相比普通索引建立的数据更小， 因为只取前几个字符。</li><li><strong>全文索引(Full Text)</strong> ：全文索引主要是为了检索大文本数据中的关键字的信息，是目前搜索引擎数据库使用的一种技术。Mysql5.6 之前只有 MYISAM 引擎支持全文索引，5.6 之后 <code>InnoDB</code> 也支持了全文索引。</li></ol><h2 id="密集索引与稀疏索引的区别"><a href="#密集索引与稀疏索引的区别" class="headerlink" title="密集索引与稀疏索引的区别"></a>密集索引与稀疏索引的区别</h2><ul><li>密集索引文件中的每一个搜索码值都对应一个索引值</li><li>稀疏索引文件只为索引码的某些值建立索引项</li></ul><p>密集索引叶子节点保存的<strong>不仅仅是键值，还保存了位于同一行记录中的其他列的信息</strong>。由于密集索引决定了表的物理排列顺序，一个表只能有一个物理排列顺序，所以一个表只能创建一个密集索引。</p><p>稀疏索引叶子节点只保存了键位信息及该行数据地址，非主键索引只保存了键位信息及其主键。<strong>定位到叶子节点之后仍然需要通过地址或者主键信息进一步定位到数据。</strong></p><p>MySQL <strong><code>MyISAM</code>存储引擎，不管是主键索引，唯一键索引还是普通索引都是稀疏索引; <code>InnoDB</code>存储引擎, 有且只有一个密集索引。</strong></p><p><code>InnoDB</code>密集索引的选取规则如下 :</p><ul><li>若主键被定义，则主键作为密集索引</li><li>如果没有主键被定义，该表的第一个唯一非空索引则作为密集索引</li><li>若不满足以上条件，<code>innodb</code>内部会生成一个隐藏主键（密集索引）</li><li>非主键索引存储相关键位和其对应的主键值，包含两次查找</li></ul><img src="/2021/06/18/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A/6.png" alt="6" style="zoom: 50%;"><p>从上图中可以看到，如果一个索引是<strong>聚集索引</strong>，则其叶子节点上存放的即是数据本身，而如果一个索引是<strong>稀疏索引</strong>，叶子节点存放的仅是地址，指向将要查找的数据。<code>InnoDB</code>如果查询条件为主键索引，则只需查询一次，但是辅助索引需要查询两次，先通过辅助索引查询到主键索引，再查询到数据。</p><h2 id="如何定位并优化慢查询SQL"><a href="#如何定位并优化慢查询SQL" class="headerlink" title="如何定位并优化慢查询SQL"></a>如何定位并优化慢查询SQL</h2><ul><li>根据慢日志定位慢查询<code>sql</code></li><li>使用<code>explain</code>等工具分许<code>sql</code></li><li>修改<code>sql</code>或者尽量让<code>sql</code>走索引</li></ul><p><strong>根据慢日志定位慢查询<code>sql</code></strong></p><p>1.查找慢查询日志</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> <span class="keyword">variables</span> <span class="keyword">like</span> <span class="string">'%quer%'</span>;</span><br></pre></td></tr></table></figure><p>2.打开慢查询日志并设置慢查询阈值为1秒</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">set</span> <span class="keyword">global</span> slow_query_log = <span class="keyword">on</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">set</span> <span class="keyword">global</span> long_query_time = <span class="number">1</span>;</span><br></pre></td></tr></table></figure><p>3.重连数据库,更新设置</p><p>4.制造慢查询<code>sql</code>并执行</p><p>5.查看慢查询数据库的记录(慢查询<code>sql</code>的条数)</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> <span class="keyword">status</span> <span class="keyword">like</span> <span class="string">'%slow_queries%'</span>;</span><br></pre></td></tr></table></figure><p>6.定位慢查询<code>sql</code>地址</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">slow_query_log_file</span><br></pre></td></tr></table></figure><p><strong>使用<code>explain</code>等工具分许<code>sql</code></strong></p><img src="/2021/06/18/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A/7.png" alt="7" style="zoom:80%;"><p><strong><code>Explain</code>关键字分析</strong></p><p><strong>type</strong>表示查询数据的方式，根据效率从高到低排序有如下几种。</p><p>如果type为index或all，表示本次扫描为全表扫描，说明这个语句是需要优化的。</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">system&gt;const&gt;eq_ref&gt;ref&gt;fulltext&gt;ref_or_null&gt;index_merge&gt;unique_subquery&gt;index_subquery&gt;range&gt;index&gt;all</span><br></pre></td></tr></table></figure><p><strong>extra</strong>中出现以下2项意味着MySQL根本不能使用索引，效率会受到重大影响，应尽可能对此进行优化</p><table><thead><tr><th align="center">extra项</th><th align="left">描述</th></tr></thead><tbody><tr><td align="center">Using filesort</td><td align="left">表示MySQL会对结果使用一个外部索引排序，而不是从表里按索引次序读到相关内容。可能在内存或者磁盘上进行排序。MySQL中无法利用索引完成的排序操作称为”文件排序“</td></tr><tr><td align="center">Using temporary</td><td align="left">表示MySQL在对查询结果排序时使用临时表，常见于排序 order by和分组查询group by。</td></tr></tbody></table><p><strong>修改<code>sql</code>或者尽量让<code>sql</code>走索引</strong></p><p>1.修改<code>sql</code>通过主键进行查找</p><p>2.添加索引</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> tb_test <span class="keyword">add</span> <span class="keyword">index</span> index_name(test_name);</span><br></pre></td></tr></table></figure><h2 id="联合索引的最左匹配原则的成因"><a href="#联合索引的最左匹配原则的成因" class="headerlink" title="联合索引的最左匹配原则的成因"></a>联合索引的最左匹配原则的成因</h2><p><strong>最左匹配原则</strong></p><ul><li>MySQL会一直向右匹配直到遇到范围查询（&gt;、&lt;、between、like）就停止匹配，比如 a=3 and b=4 and c&gt;5 and d=6,如果建立(a,b,c,d)顺序的索引，d是无法使用索引的，如果建立(a,b,d,c)的索引则都可以使用到，a、b、d的顺序可以任意调整。</li><li>=和in可以乱序，比如 a=1 and b=2 and c=3 建立(a,b,c)索引可以任意顺序，MySQL的查询优化器会帮你优化成索引可以识别的形式。</li></ul><p><strong>示例</strong>-&gt;对列col1、列col2和列col3建一个联合索引</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">index</span> admin_col1_col2_col3 <span class="keyword">on</span> <span class="keyword">admin</span> (col1,col2,col3);</span><br></pre></td></tr></table></figure><p>联合索引 admin_col1_col2_col3 实际建立了(col1)、(col1,col2)、(col,col2,col3)三个索引。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> <span class="keyword">admin</span> <span class="keyword">where</span> clo1 = <span class="number">1</span> <span class="keyword">and</span> clo2 = <span class="number">7</span> <span class="keyword">and</span> clo4 = <span class="number">5</span>;</span><br></pre></td></tr></table></figure><p>上面这个查询语句执行时会依照最左前缀匹配原则，检索时会使用索引(col1,col2)进行数据匹配。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from admin where clo2 &#x3D; 7;</span><br></pre></td></tr></table></figure><p>上面这条语句就不会走联合索引，而是会进行全表扫描。</p><p>MySQL创建联合索引的规则是首先会对联合合索引的最左边的，也就是第一个字段col1的数据进行排序，在第一个字段的排序基础上，然后再对后面第二个字段col2进行排序。其实就相当于实现了类似 order by col1 col2这样一种排序规则。因此第一个字段是绝对有序而第二个字段是无序的，因此直接使用第二个字段判断条件是用不到索引的。</p><h1 id="数据库锁"><a href="#数据库锁" class="headerlink" title="数据库锁"></a>数据库锁</h1><h2 id="什么是事务？"><a href="#什么是事务？" class="headerlink" title="什么是事务？"></a>什么是事务？</h2><p>事务是逻辑上的一组操作，要么都执行，要么都不执行，是一个不可分割的工作单位。</p><h2 id="事务的特性-ACID"><a href="#事务的特性-ACID" class="headerlink" title="事务的特性(ACID)"></a>事务的特性(ACID)</h2><p><img src="/2021/06/18/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A/4.png" alt="4"></p><ul><li><strong>原子性：</strong> 事务是数据库的逻辑工作单位，事务中包括的诸操作要么都做，要么都不做。</li><li><strong>一致性：</strong> 事务执行的结果必须是使数据库从一个一致性状态变到另一个一致性状态。</li><li><strong>隔离性：</strong> 并发访问数据库时，一个用户的事务不被其他事务所干扰，各并发事务之间数据库是独立的；</li><li><strong>持久性：</strong> 一个事务被提交之后。它对数据库中数据的改变是持久的，即使数据库发生故障也不应该对其有任何影响。</li></ul><h2 id="并发事务带来的问题"><a href="#并发事务带来的问题" class="headerlink" title="并发事务带来的问题"></a>并发事务带来的问题</h2><p><strong>脏读（<code>Dirty read</code>）:</strong> 当一个事务正在访问数据并且对数据进行了修改，而这种修改还没有提交到数据库中，这时另外一个事务也访问了这个数据，然后使用了这个数据。因为这个数据是还没有提交的数据，那么另外一个事务读到的这个数据是“脏数据”，依据“脏数据”所做的操作可能是不正确的。</p><p><strong>更新丢失（<code>Lost to modify</code>）:</strong> 指在一个事务读取一个数据时，另外一个事务也访问了该数据，那么在第一个事务中修改了这个数据后，第二个事务也修改了这个数据。这样第一个事务内的修改结果就被丢失，因此称为丢失修改。 例如：事务1读取某表中的数据A=20，事务2也读取A=20，事务1修改A=A-1，事务2也修改A=A-1，最终结果A=19，事务1的修改被丢失。</p><p><strong>不可重复读（<code>Unrepeatableread</code>）:</strong> 指在一个事务内多次读同一数据。在这个事务还没有结束时，另一个事务也访问该数据。那么，在第一个事务中的两次读数据之间，由于第二个事务的修改导致第一个事务两次读取的数据可能不太一样。这就发生了在一个事务内两次读到的数据是不一样的情况，因此称为不可重复读。</p><p><strong>幻读（<code>Phantom read</code>）:</strong> 幻读与不可重复读类似。它发生在一个事务（T1）读取了几行数据，接着另一个并发事务（T2）插入了一些数据时。在随后的查询中，第一个事务（T1）就会发现多了一些原本不存在的记录，就好像发生了幻觉一样，所以称为幻读。</p><p><strong>不可重复度和幻读区别：</strong>不可重复读的重点是修改，幻读的重点在于新增或者删除。</p><h2 id="事务的隔离级别"><a href="#事务的隔离级别" class="headerlink" title="事务的隔离级别"></a>事务的隔离级别</h2><ul><li><strong>READ-UNCOMMITTED(读取未提交)：</strong> 最低的隔离级别，允许读取尚未提交的数据变更</li><li><strong>READ-COMMITTED(读取已提交)：</strong> 允许读取并发事务已经提交的数据</li><li><strong>REPEATABLE-READ(可重复读)：</strong> 对同一字段的多次读取结果都是一致的，除非数据是被本身事务自己所修改。</li><li><strong>SERIALIZABLE(可串行化)：</strong> 最高的隔离级别，完全服从ACID的隔离级别。所有的事务依次逐个执行。</li></ul><table><thead><tr><th>隔离级别</th><th>脏读</th><th>不可重复读</th><th>幻影读</th></tr></thead><tbody><tr><td>READ-UNCOMMITTED</td><td>√</td><td>√</td><td>√</td></tr><tr><td>READ-COMMITTED <strong>(Oracle 默认)</strong></td><td>×</td><td>√</td><td>√</td></tr><tr><td>REPEATABLE-READ <strong>(MySQL默认)</strong></td><td>×</td><td>×</td><td>√</td></tr><tr><td>SERIALIZABLE</td><td>×</td><td>×</td><td>×</td></tr></tbody></table><p><strong>设置隔离级别</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SET</span> [<span class="keyword">SESSION</span>|<span class="keyword">GLOBAL</span>] <span class="keyword">TRANSACTION</span> <span class="keyword">ISOLATION</span> <span class="keyword">LEVEL</span> [<span class="keyword">READ</span> UNCOMMITTED|<span class="keyword">READ</span> COMMITTED|REPEATABLE <span class="keyword">READ</span>|<span class="keyword">SERIALIZABLE</span>]</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select @@tx_isolation;</span><br><span class="line">+<span class="comment">-----------------+</span></span><br><span class="line">| @@tx_isolation  |</span><br><span class="line">+<span class="comment">-----------------+</span></span><br><span class="line">| REPEATABLE-READ |</span><br><span class="line">+<span class="comment">-----------------+</span></span><br></pre></td></tr></table></figure><p>与 SQL 标准不同的地方在于<code>InnoDB</code> 存储引擎在 <strong>REPEATABLE-READ（可重读）</strong> 事务隔离级别下，允许应用使用 Next-Key Lock 锁算法来避免幻读的产生。这与其他数据库系统(如 SQL Server)是不同的。所以说虽然 <code>InnoDB</code> 存储引擎的默认支持的隔离级别是 <strong>REPEATABLE-READ（可重读）</strong> ，但是可以通过应用加锁读（例如 <code>select * from table for update</code> 语句）来保证不会产生幻读，而这个加锁度使用到的机制就是 Next-Key Lock 锁算法。从而达到了 SQL 标准的 <strong>SERIALIZABLE(可串行化)</strong> 隔离级别。</p><p>因为隔离级别越低，事务请求的锁越少，所以大部分数据库系统的隔离级别都是<strong>READ-COMMITTED(读取提交内容):</strong>，但是<code>InnoDB</code> 存储引擎默认使用 <strong>REPEATABLE-READ（可重读）</strong> 并不会有任何性能损失。<code>InnoDB</code> 存储引擎在 <strong>分布式事务</strong> 的情况下一般会用到<strong>SERIALIZABLE(可串行化)</strong> 隔离级别。</p><h2 id="数据库锁的分类"><a href="#数据库锁的分类" class="headerlink" title="数据库锁的分类"></a>数据库锁的分类</h2><table><thead><tr><th align="center">划分类型</th><th align="center">类别</th></tr></thead><tbody><tr><td align="center">粒度</td><td align="center">表级锁、行级锁、页级锁</td></tr><tr><td align="center">级别</td><td align="center">共享锁、排他锁</td></tr><tr><td align="center">加锁方式</td><td align="center">自动锁、显示锁</td></tr><tr><td align="center">操作</td><td align="center">DML(数据操作) 、DDL(数据定义)</td></tr><tr><td align="center">使用方式</td><td align="center">乐观锁、悲观锁</td></tr></tbody></table><h1 id="MySQL存储引擎"><a href="#MySQL存储引擎" class="headerlink" title="MySQL存储引擎"></a>MySQL存储引擎</h1><p><strong>查看 MySQL 提供的所有存储引擎</strong></p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show engines;</span><br></pre></td></tr></table></figure><img src="/2021/06/18/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A/5.png" alt="5"><p>从上图我们可以看出MySQL当前默认的存储引擎是<code>InnoDB</code>，并且只有<code>InnoDB</code>是事务性存储引擎，即只有<code>InnoDB</code>支持事务；</p><h2 id="MyISAM-和-InnoDB-的区别"><a href="#MyISAM-和-InnoDB-的区别" class="headerlink" title="MyISAM 和 InnoDB 的区别"></a><code>MyISAM</code> 和 <code>InnoDB</code> 的区别</h2><p>MySQL 5.5 之前，<code>MyISAM</code> 引擎是 MySQL 的默认存储引擎，5.5 版本之后，MySQL 引入了 <code>InnoDB</code>（事务性数据库引擎），默认的存储引擎改为 <code>InnoDB</code>。</p><table><thead><tr><th align="center">View</th><th align="left">Description</th></tr></thead><tbody><tr><td align="center">锁</td><td align="left"><code>MyISAM</code>默认表级锁，不支持行级锁; <code>InnoDB</code>默认行级锁，支持表级锁。</td></tr><tr><td align="center">事务</td><td align="left"><code>MyISAM</code> 不提供事务支持; <code>InnoDB</code> 提供事务支持，具有提交(commit)和回滚(rollback)事务的能力。</td></tr><tr><td align="center">外键</td><td align="left"><code>MyISAM</code> 不支持外键，而 <code>InnoDB</code> 支持。</td></tr><tr><td align="center">安全恢复</td><td align="left"><code>MyISAM</code> 不支持数据库异常崩溃后的安全恢复；<code>InnoDB</code>支持</td></tr><tr><td align="center">文件存储</td><td align="left"><code>InnoDB</code>存储文件有 <code>.frm</code>(定义文件)、.<code>ibd</code>(数据文件)；<code>MyISAM</code> 是 <code>.frm</code>、<code>.myd</code>(数据文件)、<code>.myi</code>(索引文件) 即<code>MyISAM</code>将数据和索引分开存储，而<code>InnoDB</code>将数据和索引绑定存储。</td></tr><tr><td align="center">索引</td><td align="left"><code>MyISAM</code> 为稀疏索引；<code>InnoDB</code>为密集索引</td></tr></tbody></table><p>🌈 拓展:</p><ul><li>MySQL <code>InnoDB</code> 引擎使用 <strong>redo log(重做日志)</strong> 保证事务的<strong>持久性</strong>，使用 <strong>undo log(回滚日志)</strong> 来保证事务的<strong>原子性</strong>。</li><li>MySQL <code>InnoDB</code> 引擎通过 <strong>锁机制</strong>、<strong>MVCC</strong> 等手段来保证事务的隔离性。</li><li>保证了事务的持久性、原子性、隔离性之后，一致性才能得到保障。</li></ul><h2 id="MyISAM-和-InnoDB-的选择"><a href="#MyISAM-和-InnoDB-的选择" class="headerlink" title="MyISAM 和 InnoDB 的选择"></a><code>MyISAM</code> 和 <code>InnoDB</code> 的选择</h2><p><code>MyISAM</code> </p><ul><li>频繁执行全表count语句，即count(*) -&gt; <code>MyISAM</code>用一个变量保存记录总数</li><li>对数据进行增删改的频率不高，查询频繁</li></ul><p><code>InnoDB</code></p><ul><li>增删改查都比较频繁</li><li>可靠性要求高、要求支持事务</li></ul><h2 id="InnoDB-存储引擎锁的三种算法"><a href="#InnoDB-存储引擎锁的三种算法" class="headerlink" title="InnoDB 存储引擎锁的三种算法"></a><code>InnoDB</code> 存储引擎锁的三种算法</h2><ul><li>Record lock：记录锁，单个行记录上的锁</li><li>Gap lock：间隙锁，锁定一个范围，不包括记录本身</li><li>Next-key lock ：record+gap临键锁，锁定一个范围，包含记录本身</li></ul><h2 id="InnoDB为什么推荐使用自增ID作为主键"><a href="#InnoDB为什么推荐使用自增ID作为主键" class="headerlink" title="InnoDB为什么推荐使用自增ID作为主键"></a><code>InnoDB</code>为什么推荐使用自增ID作为主键</h2><p>自增ID可以保证每次插入时B+树索引是从右边扩展的，可以避免B+树频繁合并和分裂。如果使用字符串主键和随机主键，会使得数据随机插入，效率比较差。</p><p><strong>参考资料</strong></p><ul><li><p><a href="https://juejin.cn/post/6844903934625054733#heading-16" target="_blank" rel="noopener">掘金 - 数据库底层设计</a></p></li><li><p><a href="https://github.com/Snailclimb/JavaGuide/blob/master/docs/database/MySQL.md" target="_blank" rel="noopener">Github - 数据库锁 </a></p></li><li><p><a href="https://github.com/Snailclimb/JavaGuide/blob/master/docs/database/MySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B4%A2%E5%BC%95.md" target="_blank" rel="noopener">Github - 数据库索引</a></p></li><li><p><a href="https://github.com/Snailclimb/JavaGuide/blob/master/docs/database/%E4%B8%80%E5%8D%83%E8%A1%8CMySQL%E5%91%BD%E4%BB%A4.md" target="_blank" rel="noopener">Github -  sql 整理</a></p></li><li><p><a href="https://blog.csdn.net/ZYC88888/article/details/81701712" target="_blank" rel="noopener">MySQL 索引</a></p></li></ul>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;数据库索引&quot;&gt;&lt;a href=&quot;#数据库索引&quot; class=&quot;headerlink&quot; title=&quot;数据库索引&quot;&gt;&lt;/a&gt;数据库索引&lt;/h1&gt;&lt;h2 id=&quot;何为索引？为什么要使用索引？&quot;&gt;&lt;a href=&quot;#何为索引？为什么要使用索引？&quot; class=&quot;headerlink&quot; title=&quot;何为索引？为什么要使用索引？&quot;&gt;&lt;/a&gt;何为索引？为什么要使用索引？&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;索引是一种用于快速查询和检索数据的数据结构。常见的索引结构有: B 树， B+树和 Hash。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;查询数据最基本的方式为全表扫描，即将整张表的数据全部或者分批次加载到内存中，&lt;strong&gt;磁盘存储的最小单位为块&lt;/strong&gt;(512Byte)，由多行数据来组成。我们在查询数据时将块加载进内存，&lt;strong&gt;然后逐个块的去轮寻&lt;/strong&gt;，找到目标数据即返回，这种查询方式是非常慢的，所以我们就需要引入一种更高效的查询机制即索引。&lt;strong&gt;索引的灵感来源于字典，类似于字典的目录&lt;/strong&gt;。&lt;/p&gt;</summary>
    
    
    
    
    <category term="MySQL" scheme="http://yoursite.com/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>HTTP的前世今生</title>
    <link href="http://yoursite.com/2021/06/14/HTTP%E7%9A%84%E5%89%8D%E4%B8%96%E4%BB%8A%E7%94%9F/"/>
    <id>http://yoursite.com/2021/06/14/HTTP%E7%9A%84%E5%89%8D%E4%B8%96%E4%BB%8A%E7%94%9F/</id>
    <published>2021-06-14T06:38:56.000Z</published>
    <updated>2021-06-15T13:26:52.015Z</updated>
    
    <content type="html"><![CDATA[<h1 id="HTTP的主要特点"><a href="#HTTP的主要特点" class="headerlink" title="HTTP的主要特点"></a>HTTP的主要特点</h1><p><strong>支持客服/服务器模式</strong>：HTTP协议工作于客户端/服务器的架构之上，浏览器作为HTTP客户端通过URL向HTTP服务端发送请求，web服务器根据接受到的请求向客户端发送响应信息；</p><p><strong>简单快速：</strong>客户端向服务器请求服务的时候，只需传送请求方法和路径。请求方法常用的有GET、HEAD、POST，每种方法规定了客户与服务器联系的类型不同。由于HTTP协议简单，使得HTTP服务器的程序规模小，因而通信速度很快。</p><p><strong>灵活</strong>：HTTP允许传输任意类型的数据对象。正在传输的类型由Content-Type加以标记;</p><a id="more"></a>  <p><strong>无连接：</strong>无连接即<strong>限制每次连接只处理一次请求</strong>，服务器处理完客户的请求并收到客户的应答之后便断开连接，采用这种方式可以节省传输时间。从HTTP 1.1 默认使用了<strong>长连接</strong>，即服务器需要等待一定的时间后才断开连接，以保证连接特性。虽然目前的技术如 Keep-Alive使用长连接优化效率，但这些都处于HTTP请求之外的，也就是说在每一个独立的HTTP请求中是无法得知当前请求的HTTP是否处于长连接的状态。我们始终认为HTTP请求在结束后连接就会关闭，这是HTTP的特性，至于下层实现是否在结束请求之后关闭连接都不会关闭这个特性。Keep-Alive可以理解为下层实现对上层是透明。</p><p><strong>无状态：</strong>HTTP协议是无状态协议，<strong>无状态是指协议对于事物处理没有记忆能力</strong>，缺少状态意味着如果后续处理需要前面的信息则必须被重传。这样可能导致每次传输的数据量增大，另一方面，在服务器不需要先前的信息时它的应答会变快。</p><h1 id="HTTP请求头部"><a href="#HTTP请求头部" class="headerlink" title="HTTP请求头部"></a>HTTP请求头部</h1><p>客户端发送一个HTTP请求到服务器的请求消息结构如下，主要由<strong>请求行、请求头部、空行、和请求正文</strong>这四个部分组成。</p><img src="/2021/06/14/HTTP%E7%9A%84%E5%89%8D%E4%B8%96%E4%BB%8A%E7%94%9F/1.png" alt="1" style="zoom:80%;"><p>请求行主要由<strong>请求方法</strong>(GET/PST..)、<strong>URL</strong>、<strong>协议版本号</strong>(1.0/1.1/2.0)三个部分组成，最后需要一个回车换行标志；</p><p>请求头部由若干个报头组成，每个报头的结构都是<strong>头部名字+ <code>：</code> + 空格 + 值</strong>这样的形式，名字与大小写无关，这些请求头部用来设置HTTP请求的一些参数；</p><p>请求正文即数据体，该数据体只在POST请求中用到，表示要上传的数据；</p><p><strong>请求正文和请求头部之间有空行</strong>，即浏览器发送一个空白行来通知服务器它已经结束了该请求头部的发送；</p><h1 id="HTTP响应结构"><a href="#HTTP响应结构" class="headerlink" title="HTTP响应结构"></a>HTTP响应结构</h1><p>服务器接收并处理客户端发送过来的请求后会返回一个HTTP的响应消息即HTTP响应报文，HTTP的响应报文如下：</p><img src="/2021/06/14/HTTP%E7%9A%84%E5%89%8D%E4%B8%96%E4%BB%8A%E7%94%9F/2.png" alt="2" style="zoom:80%;"><p>HTTP的响应报文主要由<strong>状态行、响应头部、响应正文</strong>三部分组成；</p><p>状态行主要由<strong>协议版本号、状态码、状态码描述</strong>三部分组成；</p><p>响应头部主要用于描述服务器的基本信息，以及数据的描述，由响应头字段名字以及对应的值组成；</p><h1 id="HTTP请求-响应的步骤"><a href="#HTTP请求-响应的步骤" class="headerlink" title="HTTP请求/响应的步骤"></a>HTTP请求/响应的步骤</h1><ul><li>客户端连接到Web服务器(建立TCP连接)</li><li>发送HTTP请求</li><li>服务器接受请求并返回HTTP响应</li><li>释放TCP连接</li><li>客户端浏览器解析HTML内容</li></ul><p>首先客户端连接Web服务器（一个HTTP客户端通常是浏览器），与Web服务器的HTTP端口（默认80）建立一个TCP套接字连接；然后发送HTTP请求（<strong>HTTP 协议是建立在 TCP 协议之上的应用层协议，其本质是在建立起的TCP连接中，按照HTTP协议标准发送一个索要网页的请求</strong>），即通过TCP套接字，客户端向Web服务器发送一个文本的请求报文；之后服务器接受到来自客户端的请求并返回HTTP响应，Web服务器解析该请求，定位请求资源，并将资源副本写到TCP套接字，由客户端读取；之后会释放TCP连接（若连接模式为Close，则服务器主动关闭TCP连接，客户端被动关闭连接，若连接模式为Keep-Alive，则该连接会保持一段时间，在该时间内服务器可以继续接收请求）；最后客户端就拿到了HTML相关内容并进行解析，客户端浏览器首先去解析状态行，查看表明请求是否成功的状态代码，然后解析每一个响应头，响应头告知以下为若干字节的HTML文档及文档的字符集，客户端浏览器读取响应数据HTML，并根据HTML语法对其进行格式化，最后在浏览器窗口中显示。</p><h1 id="在浏览器地址栏键入URL，按下回车后经历的流程"><a href="#在浏览器地址栏键入URL，按下回车后经历的流程" class="headerlink" title="在浏览器地址栏键入URL，按下回车后经历的流程"></a>在浏览器地址栏键入URL，按下回车后经历的流程</h1><ul><li>DNS解析</li><li>TCP连接</li><li>发送HTTP请求</li><li>服务器处理请求并返回HTTP报文</li><li>浏览器解析渲染页面</li><li>TCP连接断开</li></ul><p>首先浏览器会依据URL逐层查询DNS如期缓存，解析URL中的域名所对应的IP地址，DNS缓存从近到远，依次是浏览器缓存、系统缓存、路由器缓存、IPS服务器缓存、根域名服务器缓存、顶级域名服务器缓存，从哪个缓存找到对应的IP则直接返回，不再查询后面的缓存；找到IP地址之后，根据IP地址和对应的端口号与服务器建立TCP连接；之后浏览器会发送读取文件的HTTP请求，该请求将发送给服务器；服务器收到HTTP请求后处理请求并把对应的带有HTML文本的HTTP响应报文发回给浏览器；浏览器收到HTML并在显示窗口中去渲染（首先解析 HTML 文件构建 DOM 树，然后解析 CSS 文件构建渲染树，等到渲染树构建完成后，浏览器开始布局渲染树并将其绘制到屏幕上）；最终浏览器与服务器通过四次挥手释放TCP连接；</p><h1 id="HTTP请求方法"><a href="#HTTP请求方法" class="headerlink" title="HTTP请求方法"></a>HTTP请求方法</h1><p>HTTP1.0 定义了三种请求方法： GET, POST 和 HEAD方法。</p><p>HTTP1.1 新增了六种请求方法：OPTIONS、PUT、PATCH、DELETE、TRACE 和 CONNECT 方法。</p><table><thead><tr><th>方法</th><th>描述</th></tr></thead><tbody><tr><td>GET</td><td>请求指定的页面信息，并返回具体内容，通常只用于读取数据。</td></tr><tr><td>HEAD</td><td>类似于 GET 请求，只不过返回的响应中没有具体的内容，用于获取报头。</td></tr><tr><td>POST</td><td>向指定资源提交数据进行处理请求（例如提交表单或者上传文件）。数据被包含在请求体中。POST 请求可能会导致新的资源的建立或已有资源的更改。</td></tr><tr><td>PUT</td><td>替换指定的资源，没有的话就新增。</td></tr><tr><td>DELETE</td><td>请求服务器删除 URL 标识的资源数据。</td></tr><tr><td>CONNECT</td><td>将服务器作为代理，让服务器代替用户进行访问。</td></tr><tr><td>OPTIONS</td><td>向服务器发送该方法，会返回对指定资源所支持的 HTTP 请求方法。</td></tr><tr><td>TRACE</td><td>回显服务器收到的请求数据，即服务器返回自己收到的数据，主要用于测试和诊断。</td></tr><tr><td>PATCH</td><td>是对 PUT 方法的补充，用来对已知资源进行局部更新。</td></tr></tbody></table><h2 id="GET请求和POST请求的区别"><a href="#GET请求和POST请求的区别" class="headerlink" title="GET请求和POST请求的区别"></a>GET请求和POST请求的区别</h2><ul><li>GET将请求信息放到URL中；POST放在报文体中；</li><li>GET提交的数据大小有限制；POST提交的数据没限制；</li><li><strong>GET符合幂等性和安全性；POST不符合；</strong></li><li>GET可以被缓存；POST不行；</li></ul><p><strong>注解</strong></p><p>由于GET请求是将请求信息放到URL中的，所以对长度有限制。虽然URL本身并没有长度的限制，但是浏览器会对URL有长度有所限制；</p><p>从数据库层面看，GET请求符合幂等性和安全性。幂等性即对数据库的一次操作和多次操作获得的结果是一致的，安全性即对数据库的操作没有改变数据库中的数据。GET请求是做查询操作的，因此不会改变数据库原有的数据，大致可以认为GET请求符合幂等性和安全性。POST请求则既不幂等也不安全，因为POST请求往往是向数据库中提交数据，因此会改变数据库中的数据。同时POST请求每次获得的结果也可能不同，因为POST请求是作用到上一层的URL上的，即每一次请求都会添加一次新的资源。</p><p>GET请求可以被缓存，可以保存在浏览器的浏览记录中，以GET请求的URL能够保存为浏览器书签。这也是GET请求被广泛使用的原因。</p><h1 id="HTTP状态码"><a href="#HTTP状态码" class="headerlink" title="HTTP状态码"></a>HTTP状态码</h1><p><strong>HTTTP态码共有 5 种类型:</strong></p><table><thead><tr><th>类别</th><th>分类描述</th></tr></thead><tbody><tr><td>1xx</td><td>指示信息-&gt;表示请求已接受，继续处理</td></tr><tr><td>2xx</td><td>成功-&gt; 表示请求已被成功接收、理解、接受</td></tr><tr><td>3xx</td><td>重定向-&gt; 要完成请求必须进行更进一步的操作</td></tr><tr><td>4xx</td><td>客户端错误-&gt; 请求有语法错误或请求无法实现</td></tr><tr><td>5xx</td><td>服务器端错误-&gt; 服务器未能实现合法请求</td></tr></tbody></table><p><strong>常见的HTTP状态码</strong></p><table><thead><tr><th align="center">状态码</th><th align="center">English Name</th><th align="left">描述</th></tr></thead><tbody><tr><td align="center">100</td><td align="center">continue</td><td align="left">继续。客户端继续处理请求</td></tr><tr><td align="center">101</td><td align="center">Switching Protocol</td><td align="left">切换协议。服务器根据客户端的请求切换到更高级的协议</td></tr><tr><td align="center">200</td><td align="center">OK</td><td align="left">请求成功。请求所希望的响应头或数据体将随此响应返回</td></tr><tr><td align="center">301</td><td align="center">Moved Permanently</td><td align="left">永久移动。请求的资源已被永久地移动到新 URI，返回信息会包含新的 URI，浏览器会自动定向到新 URI</td></tr><tr><td align="center">302</td><td align="center">Found</td><td align="left">临时移动。与 301 类似。但资源只是临时被移动，客户端应继续使用原有URI</td></tr><tr><td align="center">400</td><td align="center">Bad Request</td><td align="left">客户端请求的语法错误，服务器无法理解；请求的参数有误</td></tr><tr><td align="center">401</td><td align="center">Unauthorized</td><td align="left">当前请求需要用户验证</td></tr><tr><td align="center">403</td><td align="center">Forbidden</td><td align="left">服务器已经理解请求，但是拒绝执行它</td></tr><tr><td align="center">404</td><td align="center">Not Found</td><td align="left">请求失败，请求所希望得到的资源未被在服务器上发现</td></tr><tr><td align="center">500</td><td align="center">Internal Server</td><td align="left">服务器遇到了一个未曾预料的状况，导致了它无法完成对请求的处理</td></tr><tr><td align="center">501</td><td align="center">Not Implemented</td><td align="left">服务器不支持当前请求所需要的某个功能</td></tr><tr><td align="center">502</td><td align="center">Bad Gateway</td><td align="left">作为网关或者代理工作的服务器尝试执行请求时，从远程服务器接收到无效的响应</td></tr><tr><td align="center">503</td><td align="center">Service Unavailable</td><td align="left">由于临时的服务器维护或者过载，服务器当前无法处理请求，一段时间后可能恢复正常</td></tr><tr><td align="center">504</td><td align="center">Gateway Time-out</td><td align="left">充当网关或代理的服务器，未及时从远端服务器获取请求</td></tr></tbody></table><h1 id="HTTP版本间的区别"><a href="#HTTP版本间的区别" class="headerlink" title="HTTP版本间的区别"></a>HTTP版本间的区别</h1><h2 id="HTTP-1-1-和-HTTP-1-0-的区别"><a href="#HTTP-1-1-和-HTTP-1-0-的区别" class="headerlink" title="HTTP/1.1 和 HTTP/1.0 的区别"></a>HTTP/1.1 和 HTTP/1.0 的区别</h2><p><strong>缓存处理</strong>：在 HTTP/1.0 中主要使用 header 里的 if-modified-Since, Expries 来做缓存判断的标准。而 HTTP/1.1 请求头中添加了更多与缓存相关的字段，从而支持更为灵活的缓存策略，例如 Entity-tag, If-Unmodified-Since, If-Match, If-None-Match 等可供选择的缓存头来控制缓存策略。</p><p><strong>节约带宽</strong>： 当客户端请求某个资源时，HTTP/1.0 默认将该资源相关的整个对象传送给请求方，但很多时候可能客户端并不需要对象的所有信息。而在 HTTP/1.1 的请求头中引入了 range 头域，它允许只请求部分资源，其使得开发者可以多线程请求某一资源，从而充分的利用带宽资源，实现高效并发。</p><p><strong>错误通知的管理</strong>：HTTP/1.1 在 1.0 的基础上新增了 24 个错误状态响应码，例如 414 表示客户端请求中所包含的 URL 地址太长，以至于服务器无法处理；410 表示所请求的资源已经被永久删除。</p><p><strong>Host 请求头</strong>：早期 HTTP/1.0 中认为每台服务器都绑定一个唯一的 IP 地址并提供单一的服务，请求消息中的 URL 并没有传递主机名。而随着虚拟主机的出现，一台物理服务器上可以存在多个虚拟主机，并且它们共享同一个 IP 地址。为了支持虚拟主机，HTTP/1.1 中添加了 host 请求头，请求消息和响应消息中应声明这个字段，若请求消息中缺少该字段时服务端会响应一个 404 错误状态码。</p><p><strong>长连接</strong>：HTTP/1.0 默认浏览器和服务器之间保持短暂连接，浏览器的每次请求都需要与服务器建立一个 TCP 连接，服务器完成后立即断开 TCP 连接。HTTP/1.1 默认使用的是持久连接，其支持在同一个 TCP 请求中传送多个 HTTP 请求和响应。此之前的 HTTP 版本的默认连接都是使用非持久连接，如果想要在旧版本的 HTTP 协议上维持持久连接，则需要指定 Connection 的首部字段的值为 Keep-Alive。</p><h2 id="HTTP-1-0-1-1-和-HTTP-2-0-的区别"><a href="#HTTP-1-0-1-1-和-HTTP-2-0-的区别" class="headerlink" title="HTTP/1.0/1.1 和 HTTP/2.0 的区别"></a>HTTP/1.0/1.1 和 HTTP/2.0 的区别</h2><p><strong>二进制分帧</strong>：相比于 HTTP/1.X 的文本（字符串）传送， HTTP/2.0 采用二进制传送。客户端和服务器传输数据时把数据分成帧，帧组成了数据流，流具有流 ID 标识和优先级，通过优先级以及流依赖能够一定程度上解决关键请求被阻塞的问题。<br><strong>多路复用</strong>：HTTP/2.0 支持多路复用。因为流 ID 的存在， 通过同一个 HTTP 请求可以实现多个 HTTP 请求传输，客户端和服务器可以通过流 ID 来标识究竟是哪个流从而定位到是哪个 HTTP 请求。<br><strong>头部压缩：</strong>HTTP/2.0 头部压缩。HTTP/2.0 通过 gzip 和 compress 压缩头部然后再发送，同时通信双方会维护一张头信息表，所有字段都记录在这张表中，在每次 HTTP 传输时只需要传头字段在表中的索引即可，大大减小了重传次数和数据量。<br><strong>服务器推送：</strong>HTTP/2.0 支持服务器推送。 服务器在客户端未经请求许可的情况下，可预先向客户端推送需要的内容，客户端在退出服务时可通过发送复位相关的请求来取消服务端的推送</p><h1 id="Cookie与Session"><a href="#Cookie与Session" class="headerlink" title="Cookie与Session"></a>Cookie与Session</h1><p>因为HTTP是无状态的，理论上意味着我们每次访问有登录需求的页面的时候都需要不厌其烦的输入用户名和密码，但是实际上我们并没有如此操作的原因是引入了Cookie与Session机制。Cookie与Session弥补了HTTP无状态的不足，使HTTP具有了状态性。</p><h2 id="Cookie"><a href="#Cookie" class="headerlink" title="Cookie"></a><strong>Cookie</strong></h2><p>Cookie技术是客户端的解决方案，Cookie就是由服务器发送给客户端的特殊信息，而这些信息以文本文件的形式存放在客户端，然后客户端每次向服务器发送请求的时候都会带上这些特殊信息。</p><p>当用户使用浏览器访问一个支持Cookie的网站时，用户提供一个包括用户名在内的个人信息并提交至服务器，接着服务器在向客户端发送超文本的同时也会发回这些信息。当然这些信息并不存在HTTP的响应体中，而是存在HTTP的响应头中。当用户浏览器接收到来自服务器的响应后，浏览器会将这些信息存放一个统一的位置，至此客户端再向服务器发送请求时，都会把相应的Cookie再次发送到服务器中，而这次Cookie信息则存在HTTP请求头里了。 有了Cookie这样的技术实现，服务器在接受到来自客户端浏览器的请求之后就能够分析存放在请求头中的Cookie，得到客户端特有的信息，从而动态生成与该客户端相对应的内容。</p><p><strong>Cookie的设置及发送过程如下：</strong></p><img src="/2021/06/14/HTTP%E7%9A%84%E5%89%8D%E4%B8%96%E4%BB%8A%E7%94%9F/3.png" alt="3" style="zoom: 67%;"><h2 id="Session"><a href="#Session" class="headerlink" title="Session"></a><strong>Session</strong></h2><p>Session机制是一种服务器端的机制，服务器使用了一种类似于散列表的结构来保存信息，当程序需要为某个客户端请求创建一个Session的时候，服务器首先检查这个客户端的请求里是否含有Session标识(即为session id)，如果已包含则说明以前已经为此客户端创建过Session,服务器就按照session id把session检索出来使用，若检索不到，可能新建一个。如果客户端请求不包含session id 则为客户端创建一个Session，并生成一个与此Session相关的 session id。(session id的值为一个既不会重复又不容易被找到规律的字符串)这个session id 将会在本次响应中发给客户端进行保存。</p><p><strong>Session的实现方式</strong></p><ul><li>使用Cookie来实现</li><li>使用URL回写来实现</li></ul><p>使用Cookie来实现服务器给每个Session 分配一个唯一的 JSESSIONID并通过Cookie发送给客户端，当客户端发送新的请求的时候，将在Cookie头中携带JSESSIONID,这样服务器就可以找到客户端对应的Session了。</p><img src="/2021/06/14/HTTP%E7%9A%84%E5%89%8D%E4%B8%96%E4%BB%8A%E7%94%9F/4.png" alt="4" style="zoom:80%;"><p>URL回写是指服务器在发送给浏览器页面的所有链接中都携带JSESSIONID的参数，这样客户端点击任何一个链接都会把JSESSIONID带回服务器。如果直接在浏览器输入服务器资源的URL来请求该资源，那么Session 是匹配不到的。Tomcat对Session的使用是一开始同时使用Cookie和URL回写的，如果发现客户端支持Cookie就继续使用Cookie停止使用URL回写；如果发现Cookie被禁用，就一直使用URL回写。不管是Cookie还是Session都和 JSESSIONID息息相关。</p><h2 id="Cookie与Session的区别"><a href="#Cookie与Session的区别" class="headerlink" title="Cookie与Session的区别"></a><strong>Cookie与Session的区别</strong></h2><ul><li>Cookie数据存放在客户的浏览器上，Session数据存放在服务器上</li><li>Session相对于Cookie更安全</li><li>若考虑减轻服务器的负担，应当使用Cookie</li></ul><p>Cookie的数据存放在客户的浏览器上，不安全，别人可以分析存放在本地的Cookie并进行Cookie欺骗，考虑到安全应当使用Session，但是Session会在一定时间内保存在服务器上，当访问增多会比较占用服务器的性能，考虑到减轻服务器性能方面的开销，可以使用Cookie</p><h1 id="数据加密技术"><a href="#数据加密技术" class="headerlink" title="数据加密技术"></a>数据加密技术</h1><ul><li>单向加密：哈希算法，将任意长度的信息转换成固定长度的值，算法不可逆</li><li>对称加密：加密和解密都使用同一个密钥</li><li>非对称加密：加密使用的密钥和解密使用的密钥是不同的即公钥与私钥</li><li>数字签名：证明某个消息或者文件是某人发出/认同的</li></ul><h2 id="单向加密"><a href="#单向加密" class="headerlink" title="单向加密"></a><strong>单向加密</strong></h2><p>单向加密又称不可逆加密，通常采用了哈希算法，即明文被加密成密文后，无法再解密回明文。</p><ul><li>同一明文对应同一密文</li><li>对明文进行微小修改，密文即会发生极大变化</li><li>对于不同的明文，产生的密文是定长的</li></ul><p>在加密领域，单向加密经常用于存放用户的密码，以实现即使数据库数据完全泄露被获取，也无法直接用于登录。</p><h2 id="对称加密"><a href="#对称加密" class="headerlink" title="对称加密"></a><strong>对称加密</strong></h2><p>对称加密即为明文可以使用密钥加密成为密文，也能使用同一个密钥将密文解密回明文的方式。</p><ul><li>加密解密的速度快，因此适合数据量大的时候使用</li><li>同一明文不一定都应同一密文，由加密算法决定</li></ul><p><strong>常用对称加密的场景有</strong></p><ul><li>服务端用于保存涉及用户隐私的数据，服务端自动进行数据加密</li><li>进行网络传输时，依赖其他方式进行密钥交换后，使用密钥进行对称加密解密(如SSL/TLS传输机制)</li></ul><p>常见的对称加密算法有：DES、AES、SM4(国密)，而同一加密算法又有不同的加密模式。</p><h2 id="非对称加密"><a href="#非对称加密" class="headerlink" title="非对称加密"></a><strong>非对称加密</strong></h2><p>不同于对称加密，非对称加密拥有一对密钥，分别是公钥和私钥，公钥和算法是公开的，私钥是保密的。使用其中一个密钥加密后的密文必须使用另一个密钥来解密。</p><ul><li>非对称加密算法的性能大大弱于对称加密，不建议采用非对称加密算法加密大量的用户数据</li><li>由于其加密特性，非对称加密算法加密的数据长度有限</li></ul><p><strong>使用场景：</strong></p><ul><li>客户端利用公钥给数据加密，传输给拥有私钥的服务端进行解密。由于只是私钥可以解密该数据，该密文即使在传输过程中被截获也不会有泄露的风险。</li><li>服务端对于一段明文传输的数据，先用哈希算法产生摘要信息，之后用私钥对于摘要信息进行加密产生一个数字签名。客户端收到这段明文数据和对应数字签名后，可以利用公钥来验证这段明文数据的完整性。</li></ul><p>常用的非对称加密的算法有：RSA、ECC、SM2</p><h2 id="数字签名"><a href="#数字签名" class="headerlink" title="数字签名"></a><strong>数字签名</strong></h2><p>签名就是在信息的后面加一段内容，这些内容是经过哈希后的值，可以证明信息没有被修改。哈希值一般都会加密后再和信息一起发送，以保证这个哈希值不被修改。</p><p><strong>数字签名的流程</strong></p><ul><li>创建数据密钥对</li><li>一段数据利用哈希算法获得数据摘要，再用明文私钥获得哈希值的签名</li><li>此后用户可以将这段数据和签名一同分发给任何拥有公钥的人</li></ul><h1 id="HTTPS"><a href="#HTTPS" class="headerlink" title="HTTPS"></a>HTTPS</h1><p>HTTPS为超文本传输安全协议，是一种以计算机网络安全通信为目的的传输协议，<strong>在HTTP下面加入了SSL层</strong>，从而具有了保护交换数据隐私以及完整性的功能，还提供对网站服务器身份认证的功能，即安全版的HTTP。</p><h2 id="SSL-Security-Sockets-Layer-安全套接层"><a href="#SSL-Security-Sockets-Layer-安全套接层" class="headerlink" title="SSL(Security Sockets Layer-安全套接层)"></a><strong>SSL</strong>(Security Sockets Layer-安全套接层)</h2><ul><li>为网络通信提供安全及数据完整性的一种安全协议</li><li>操作系统对外提供的API,SSL 3.0后更名为TLS</li><li>采用<strong>身份验证</strong>和<strong>数据加密</strong>保证网络通信的安全性和数据的完整性</li></ul><p><strong>”劫持“</strong> ：HTTP抓包的相关协议中，不管是GET请求还是PSOT请求,客户端与服务器之间都没有任何身份认证的过程，数据全部明文传输，“裸奔”在互联网上，所以客户端发出的请求很容易被黑客截获，如果此时黑客冒充服务器，即可以返回任何数据给客户端而不被客户端察觉。</p><h2 id="HTTPS的加密方式"><a href="#HTTPS的加密方式" class="headerlink" title="HTTPS的加密方式"></a><strong>HTTPS的加密方式</strong></h2><p>HTTPS 采用对称加密和非对称加密相结合的方式，首先使用 SSL/TLS 协议进行加密传输，为了弥补非对称加密的缺点，HTTPS 采用证书来进一步加强非对称加密的安全性，通过非对称加密，客户端和服务端协商好之后进行通信传输的对称密钥，后续的所有信息都通过该对称秘钥进行加密解密，完成整个 HTTPS 的流程。</p><h2 id="HTTPS数据传输流程"><a href="#HTTPS数据传输流程" class="headerlink" title="HTTPS数据传输流程"></a><strong>HTTPS数据传输流程</strong></h2><ul><li>浏览器将支持的加密算法信息发送给服务器</li><li>服务器选择一套浏览器支持的加密算法，以证书的形式回发浏览器</li><li>浏览器验证证书合法性，并结合证书公钥加密信息发送给服务器</li><li>服务器使用私钥解密信息，验证哈希，加密响应消息回发浏览器</li><li>浏览器解密响应消息，并对消息进行验真，之后进行加密交互数据</li></ul><h2 id="HTTP与HTTPS的区别"><a href="#HTTP与HTTPS的区别" class="headerlink" title="HTTP与HTTPS的区别"></a><strong>HTTP与HTTPS的区别</strong></h2><ul><li>HTTPS需要到CA申请证书，HTTP不需要；</li><li>HTTPS密文传输，HTTP明文传输；</li><li>连接方式不同，HTTPS默认使用443端口,HTTP使用80端口；</li><li>HTTPS = HTTP + 加密 + 认证 + 完整性保护，较HTTP安全；</li><li>HTTP 页面响应比 HTTPS 快，主要因为 HTTPS 除了 TCP 的 3 次握手，还需要经历一个 SSL 协商过程；</li></ul><h1 id="Socket"><a href="#Socket" class="headerlink" title="Socket"></a>Socket</h1><p>Socket和TCP/IP协议没有必然的联系，只对TCP/IP协议的抽象，是操作系统对外开放的接口。方便程序员更方便的使用TCP/IP协议。</p><p>Socket起源于Unix,而Unix遵从一切皆文件的哲学，Socket是一种从打开到读和写再到关闭的这种模式去实现的。服务器和客户端各自维护一个文件，在建立连接打开后，可以向自己的文件写入内容供对方使用，在通信结束时就会关闭文件。</p><h2 id="套接字的三种类型"><a href="#套接字的三种类型" class="headerlink" title="套接字的三种类型"></a><strong>套接字的三种类型</strong></h2><p><strong>流套接字（SOCK_STREAM）</strong>：流套接字基于 TCP 传输协议，主要用于提供面向连接、可靠的数据传输服务。由于 TCP 协议的特点，使用流套接字进行通信时能够保证数据无差错、无重复传送，并按顺序接收，通信双方不需要在程序中进行相应的处理。<br><strong>数据报套接字（SOCK_DGRAM）</strong>：和流套接字不同，数据报套接字基于 UDP 传输协议，对应于无连接的 UDP 服务应用。该服务并不能保证数据传输的可靠性，也无法保证对端能够顺序接收到数据。此外，通信两端不需建立长时间的连接关系，当 UDP 客户端发送一个数据给服务器后，其可以通过同一个套接字给另一个服务器发送数据。当用 UDP 套接字时，丢包等问题需要在程序中进行处理。<br><strong>原始套接字（SOCK_RAW）</strong>：由于流套接字和数据报套接字只能读取 TCP 和 UDP 协议的数据，当需要传送非传输层数据包（例如 Ping 命令时用的 ICMP 协议数据包）或者遇到操作系统无法处理的数据包时，此时就需要建立原始套接字来发送。</p><h2 id="Socket通信流程"><a href="#Socket通信流程" class="headerlink" title="Socket通信流程"></a><strong>Socket通信流程</strong></h2><img src="/2021/06/14/HTTP%E7%9A%84%E5%89%8D%E4%B8%96%E4%BB%8A%E7%94%9F/5.png" alt="5" style="zoom: 80%;"><p>服务器首先创建socket后，再为socket绑定IP地址和端口号，接着服务器的socket会开始监听端口号的请求，随时准备接收来自客户端的请求，这时候服务器的socket只是处于<code>listen()</code>状态并没有打开；</p><p>假设此时客户端创建socket，然后打开socket，并根据服务器的IP地址和端口号尝试去连接服务器的socket；</p><p>服务器的socket接收到来自客户端的socket请求后被动打开，开始接收客户端的请求直到客户端返回连接信息，这时服务器的socket进入到阻塞状态<code>accept()</code>，(处于阻塞状态需要一直等到客户端返回连接请求信息后才返回) 同时开始接收下一个客户端的连接请求；</p><p>客户端连接成功后，会向服务器发送连接状态信息，服务器接收到连接状态信息后就会将<code>accept()</code>方法返回，提示连接成功。</p><p>连接成功之后客户端就可以向socket中写入信息，服务器就能收到并读取相关信息。最后在发送完数据后，客户端就会关闭socket，紧接着服务端也需要关闭socket.</p><p><strong>参考资料</strong></p><ul><li><p><a href="https://leetcode-cn.com/leetbook/read/networks-interview-highlights/eksi0s/" target="_blank" rel="noopener">LeetCode - 应用层</a></p></li><li><p><a href="https://juejin.cn/post/6844904100035821575" target="_blank" rel="noopener">掘金 - HTTP灵魂之问</a></p></li></ul>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;HTTP的主要特点&quot;&gt;&lt;a href=&quot;#HTTP的主要特点&quot; class=&quot;headerlink&quot; title=&quot;HTTP的主要特点&quot;&gt;&lt;/a&gt;HTTP的主要特点&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;支持客服/服务器模式&lt;/strong&gt;：HTTP协议工作于客户端/服务器的架构之上，浏览器作为HTTP客户端通过URL向HTTP服务端发送请求，web服务器根据接受到的请求向客户端发送响应信息；&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;简单快速：&lt;/strong&gt;客户端向服务器请求服务的时候，只需传送请求方法和路径。请求方法常用的有GET、HEAD、POST，每种方法规定了客户与服务器联系的类型不同。由于HTTP协议简单，使得HTTP服务器的程序规模小，因而通信速度很快。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;灵活&lt;/strong&gt;：HTTP允许传输任意类型的数据对象。正在传输的类型由Content-Type加以标记;&lt;/p&gt;</summary>
    
    
    
    
    <category term="计网" scheme="http://yoursite.com/tags/%E8%AE%A1%E7%BD%91/"/>
    
  </entry>
  
  <entry>
    <title>TCP那些事</title>
    <link href="http://yoursite.com/2021/06/11/TCP%E9%82%A3%E4%BA%9B%E4%BA%8B/"/>
    <id>http://yoursite.com/2021/06/11/TCP%E9%82%A3%E4%BA%9B%E4%BA%8B/</id>
    <published>2021-06-11T03:31:14.000Z</published>
    <updated>2021-07-21T12:55:13.608Z</updated>
    
    <content type="html"><![CDATA[<p>运输层协议为运行在不同主机上的应用进程之间的逻辑通信；</p><p>TCP与UDP为两种传输层的协议，TCP(传输控制协议)为调用它的应用程序提供一个可靠的、面向连接的服务，而UDP(用户数据协议)为调用它的应用程序提供一种不可靠的、无连接的服务；</p><p><strong>TCP与UDP最基本的责任是将两个端系统间IP的交付服务扩展为运行在端系统上的两个进程之间的交付服务</strong>；</p><a id="more"></a>  <h1 id="TCP报文头"><a href="#TCP报文头" class="headerlink" title="TCP报文头"></a>TCP报文头</h1><img src="/2021/06/11/TCP%E9%82%A3%E4%BA%9B%E4%BA%8B/2.png" alt="2" style="zoom: 80%;"><p><strong>Source Port/Destination Port：</strong> TCP与UDP的数据包都是不包含IP地址信息的，那是IP层面上的事情，但是TCP与UDP都会有源端口和目的端口。两个进程在计算机内部通信可以有<strong>管道、内存共享、信号量、消息队列</strong>等方法，而两个进程如果需要通信最基本的前提是能够唯一的标识一个进程，通过这个唯一的标识来找到对应的进程。在本地的进程通信的过程中我们可以使用PID(进程号)来唯一的标识一个进程，但是PID只在本地唯一，如果把两个进程放到不同的计算机中，它们如果想要进行通信，此时PID就不够用了，解决这个问题的方法就是在传输层中引入<strong>协议端口号（端口）</strong>。<strong>IP层的IP地址可以唯一的标识一个主机</strong>，而TCP协议和端口可以唯一标识主机中的一个进程，所以我们利用<strong>IP地址 + 协议端口号</strong>这样的组合方式来唯一标识网络中的一个进程。有时也把这种唯一标识的模式称为套接字(socket)。虽然通信的重点是应用进程，但是我们只需要<strong>将传送的报文交到目的主机的某一个合适的端口</strong>，剩下的工作就交给TCP来完成就好。</p><p><strong>Sequence Number：</strong>序号是建立在字节流之上的，<strong>每一个报文段的序号即是该报文段中首字节的字节流编码</strong>。假设主机A中的一个进程想通过一条TCP连接向主机B上的一个进程发送数据流，主机A中的TCP将隐式地对数据流中的每一个字节编号，假设数据流由一个包含50000字节的文件组成，其MSS为1000字节，数据流的首字节编号为0，则TCP将为该数据流构建50个报文段，即第一个报文段的序号为0；第二个报文段的序号为100，第三个报文段的序号为200，以此类推，每个序号被填入到相应TCP报文段首部的序号字段中去。</p><p><strong>Acknowledgment Number：</strong> ack确认号是<strong>期望收到对方下一个报文段中首个字节的序号即下一个报文的序列号</strong>。假如B收到了A发送过来的报文段，其序列号是501，并且数据的长度是100字节，这表明B正确收到了来自A的<strong>序号从501-600的数据</strong>，因此B期望接着收到A的序列号为601的报文段，所以B在发送给A的确认报文段中会把ack置为601。</p><p><strong>Offset：</strong>即数据偏移，由于头部有可选字段长度不固定，因此它指出TCP报文的数据距离TCP报文的起始处有多远。</p><p><strong>Reservd：</strong>保留区域，保留给将来使用，目前必须置为 0</p><p><strong>TCP Flags:</strong> 控制位，由八个标志位组成，每个标志位代表一个控制功能 ；常见的标志位如下：</p><ul><li><strong>URG:</strong> 紧急指针标志，用于保证TCP连接不被中断，并且督促中间层设备尽快处理。URG=1-&gt;紧急指针有效；URG=0-&gt;忽略紧急指针</li><li><strong>ACK:</strong> 确认序号标志，ACK=1-&gt; 确认号有效；ACK=0 -&gt; 报文不含确认信息，忽略确认号字段 </li><li><strong>PSH:</strong> push标志 ，push=1-&gt;表示是带有push标志的数据，指示接收方在接收该报文段以后应该尽可能的将该报文段交给应用程序，而不是放到缓冲区排队。</li><li><strong>RST:</strong> 重置连接标志，用于重置由于主机崩溃或者其他原因而出现的错误连接，或者用于拒绝非法的报文段和拒绝连接请求</li><li><strong>SYN:</strong> 同步序号，用于建立连接过程，在连接请求中 SYN=1和ACK=0 表示该数据段没有使用捎带的确认域，而连接应答捎带一个确认域即SYN=1和ACK=1</li><li><strong>FIN:</strong> finish标志，用于释放连接，finish=1表示发送方已经没有数据发送了即关闭本方的数据流。</li></ul><p><strong>Window:</strong> 用来告知发送段接收端的缓存大小，以此控制发送端发送数据的速率，因而达到流量控制。</p><p><strong>Checksum:</strong> 检验和指的是奇偶校验，此校验和是对整个的TCP报文段包括TCP头 部和TCP数据以16位进行计算所得，由发送端计算和存储，并由接收端进行验证。</p><p><strong>Urgent Pointer:</strong> 只有当TCP Flags 中的URG=1时才有效，指出本报文段中的紧急数据的字节数。</p><p><strong>TCP Options:</strong> 可选项，其长度可变，定义一些其他的可选参数。</p><h1 id="UDP报文头部"><a href="#UDP报文头部" class="headerlink" title="UDP报文头部"></a>UDP报文头部</h1><img src="/2021/06/11/TCP%E9%82%A3%E4%BA%9B%E4%BA%8B/1.png" alt="1" style="zoom:80%;"><p><strong>Source Port:</strong> 源端口是一个可选字段，它表示发送方进程的端口号，接收方可以使用该字段向发送方发送信息；</p><p><strong>Destination Port:</strong> 目的端口是数据报接收方的端口号，它只在目标的 IP 地址下才有意义；</p><p><strong>Length:</strong> 长度是协议头和数据报中数据长度的总和，表示整个数据报的大小;</p><p><strong>Checksum:</strong> 校验码使用 IP 首部、UDP 首部和数据报中的数据进行计算，接收方可以通过校验码验证数据的准确性，发现传输过程中出现的问题；</p><h2 id="UDP的特点"><a href="#UDP的特点" class="headerlink" title="UDP的特点"></a>UDP的特点</h2><ul><li>面向非连接</li><li>不维护连接状态，支持同时向多个客户端传输相同的消息</li><li>数据包报头只有8个字节，相较于TCP的20个字节信息，额外开销较小</li><li>吞吐量只受限于数据生成速率、传输速率以及机器性能影响</li><li>尽最大努力交付，不保证可靠交付，不需要维持复杂的链接状态表格</li><li>面向报文，不对应用程序提交的报文信息进行拆分或者合并</li></ul><p><strong>注解</strong></p><p>UDP是一个非连接的传输协议，传输之前源端与终端不建立连接，当它想传输时就简单的抓取来自应用层数据，并尽可能快的把它扔到网络上，在发送端UDP传送的速度仅仅受应用程序生成数据的速度、计算机的能力、和传输带宽的限制。在接收端UDP把每个消息段放到队列中，应用程序每次从消息队列中读取一个消息段。</p><p>由于UDP的连接为非连接状态，每次就不需要维护连接状态、包括收发状态等，因此一台服务器可同时向多个客户机传输相同的消息。</p><p>吞吐量不受拥挤控制算法的调节，只受应用软件生成数据的速率、传输带宽 、源端与终端主机性能的限制。</p><p>UDP是面向报文的，发送端的UDP对应用程序交下来的报文在添加首部后就向下交付给IP层，既不拆分也不合并，而是保留报文的边界，因此应用程序需要选择合适的报文大小，可以看出UDP将绝大多数控制交给上层去解决。</p><h1 id="DNS为什么使用UDP"><a href="#DNS为什么使用UDP" class="headerlink" title="DNS为什么使用UDP"></a>DNS为什么使用UDP</h1><p>实际上，DNS 不仅使用了 UDP 协议，也使用了 TCP 协议 。DNS <strong>查询</strong>在刚设计时主要使用 UDP 协议进行通信，而 TCP 协议也是在 DNS 的演进和发展中被加入到规范的：</p><ol><li>DNS 在设计之初就在区域传输中引入了 TCP 协议，在查询中使用 UDP 协议；</li><li>当 DNS 超过了 512 字节的限制，我们第一次在 DNS 协议中明确了『当 DNS 查询被截断时，应该使用 TCP 协议进行重试』这一规范；</li><li>随后引入的 EDNS 机制允许我们使用 UDP 最多传输 4096 字节的数据，但是由于 MTU 的限制导致的数据分片以及丢失，使得这一特性不够可靠；</li><li>在最近的几年，我们重新规定了 DNS 应该同时支持 UDP 和 TCP 协议，TCP 协议也不再只是重试时的选择；</li></ol><h2 id="DNS-查询选择-UDP-或者-TCP-两种不同协议时的主要原因："><a href="#DNS-查询选择-UDP-或者-TCP-两种不同协议时的主要原因：" class="headerlink" title="DNS 查询选择 UDP 或者 TCP 两种不同协议时的主要原因："></a>DNS 查询选择 UDP 或者 TCP 两种不同协议时的主要原因：</h2><p><strong>UDP 协议</strong></p><ul><li>DNS 查询的数据包较小、机制简单；</li><li>UDP 协议的额外开销小、有着更好的性能表现；</li></ul><p><strong>TCP 协议</strong></p><ul><li>DNS 查询由于 DNSSEC 和 IPv6 的引入迅速膨胀，导致 DNS 响应经常超过 MTU 造成数据的分片和丢失，我们需要依靠更加可靠的 TCP 协议完成数据的传输；</li><li>随着 DNS 查询中包含的数据不断增加，TCP 协议头以及三次握手带来的额外开销比例逐渐降低，不再是占据总传输数据大小的主要部分；</li></ul><p>无论是选择 UDP 还是 TCP，最核心的矛盾就在于需要传输的数据包大小，如果数据包小到一定程度，UDP 协议绝对最佳的选择，但是当数据包逐渐增大直到突破 512 字节以及 MTU 1500 字节的限制时，我们也只能选择使用更可靠的 TCP 协议来传输 DNS 查询和相应。</p><h1 id="TCP与UDP的区别"><a href="#TCP与UDP的区别" class="headerlink" title="TCP与UDP的区别"></a>TCP与UDP的区别</h1><p><strong>面向连接与无连接：</strong>TCP面向连接而UDP面向无连接，TCP有三次握手的过程，UDP适合消息的多播发布即从单个点向多个点传输信息；</p><p><strong>可靠性</strong>：TCP比较可靠，利用握手确认和重传机制来提供可靠性保证，而UDP可能会丢失，不能保证报文段是否被接收；</p><p><strong>有序性：</strong>TCP利用序列号保证了报文段的顺序交付，到达可能无序，但TCP最终会排序，而UDP不具备有序性；</p><p><strong>传输形式：</strong>TCP面向字节流；UDP面向报文段；</p><p><strong>速度：</strong>TCP速度慢，因为要创建连接，保证消息的可靠性和有序性，相较于UDP需要做额外的很多事情；UDP则更适合对速度敏感的应用，比如在线视频媒体，电话广播、多人在线游戏等；</p><p><strong>量级：</strong>TCP属于重量级的，UDP属于轻量级的，主要体现在报文头部；</p><h1 id="TCP三次握手"><a href="#TCP三次握手" class="headerlink" title="TCP三次握手"></a>TCP三次握手</h1><p>TCP连接即：在一个应用进程与另外一个应用进程发送数据之前，这两个进程必须先”相互握手”,即它们必须相互发送某些预备的报文段，以建立确保数据传输的参数。在双方握手建立TCP连接之后，将会在两个应用之间建立一个全双工的通信，全双工的通信将会占用两个计算机之间的通信线路，直到它被一方或者双方关闭为止。</p><p>所谓三次握手(Three-way Handshake)，是指建立一个TCP连接时，需要客户端和服务器总共发送3个包。<strong>三次握手的目的是连接服务器指定端口，建立TCP连接,并同步连接双方的顺序号和确认号并交换 TCP信息。</strong>三次握手的过程如下：</p><!-- more --><img src="/2021/06/11/TCP%E9%82%A3%E4%BA%9B%E4%BA%8B/7.png" alt="4" style="zoom: 50%;"><ul><li><strong>第一次握手</strong>：建立连接时，服务器属于<code>LISTEN监听</code>状态。客户端发送<strong>SYN包</strong><code>[SYN = 1; seq = x]</code> 到服务器，并进入<code>SYN_SENT同步已发送</code>状态，等待服务器确认。</li><li><strong>第二次握手</strong>：服务器收到<strong>SYN包</strong>即客户端的连接请求后，将发送ACK确认回应，同时自己也将发送一个SYN建立连接请求，即<strong>SYN+ACK包</strong>  <code>[SYN = 1; ACK = 1; seq = y; ack = x + 1]</code>，此时服务器进入<code>SYN_RECV同步</code>已收到状态。</li><li><strong>第三次握手</strong>：客户端收到服务器的 <strong>SYN+ACK包</strong>，做为回应需要向服务器发送确认包即<strong>ACK包</strong><code>[ACK = 1; seq = x + 1; ack = y + 1]</code>，在该包发送并接收完毕后，客户端与服务器都进入<code>ESTABLISHED建立连接</code>状态，至此连接建立成功。</li></ul><p><strong>注解</strong></p><p>最开始在客户端与服务端首次进行通信，都处于<code>CLOSED</code>状态，假设客户端主动打开，服务器被动打开，那么服务器进程会首先创建<strong>传输控制块TCB</strong>，时刻准备接收其他客户进程的连接请求，此时服务器便进入<code>LISTEN监听</code>状态。</p><p>第一次握手中<code>SYN = 1</code> 为<code>TCP Flags</code> 中的同步序号标志位，表示要与服务器建立连接请求。<strong>在连接请求中 SYN=1和ACK=0 表示该数据段没有使用捎带的确认域，而连接应答捎带一个确认域即SYN=1和ACK=1</strong>，也就是说在收到对方的连接请求后如果同意连接都会向对方发送<code>ACK = 1</code> 进行确认反馈。这也就是在第二次与第三次的握手中都会有<code>ACK= 1</code>的原因。</p><p>第一次握手中的<code>seq = x</code> 是因为<code>Sequence Number</code>会初始化一个序号x，(x可以是任意的正整数值)，在第二次握手中服务器的报文中 <code>ack = x + 1</code> 即对<code>seq = x</code>的回应，表示期待下一次收到来自客户端的报文序号为 <code>x + 1</code>；之所以加1是因为<strong>前两次握手并不能传输数据，每次发包都会消耗掉一个序列号</strong>。第二次握手服务器回应客户端发送报文段同样会初始化一个 <code>Sequence Number</code>即<code>seq = y</code>。</p><h2 id="为什么需要三次握手才能建立连接？两次握手不行嘛？"><a href="#为什么需要三次握手才能建立连接？两次握手不行嘛？" class="headerlink" title="为什么需要三次握手才能建立连接？两次握手不行嘛？"></a>为什么需要三次握手才能建立连接？两次握手不行嘛？</h2><p>三次握手的主要目的是<strong>1、确认自己和对方的发送和接收都是正常的</strong>，从而保证了双方能够进行可靠通信。同时<strong>2、初始化<code>Sequence Number</code></strong>即上面的x与y。通过初始化的这个序号来保证在应用层接收到数据不会乱序，即TCP会根据这个序号来拼接数据。因此在第二次握手服务器发送给客户端初始化序号后，客户端还需要回发确认报文给服务器来告知其已经接收到并且连接正常。</p><p>如果改为了两次握手，在两次握手的设定下，服务器端在成功接受客户端的连接请求SYN后，向客户端发出ACK确定报文时，如果因为网络原因客户端没有接收到，则会一直等待服务器端的ACK报文，而服务器端则认为连接成功建立了，便开始向客户端发送数据。但是客户端因为没有收到服务器端的ACK报文，所以并不知道服务器的顺序号seq，则会认为连接未成功建立，忽略服务器发出的任何数据。如此客户端一直等待服务器端的ACK报文，而服务器端因为客户端一直没有接收数据，而不断地重复发送数据，从而造成死锁。</p><h2 id="针对TCP连接的安全问题：SYN洪泛攻击"><a href="#针对TCP连接的安全问题：SYN洪泛攻击" class="headerlink" title="针对TCP连接的安全问题：SYN洪泛攻击"></a>针对TCP连接的安全问题：SYN洪泛攻击</h2><p>SYN攻击属于DOS攻击的一种，它利用TCP协议缺陷，通过发送大量的半连接请求，耗费CPU和内存资源。SYN攻击除了能影响主机外，还可以危害路由器、防火墙等网络系统，事实上SYN攻击并不管目标是什么系统，只要这些系统打开TCP服务就可以实施。</p><p><strong>SYN攻击的原理</strong></p><p>在三次握手过程中，服务器发送SYN-ACK（确认收到客户端请求的连接）之后，收到客户端的ACK（第三个包）之前的TCP连接称为半连接(half-open connect).此时服务器处于<code>SYN_RECV（等待客户端相应）</code>状态，如果接收到客户端的ACK，则TCP连接成功，如果未接受到，则会重发请求直至成功。SYN攻击就是由’’攻击客户端” 在短时间内伪造大量不存在的IP地址，向服务器不断地发送SYN包，服务器回复确认包，并等待客户的确认，由于源地址是不存在的，服务器需要不断的重发直至超时，这些伪造的SYN包将长时间占用未连接队列，影响了正常的SYN，目标系统运行缓慢，严重者引起网络堵塞甚至系统瘫痪。</p><p><strong>防范</strong></p><p>主要有两大类，一类是通过防火墙、路由器等过滤网关防护，另一类是通过加固TCP/IP协议栈防范.但必须清楚的是，SYN攻击不能完全被阻止，我们所做的是尽可能的减轻SYN攻击的危害，除非将TCP协议重新设计。</p><ul><li>SYN Cookies：该方案原理和 HTTP Cookies 技术类似，服务端通过特定的算法将半开连接信息编码成序列号或者时间戳，用作服务端给客户端的消息编号，随 SYN-ACK 消息一同返回给连接发起方，这样在连接建立完成前服务端不保存任何信息，直到发送方发送 ACK 确认报文并且服务端成功验证编码信息后，服务端才开始分配传输资源。若请求方是攻击者，则不会向服务端会 ACK 消息，由于未成功建立连接，因此服务端并没有花费任何额外的开销。</li></ul><h2 id="如果已经建立了连接，但是客户端突然出现故障了怎么办？"><a href="#如果已经建立了连接，但是客户端突然出现故障了怎么办？" class="headerlink" title="如果已经建立了连接，但是客户端突然出现故障了怎么办？"></a>如果已经建立了连接，但是客户端突然出现故障了怎么办？</h2><p><strong>保活机制keep-alive</strong></p><ul><li>向对方发送保活探测报文如果未收到响应报文则继续发送</li><li>尝试次数达到保活探测数仍未收到响应则中断连接</li></ul><p>TCP设有保活机制，在一段时间我们称为报活时间，即<code>KeepAliveTime</code> ,在这段时间内，连接处于非活动状态，开启保活功能的一端将向对方发送一个保活的探测报文，如果发送端没有收到响应报文，那么经过一个已经提前配置好的保活时间间隔将会继续发送保活探测报文，直到发送探测报文的次数达到保活探测数，这时对方主机将会被确认为不可达，连接也将被终止。</p><h1 id="TCP四次挥手"><a href="#TCP四次挥手" class="headerlink" title="TCP四次挥手"></a>TCP四次挥手</h1><p><strong>“挥手”是为了终止连接</strong>，即断开一个TCP连接时，需要客户端和服务器总共发出4个包以确定连接的断开。TCP四次挥手的过程如下：</p><img src="/2021/06/11/TCP%E9%82%A3%E4%BA%9B%E4%BA%8B/8.png" alt="5" style="zoom: 50%;"><ul><li><strong>第一次挥手</strong>：刚开始客户端与服务器都处于<code>ESTABLISHED连接状态</code>，假设客户端主动关闭，服务器被动关闭。客户端首先发送<strong>连接释放报文</strong><code>[FIN = 1; seq =m]</code>,并停止发送数据，主动关闭TCP连接，进入<code>FIN_WAIT_1终止等待1</code>状态，等待服务器的确认。</li><li><strong>第二次挥手</strong>：服务器收到连接释放报文后即发出 <strong>确认报文</strong> <code>[ACK = 1; seq = n; ack = m + 1]</code>，并进入<code>CLOSE_WAIT关闭等待</code>状态，此时TCP处于半关闭状态，客户端到服务器的连接释放。同时客户端收到服务器的确认后进入 <code>FIN_WAIT_2终止等待2</code> 状态，并等待服务器发出的连接释放报文。</li><li><strong>第三次挥手</strong>：当服务器的数据传输完毕后，服务器发出 <strong>连接释放报文</strong> <code>[FIN = 1; ACK = 1; seq = p; ack = m + 1]</code>,并进入<code>LAST_ACK最后确认</code>状态，等待客户端的最后确认。</li><li><strong>第四次挥手</strong>：客户端在收到服务器的连接释放报文段后，做为响应发出 <strong>确认报文</strong> <code>[ACK = 1; seq = m + 1; ack = p + 1]</code>, 并进入<code>TIME_WAIT时间等待</code>状态。服务器在收到来自客户端的确认报文段后便进入到<code>CLOSED连接断开</code> 状态，此时TCP未释放掉，客户端还需要经过<strong>时间等待计时器</strong>设置的时间<code>2MSL</code>后，才进入<code>CLOSED连接断开</code>状态，至此四次挥手结束TCP连接终止。</li></ul><p><strong>注解</strong></p><p>第一次挥手的连接释放报文 <code>[FIN = 1; seq =m]</code>,其中<code>FIN = 1</code>表示TCP Flags 中的<code>finish=1</code>表示发送方已经没有数据发送了即关闭本方的数据流，<code>seq = m</code> 其中m的值实际为<code>ESTABLISHED连接状态</code>下，<strong>客户端向服务器发送的最后一个数据报中最后一个数据的序号加1</strong>，而第二次挥手的确认报文中<code>seq = n</code>，n的值也同样是<code>ESTABLISHED连接状态</code>下服务器向客户端发送的最后一个数据报中最后一个数据的序号加1。TCP规定即使FIN报文段不携带任何数据，也要消耗掉一个序号。</p><p>在服务器处于<code>CLOSE_WAIT关闭等待</code>状态时，TCP服务器将通知高层的应用进程客户端要释放与服务器的连接了，这时候会处于半关闭状态，即客户端已经没有要发送 的数据了，但是服务器要发送数据客户端还是可以接收的，并且该状态将持续一段时间。</p><p>第三次挥手的连接释放报文 <code>[FIN = 1; ACK = 1; seq = p; ack = m + 1]</code>中，<code>seq = p</code>的p值表示在服务器处于<code>CLOSE_WAIT关闭等待</code>状态时向客户端发送的最后一个数据报中的最后一个数据的序号加1。</p><p>第四次挥手后客户端进入到<code>TIME_WAIT时间等待</code>状态，此时TCP连接还没有释放，必须经过<code>2*MSL</code>时间后，客户端撤销相应的TCB（保护程序）后，才能进入<code>CLOSED连接断开</code>状态。<code>MSL</code>即最长报文寿命，<code>RFC793</code>定义了<code>MSL</code>的值为2min，而Linux设置成了 30s，服务器在收到客户端的确认号后便立即进入<code>CLOSED连接断开</code>状态。可以看出，服务器结束TCP连接的时间要比客户端早一些。</p><h2 id="为什么要四次挥手？"><a href="#为什么要四次挥手？" class="headerlink" title="为什么要四次挥手？"></a>为什么要四次挥手？</h2><p>因为TCP是<strong>全双工</strong>的，所以在释放TCP连接时发送方和接收方都需要FIN报文和ACK报文， 当主动方在数据传送结束后发出连接释放的通知，由于被动方可能还有必要的数据要处理，所以会先返回 ACK 确认收到报文。当被动方也没有数据再发送的时候，则发出连接释放通知，对方确认后才完全关闭TCP连接。</p><h2 id="TIME-WAIT-为什么是-2MSL"><a href="#TIME-WAIT-为什么是-2MSL" class="headerlink" title="TIME_WAIT 为什么是 2MSL"></a>TIME_WAIT 为什么是 2MSL</h2><ul><li>确保有足够的时间让对方收到ACK包</li><li>避免新旧连接混淆</li></ul><p><code>TIME_WAIT时间等待</code>状态是用来确保有足够的时间让对端收到ACK包。如果被动关闭的那一方(服务器)没有收到ACK，就会触发被动端重发FIN报文。假如客户端发送完了ACK包就立即断开，当最后一条报文发出后丢失了，那么服务器端就不会接收到这一报文，每隔一段时间，服务器端会再次发出FIN报文，此时如果客户端已经断开了，那么就无法响应服务器的二次请求，这样服务器会继续发出FIN报文，客户端就会用 RST 包来响应服务端，这将会使得对方认为是有错误发生，因此不会正常关闭连接。所以需要设置一个时间段，如果在这个时间段内接收到了服务器端的再次请求，则代表客户端发出的ACK报文没有接收成功。反之，则代表服务器端成功接收响应报文，客户端比才进入<code>CLOSED连接断开</code>状态，此次连接成功关闭。之所以是<code>2*MSL</code> 是<strong>客户端发出ACK报文到服务器端的最大时间</strong> + <strong>服务器没有接收到ACK报文再次回发FIN的最大时间</strong> 刚好等于<code>2*MSL</code>。</p><p>同时为了避免新旧连接混淆，如果客户端在发出ACK报文段后就进入<code>CLOSED连接断开</code>状态，此时服务端相应的端口并没有关闭，若客户端在相同的端口立即建立新的连接，则有可能接收到上一次连接中残留的数据包，可能会导致不可预料的异常出现。</p><h2 id="服务器出现大量TIME-WAIT-状态会导致什么问题？如何解决？"><a href="#服务器出现大量TIME-WAIT-状态会导致什么问题？如何解决？" class="headerlink" title="服务器出现大量TIME_WAIT 状态会导致什么问题？如何解决？"></a>服务器出现大量TIME_WAIT 状态会导致什么问题？如何解决？</h2><p><strong>大量连接处于TIME_WAIT的原因</strong></p><p>我们考虑高并发短连接的业务场景，在高并发短连接的 TCP 服务器上，<strong>当服务器处理完请求后主动请求关闭连接</strong>，这样服务器上会有大量的连接处于 TIME_WAIT 状态，服务器维护每一个连接需要一个 socket，也就是每个连接会占用一个文件描述符，而文件描述符的使用是有上限的，如果持续高并发，会导致一些正常的 连接失败。</p><p>无论是客户端还是服务器主动关闭连接，从本质上来说，在高并发场景下主要关心的就是服务端的资源占用问题，而这也是采用 TCP 传输协议必须要面对的问题，其问题解决的出发点也是如何处理好服务质量和资源消耗之间的关系。</p><p><strong>解决方案</strong></p><p>服务器可以设置 SO_REUSEADDR 套接字选项来通知内核，如果端口被占用，但 TCP 连接位于 TIME_WAIT 状态时可以<strong>重用端口</strong>。如果你的服务器程序停止后想立即重启，而新的套接字依旧希望使用同一端口，此时 SO_REUSEADDR 选项就可以避免 TIME-WAIT 状态。也可以采用长连接的方式减少 TCP 的连接与断开，在长连接的业务中往往不需要考虑 TIME-WAIT 状态，但其实在长连接的业务中并发量一般不会太高。</p><h2 id="服务器出现大量CLOSE-WAIT状态的原因？-如何解决？"><a href="#服务器出现大量CLOSE-WAIT状态的原因？-如何解决？" class="headerlink" title="服务器出现大量CLOSE_WAIT状态的原因？ 如何解决？"></a>服务器出现大量CLOSE_WAIT状态的原因？ 如何解决？</h2><ul><li><p>客户端关闭socket连接，服务器忙于读写没有及时关闭连接</p></li><li><p>检查代码，特别是释放资源的代码；检查配置，特别是处理请求的线程配置</p></li></ul><p>在客户端发出连接释放报文之后并没有及时的收到来自服务器的ACK确认，即服务器没有检测到或者忘记要关闭连接，于是资源一直被服务器占用着，出现这种情况通常是程序中有bug，通常是某些连接没有及时释放导致的，或者某些配置如线程池中的线程数配置不合理，此时需要结合实际的业务去排查。</p><h1 id="TCP的快速打开-TFO"><a href="#TCP的快速打开-TFO" class="headerlink" title="TCP的快速打开(TFO)"></a>TCP的快速打开(TFO)</h1><p>TCP Fast Open是对TCP的一种简化握手手续的拓展，用于提高两端点间连接的打开速度，在TCP的三次握手过程中就传输实际有用的数据，以此来优化三次握手提高效率。</p><p><strong>请求Fast Open Cookie</strong></p><ul><li>首先客户端发送SYN给服务端，该数据包包含Fast Open选项，且该选项的Cookie为空，这表明客户端请求Fast Open Cookie；</li><li>支持TCP Fast Open的服务器生成Cookie，并将其置于SYN-ACK数据包中的Fast Open选项以发回客户端；</li><li>客户端收到SYN-ACK后，缓存Fast Open选项中的Cookie</li></ul><p><strong>实现TCP Fast Open</strong></p><ul><li>客户端发送Cookie+SYN+HTTP请求，该数据包包含数据以及此前记录的Cookie；</li><li>如果Cookie有效，服务器将在SYN-ACK数据包中对SYN和数据进行确认，服务器随后将数据递送至相应的应用程序，并返回HTTP响应，否则服务器将丢弃SYN数据包中包含的数据，且其随后发出的SYN-ACK数据包将仅确认SYN的对应序列号；</li><li>客户端回发ACK确认</li></ul><p><strong>注解</strong></p><p>TFO 的优势并不在与首轮三次握手，而在于后面的握手，在拿到客户端的 Cookie 并验证通过以后，可以<strong>直接返回 HTTP 响应</strong>，充分利用了1 个<strong>RTT</strong>(Round-Trip Time，往返时延)的时间<strong>提前进行数据传输</strong>。</p><h1 id="TCP定时器"><a href="#TCP定时器" class="headerlink" title="TCP定时器"></a>TCP定时器</h1><p>TCP中有七种计时器</p><p><strong>建立连接定时器</strong>：该定时器是在建立 TCP 连接的时候使用的，在 TCP 三次握手的过程中，发送方发送 SYN 时，会启动一个定时器（默认为 3 秒），若 SYN 包丢失了，那么 3 秒以后会重新发送 SYN 包，直到达到重传次数。</p><p><strong>重传定时器</strong>：该计时器主要用于 TCP 超时重传机制中，当TCP 发送报文段时，就会创建特定报文的重传计时器，并可能出现两种情况：</p><ul><li>若在计时器截止之前发送方收到了接收方的 ACK 报文，则撤销该计时器；</li><li>若计时器截止时间内并没有收到接收方的 ACK 报文，则发送方重传报文，并将计时器复位；</li></ul><p><strong>坚持计时器</strong>：我们知道 TCP 通过让接受方指明希望从发送方接收的数据字节数（窗口大小）来进行流量控制，当接收端的接收窗口满时，接收端会告诉发送端此时窗口已满，请停止发送数据。此时发送端和接收端的窗口大小均为0，直到窗口变为非0时，接收端将发送一个 确认 ACK 告诉发送端可以再次发送数据，但是该报文有可能在传输时丢失。若该 ACK 报文丢失，则双方可能会一直等待下去，为了避免这种死锁情况的发生，发送方使用一个坚持定时器来周期性地向接收方发送探测报文段，以查看接收方窗口是否变大。</p><p><strong>延迟应答计时器</strong>：延迟应答也被称为捎带 ACK，这个定时器是在延迟应答的时候使用的，为了提高网络传输的效率，当服务器接收到客户端的数据后，不是立即回 ACK 给客户端，而是等一段时间，这样如果服务端有数据需要发送给客户端的话，就可以把数据和 ACK 一起发送给客户端了。</p><p><strong>保活定时器</strong>：该定时器是在建立 TCP 连接时指定 SO_KEEPLIVE 时才会生效，当发送方和接收方长时间没有进行数据交互时，该定时器可以用于确定对端是否还活着。</p><p><strong>FIN_WAIT_2 定时器</strong>：当主动请求关闭的一方发送 FIN 报文给接收端并且收到其对 FIN 的确认 ACK后进入 FIN_WAIT_2状态。如果这个时候因为网络突然断掉、被动关闭的一端宕机等原因，导致请求方没有收到接收方发来的 FIN，主动关闭的一方会一直等待。该定时器的作用就是为了避免这种情况的发生。当该定时器超时的时候，请求关闭方将不再等待，直接释放连接。</p><p><strong>TIME_WAIT 定时器</strong>：我们知道在 TCP 四次挥手中，发送方在最后一次挥手之后会进入 TIME_WAIT 状态，不直接进入 CLOSE 状态的主要原因是被动关闭方万一在超时时间内没有收到最后一个 ACK，则会重发最后的 FIN，2 MSL（报文段最大生存时间）等待时间保证了重发的 FIN 会被主动关闭的一段收到且重新发送最后一个 ACK 。还有一个原因是在这 2 MSL 的时间段内任何迟到的报文段会被接收方丢弃，从而防止老的 TCP 连接的包在新的 TCP 连接里面出现。</p><h1 id="TCP超时重传"><a href="#TCP超时重传" class="headerlink" title="TCP超时重传"></a>TCP超时重传</h1><p>发送方在发送一次数据后就开启一个定时器，在一定时间内如果没有得到发送数据包的 ACK 报文，那么就重新发送数据，在达到一定次数还没有成功的话就放弃重传并发送一个复位信号。</p><p><strong>RTT与RTO</strong></p><p>RTT：发送一个数据包到收到对应的ACK，所花费的时间</p><p>RTO：重传时间间隔，TCP在发送一个数据包之后会启动一个重传定时器，RTO即为这个定时器的重传时间。</p><p>由于RTO是本次发送当前数据包所预估的超时时间，所以RTO需要一个好的算法来统计，以更好的预测本次的超时时间，RTO不是固定写死的配置，而是经过RTT计算出来的。有了RTT才能计算RTO。基于RTO才有了<strong>确认重传机制</strong>，才能支撑起TCP的滑动窗口。</p><h1 id="TCP流量控制"><a href="#TCP流量控制" class="headerlink" title="TCP流量控制"></a>TCP流量控制</h1><p> 管理<strong>点对点</strong>的数据传输速率，防止<strong>快发送方</strong>压倒<strong>慢接收方</strong></p><p>TCP 中利用可变长的滑动窗口机制实现对发送方的流量控制。对于发送端和接收端而言，TCP 需要把发送的数据放到<strong>发送缓存区</strong>, 将接收的数据放到<strong>接收缓存区</strong>。TCP报文头中的 <strong>Window</strong> 用于接收方告诉发送方自己还有多少缓冲区可以接收数据。发送方根据接收方的处理能力来发送数据，不会导致接收方接收不过来，如果对方的接收缓存区满了，就不能再继续发送了，这便是流量控制。</p><h2 id="TCP滑动窗口"><a href="#TCP滑动窗口" class="headerlink" title="TCP滑动窗口"></a>TCP滑动窗口</h2><p><strong>TCP使用滑动窗口做流量控制和乱序重排</strong></p><ul><li>提供TCP的可靠性</li><li>提供TCP的流量控制</li></ul><p>TCP将数据分割成段进行发送，出于效率和传输速度的考虑，我们不可能一段一段的去发送，等到上一报文段被接收到并回发确认后再发送下一段，这样效率是非常低的。我们要想实现对数据的批量转发，TCP必须要解决可靠传输和包乱序问题，所以TCP需要了解网络中实际的数据处理带宽或数据处理速度，这样才不会引起网络拥塞而丢包。</p><h2 id="滑动窗口数据的计算过程"><a href="#滑动窗口数据的计算过程" class="headerlink" title="滑动窗口数据的计算过程"></a><strong>滑动窗口数据的计算过程</strong></h2><img src="/2021/06/11/TCP%E9%82%A3%E4%BA%9B%E4%BA%8B/3.png" alt="3" style="zoom: 67%;"><p><strong>相关参数</strong></p><p><strong><code>LastByteAcked</code>:</strong> 指向收到的连续最大的ACK的位置，即从左端算起连续已经被接收端的程序收到并发送ACK回值确认的<code>seq</code>；</p><p><strong><code>LastByteSent</code>:</strong> 指向已经发送的最后一个字节的位置，该位置为已经发送但是还没有收到来自接收端的ACK回值确认；</p><p><strong><code>LastByteWritten</code>:</strong> 指向上层应用已写完的最后一个字节的位置，即发送端已经准备好的需要发送的最新的数据段；</p><p><strong><code>LastByteRead</code>:</strong> 指向接收端上层应用已经读完的最后一个字节的位置，即已经收到处理并做ACK回值确认的最后一个字节处；</p><p><strong><code>NextByteExpected</code>:</strong> 指向已经收到的连续最大的<code>seq</code> 位置，即已经收到但没有做回值确认；</p><p><strong><code>LastByteRcvd</code>:</strong> 指向已收到的最后一个字节的位置；与<strong><code>NextByteExpected</code></strong> 间的空缺是因为一些<code>seq</code>因为差错而没有准确到达；</p><p><strong><code>MaxRcvBuffer</code>:</strong> 接收方能够接收的最大数据量 即接收方的缓存区大小</p><p><strong><code>AdvertisedWindow</code>: 接收方缓冲区还能处理的数据量，该值即为TCP报文头中的 <code>Window</code> 中所返回的值；</strong></p><p><strong><code>EffectiveWindow</code>: 发送方窗口内还允许发送的数据的大小，即除去已发送没确认的还能发送的数据大小；</strong></p><p><strong>相关公式</strong></p><ul><li><code>AdvertisedWindow</code>  = <code>MaxRcvBuffer</code> - (<code>LastByteRcvd</code> - <code>LastByteRead</code>)</li><li><code>EffectiveWindow</code> = <code>AdvertisedWindow</code> - (<code>LastByteSent</code> - <code>LastByteAcked</code>)</li></ul><p><strong>注解</strong></p><p><code>LastByteRcvd</code> - <code>LastByteRead</code>表示接收端缓存区已经接受到的数据或者 <strong>为还没有接受到的数据预留出来的一些空间</strong>(如空缺处)，当前这些空间以及该占据了一些缓存，我们用接收方能够允许的最大缓存数减去已占据的缓存就得了接收方还能够接收的数据量。</p><p><code>LastByteSent</code> - <code>LastByteAcked</code> 表示发送端已经发送出去的数据段，这些数据段很可能已经到达接收方或者还在传输的过程中，所以我们要保证<code>LastByteSent</code> - <code>LastByteAcked</code> &lt;= <code>AdvertisedWindow</code> 即 <strong>已发送且待确认的数据量要小于接收方的<code>Window</code>大小</strong>。自然发送方窗口还可以发送的数据量的大小 <code>EffectiveWindow</code> 即为它们的差值。<code>AdvertisedWindow</code> - (<code>LastByteSent</code> - <code>LastByteAcked</code>)；</p><h2 id="TCP滑动窗口的基本原理"><a href="#TCP滑动窗口的基本原理" class="headerlink" title="TCP滑动窗口的基本原理"></a><strong>TCP滑动窗口的基本原理</strong></h2><p>TCP 滑动窗口分为两种: <strong>发送窗口</strong>和<strong>接收窗口</strong>。</p><p><strong>TCP会话的发送窗口</strong></p><img src="/2021/06/11/TCP%E9%82%A3%E4%BA%9B%E4%BA%8B/4.png" alt="4" style="zoom:80%;"><p>对于TCP会话的发送方，任何时候在其发送缓存区中的数据都可以分为以下四种：</p><ul><li><code>Sent and Acknowledged</code>:已经发送并且得到端的回应的；</li><li><code>Sent BUT NOT Yet Acknowledged</code>:已经发送但还没有接收到端的回应；</li><li><code>Not Sent Recipient Ready to Receive</code>:未发送但对端允许发送；</li><li><code>Not Sent Recipient NOT Ready to Receive</code>:未发送但是达到了<code>Window</code>的大小，对端不允许发送的数据；</li></ul><p>发送窗口：<code>Sent BUT NOT Yet Acknowledged</code> + <code>Not Sent Recipient Ready to Receive</code></p><p><strong>TCP会话的接收窗口</strong></p><img src="/2021/06/11/TCP%E9%82%A3%E4%BA%9B%E4%BA%8B/5.png" alt="5" style="zoom:80%;"><p>对于TCP的接收方来讲，在任一时刻它的接收缓存区中数据会存在三种状态：</p><p><code>Received and Acknowledged</code>:已接收并且已发送回值的状态；</p><p><code>Not Yet Received,Transmitter Permitted To Send</code>:未接收但是可以接收(准备接收)；</p><p><code>Not Yet Received,Transmitter May Not Sent</code>: 未接收但是不能接收(达到了窗口的阈值)；</p><p>接收窗口：由于ACK由TCP栈回复，默认没有应用延迟的，不存在已接收但未回复ACK的状态。其中<code>Not Yet Received,Transmitter Permitted To Send</code>未接收并且准备接收的部分为接收方的接收窗口。</p><p><strong>原理总结</strong></p><p>TCP最基本的传输可靠性来源于 <strong>确认重传机制</strong>，TCP滑动窗口的可靠性也是建立在确认重传的基础上的。发送窗口只有收到了接收方对于本段发送窗口内字节的ACK确认才会移动发送窗口的左边界，接收方只有在前面所有数据段都确认的情况下才会移动左边界。当在前面还有字节未接收但收到后面字节的情况下(即出现了空位)，窗口也不会移动并不会对后续字节进行确认，以此确保发送端会对这些数据进行重传。同时滑动窗口的大小可以根据一定的策略动态的调整，<strong>应用会根据自身处理能力的变化通过对本端TCP接收窗口的大小的控制，来实现对发送端进行流量控制</strong>。</p><h2 id="如果接收方滑动窗口满了，发送方怎么办？"><a href="#如果接收方滑动窗口满了，发送方怎么办？" class="headerlink" title="如果接收方滑动窗口满了，发送方怎么办？"></a>如果接收方滑动窗口满了，发送方怎么办？</h2><p>基于 TCP 流量控制中的滑动窗口协议，我们知道接收方返回给发送方的 ACK 包中会包含自己的接收窗口大小，若接收窗口已满，此时接收方返回给发送方的接收窗口大小为 0，此时发送方会等待接收方发送的窗口大小直到变为非 0 为止，然而，接收方回应的 ACK 包是存在丢失的可能的，为了防止双方一直等待而出现死锁情况，此时就需要坚持计时器来辅助发送方周期性地向接收方查询，以便发现窗口是否变大，当发现窗口大小变为非零时，发送方便继续发送数据。</p><h1 id="TCP拥塞控制"><a href="#TCP拥塞控制" class="headerlink" title="TCP拥塞控制"></a>TCP拥塞控制</h1><p><strong>网络拥塞</strong>: 太多的源端口想以过高的速率发送数据，导致<strong>网络</strong>来不及处理，网络性能变差。如路由器缓存溢出，导致丢包等现象。若出现拥塞而不进行控制，整个网络的吞吐量将随输入负荷的增大而下降。</p><p><strong>判断网络拥塞的依据</strong> : 没有按时收到应当到达的确认报文，即发生了重传。</p><p><strong>拥塞崩溃</strong> : “ 拥塞崩溃 ” 是为何要 拥塞控制 或者 限制有效交流 的原因。拥塞崩溃通常发生在 进入网络的通讯 超出 离开网络的带宽 这样的网络瓶颈下。本地局域网和广域网之间的连接点是常见的瓶颈。</p><h2 id="拥塞控制"><a href="#拥塞控制" class="headerlink" title="拥塞控制"></a><strong>拥塞控制</strong></h2><p>调解通讯网络的通讯入口，为了避免由超额认购导致的拥塞崩塌；</p><p>控制发送者发送数据进入<strong>网络</strong>的速率，使数据流保持在引发网络崩溃的水平之下；</p><h2 id="TCP-流量控制-VS-TCP-拥塞控制"><a href="#TCP-流量控制-VS-TCP-拥塞控制" class="headerlink" title="TCP 流量控制 VS TCP 拥塞控制"></a>TCP 流量控制 VS TCP 拥塞控制</h2><p>拥塞控制 防止发送者发送太快太多使<strong>网络</strong>无法应对，关注的是两节点之间的<strong>连接</strong></p><p>流量控制 防止发送者发送太快太多使<strong>接收者</strong>无法应对，关注的是另一个<strong>节点</strong></p><h2 id="拥塞控制算法"><a href="#拥塞控制算法" class="headerlink" title="拥塞控制算法"></a><strong>拥塞控制算法</strong></h2><ul><li><code>slow-start</code> 慢开始</li><li><code>congestion avoidance</code>拥塞避免</li><li><code>fast retransmit</code>快重传</li><li><code>fast recovery</code> 快恢复</li></ul><p><strong>相关概念</strong></p><ul><li><code>cwnd</code>:拥塞窗口，其值取决于网络的拥塞程度，动态变化；</li><li><code>rwnd</code>: 接收窗口，接收端的流量控制；</li><li><code>swnd</code>: 发送窗口-&gt; <code>swnd</code> = min[<code>rwnd</code>, <code>cwnd</code>];</li><li><code>ssthresh</code>: 慢开始门限状态变量；</li></ul><h3 id="慢启动-cwnd-lt-ssthresh"><a href="#慢启动-cwnd-lt-ssthresh" class="headerlink" title="慢启动 (cwnd &lt; ssthresh)"></a>慢启动 (<code>cwnd</code> &lt; <code>ssthresh</code>)</h3><p>刚开始进入传输数据的时候，你是不知道现在的网路到底是稳定还是拥堵的，如果做的太激进，发包太急，那么疯狂丢包，造成雪崩式的网络灾难。拥塞控制首先就是要采用一种保守的慢启动算法来慢慢地适应整个网路。</p><ol><li>三次握手后，双发宣告自己的接收窗口<code>rwnd</code>大小；</li><li>初始化 拥塞窗口<code>cwnd</code> 大小，一般为一个<code>MSS</code>,初始化 <code>ssthresh</code>慢启动门限 ，大多数TCP实现中 <code>ssthresh</code> = 65536Byte;</li><li><code>cwnd</code> 呈指数增长，当收到ACK确认后 拥塞窗口就翻倍；</li><li>当<code>cwnd</code> &gt;= <code>ssthresh</code> 时，切换为拥塞避免算法；</li></ol><h3 id="拥塞避免-cwnd-gt-ssthresh"><a href="#拥塞避免-cwnd-gt-ssthresh" class="headerlink" title="拥塞避免  (cwnd &gt;ssthresh)"></a>拥塞避免  (<code>cwnd</code> &gt;<code>ssthresh</code>)</h3><p>当<code>cwnd</code>到达了慢启动阈值，就不能无止境的翻倍下去了，否则迟早要出事的。这时候就需要拥塞避免算法来收着涨了。</p><ol><li>线性增长，每个<code>RTT</code> ，<code>cwnd</code> 增加1*<code>MSS</code></li><li>只要不出现ACK异常就继续上述操作</li></ol><p><strong>问题引入：前面两个机制都是在没有检测到拥塞的情况下，那么当出现拥赛,<code>cwnd</code> 该如何调整呢？</strong></p><ol><li>重传计时器超时间 Timeout ，判断网络出现了拥塞；</li><li>将<code>ssthresh</code>的值更新为发生拥塞时的 <code>cwnd</code> 的一半</li><li>拥塞窗口 <code>cwnd</code> 重置成  1 <code>MSS</code></li><li>整完后重新进行慢开始算法</li><li>当  <code>cwnd</code>的值又增加到<code>ssthresh</code>时,再次更新到 拥塞避免算法</li></ol><p>上述两种算法为1988年提出的TCP Tahoe版本，但是有时个别报文段会在网络中丢失，但是实际网络并未发生拥塞，这将导致发送发超时重传，并误以为网络发生了拥塞，所以发送方错误地启动了慢开始算法，并把拥塞窗口重置为最小值 1，因而降低了传输效率。所以为了优化<strong>由于错误判断拥塞而导致的效率低下的问题</strong>，1990年又增加了两种算法，即TCP Reno版本 快重传和快恢复的。</p><p>TCP的拥塞控制流程如下：</p><img src="/2021/06/11/TCP%E9%82%A3%E4%BA%9B%E4%BA%8B/6.png" alt="6" style="zoom:80%;"><h3 id="快重传"><a href="#快重传" class="headerlink" title="快重传"></a>快重传</h3><ol><li>要求接收方不要等待自己发送数据时才进行<strong>捎带确认</strong>，而是要立即发送确认；</li><li>即使收到失序的报文段也要立即发出对已收到报文段的<strong>重复确认</strong>；</li><li>当发送方一旦<strong>收到3个连续的重复确认</strong>，就将相应报文段立即重传，而不是等该报文段的重传计时器超时再重传。</li></ol><h3 id="快恢复"><a href="#快恢复" class="headerlink" title="快恢复"></a>快恢复</h3><ol><li>收到了3个连续的重复确认后，知道只是出现了丢失个别报文段并不是出现网络拥塞；</li><li>并不启动慢开始算法，而是执行快速恢复算法；</li><li>将 <code>ssthresh</code> 与 <code>cwnd</code> 都调整为当前窗口<code>cwnd</code>的一半 -&gt; <code>ssthresh</code> = <code>cwnd</code> / <code>2</code>； <code>cwnd</code> = <code>cwnd</code> / 2;</li><li>也有快速实现是把拥塞窗口 <code>cwnd</code> 的值再增大些，调整为 <code>cwnd</code> = <code>ssthresh</code> + 3</li><li>接着执行拥塞避免算法，线性增大 <code>cwnd</code></li></ol><p><strong>注解</strong></p><p><code>cwnd</code> = <code>ssthresh</code> + 3 =&gt; 既然发送方收到了3个连续的重复确认，就表明3个数据已经离开了网络，这3个报文段不再消耗网络资源而是停留在接收方的接收缓冲区中，可见现在网络中不再是堆积了报文段，反而是减少了3个报文段，因此可以适当把拥塞窗口扩大些。</p><p>快速恢复和拥塞避免的主要区别是在遇到报文丢失的场景时，拥塞避免会直接将<code>cwnd</code>置为1，而快速恢复则是先执行快速重传，然后将<code>cwnd</code>减半。</p><p><strong>参考资料</strong></p><ul><li>计算机网络自顶向下方法</li><li><a href="https://leetcode-cn.com/leetbook/read/networks-interview-highlights/ek40dd/" target="_blank" rel="noopener">LeetCode-传输层</a></li><li><a href="https://www.bilibili.com/video/BV1FE411C7dk?from=search&seid=5749281866247807566" target="_blank" rel="noopener">bilibili-TCP滑动窗口动态演示视频</a></li><li><a href="https://www.bilibili.com/video/BV1L4411a7RN?from=search&seid=1102706201373675068" target="_blank" rel="noopener">bilibili-TCP的拥塞控制讲解</a></li><li><a href="https://draveness.me/whys-the-design-udp-minimum-header/" target="_blank" rel="noopener">draveness-为什么 UDP 头只有 8 个字节</a></li><li><a href="https://draveness.me/whys-the-design-dns-udp-tcp/" target="_blank" rel="noopener">draveness-为什么 DNS 使用 UDP 协议</a></li><li><a href="https://juejin.cn/post/6844904070889603085" target="_blank" rel="noopener">掘金-TCP灵魂之问</a></li><li><a href="https://juejin.cn/post/6844904005315854343" target="_blank" rel="noopener">掘金-三次握手和四次挥手以及TCP标志位的详细介绍</a></li><li><a href="https://blog.csdn.net/h2604396739/article/details/85238286?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-6.channel_param&depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-6.channel_param" target="_blank" rel="noopener">csdn-慢启动、拥塞避免、快速重传、快速恢复</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;运输层协议为运行在不同主机上的应用进程之间的逻辑通信；&lt;/p&gt;
&lt;p&gt;TCP与UDP为两种传输层的协议，TCP(传输控制协议)为调用它的应用程序提供一个可靠的、面向连接的服务，而UDP(用户数据协议)为调用它的应用程序提供一种不可靠的、无连接的服务；&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;TCP与UDP最基本的责任是将两个端系统间IP的交付服务扩展为运行在端系统上的两个进程之间的交付服务&lt;/strong&gt;；&lt;/p&gt;</summary>
    
    
    
    
    <category term="计网" scheme="http://yoursite.com/tags/%E8%AE%A1%E7%BD%91/"/>
    
  </entry>
  
  <entry>
    <title>计算机网络概述</title>
    <link href="http://yoursite.com/2021/06/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E6%A6%82%E8%BF%B0/"/>
    <id>http://yoursite.com/2021/06/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E6%A6%82%E8%BF%B0/</id>
    <published>2021-06-07T05:40:28.000Z</published>
    <updated>2021-07-18T03:39:30.060Z</updated>
    
    <content type="html"><![CDATA[<h1 id="协议层次及服务类型"><a href="#协议层次及服务类型" class="headerlink" title="协议层次及服务类型"></a>协议层次及服务类型</h1><h2 id="OSI-七层模型"><a href="#OSI-七层模型" class="headerlink" title="OSI 七层模型"></a>OSI 七层模型</h2><p>OSI 模型全称为开放式通信系统互连参考模型，是国际标准化组织 ( ISO ) 提出的一个试图使各种计算机在世界范围内互连为网络的标准框架。OSI 将计算机网络体系结构划分为七层，每一层实现各自的功能和协议，并完成与相邻层的接口通信。OSI 的服务定义详细说明了各层所提供的服务。某一层的服务就是该层及其下各层的一种能力，它通过接口提供给更高一层。各层所提供的服务与这些服务是怎么实现的无关。OSI参考模型并没有提供一个可以实现的方法，只是描述了一些概念，用来协调进程间通信标准的制定。即OSI参考模型并不是一个标准，而是一个在制定标准时所使用的概念模型框架。</p><a id="more"></a><p><img src="/2021/06/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E6%A6%82%E8%BF%B0/1.png" alt="1"></p><ul><li>物理层：机械、电子、定时接口通信信道上的原始比特流传输 -<strong>-比特(Bit)</strong></li><li>数据链路层：物理寻址、同时将原始比特流变成逻辑传输路线–<strong>帧(Frame)</strong></li><li>网络层：控制子网的运行，如逻辑编址、分组传输、路由选择–<strong>分组、数据包(Packet)</strong></li><li>传输层：将数据进行分割，并将这些数据交给网络层且保证这些数据段有效的到达对端 –<strong>数据段(Segment)</strong> </li><li>会话层：不同机器上的用户之间建立及管理会话 –<strong>数据(data)</strong></li><li>表示层：信息的语法语义以及它们的关系，如加密、解密、转换翻译、压缩解压缩 –<strong>数据(data)</strong></li><li>应用层 ：定义了应用进程之间的交互规则，通过不同的应用层协议为不同的网络应用提供服务 –<strong>消息/报文(message)</strong></li></ul><p><strong>物理层</strong>：首先要解决两台物理机之间的通信需求，具体就是机器A往机器B发送比特流，机器B能收到这些比特流。物理层主要定义了物理设备的标准，如网线的类型、光纤的接口类型、各种传输介质的传输速率等，主要作用是传输比特流，即 01010二进制数据，将它们转化成电流强弱来进行传输，到达目的主机后再转化成 010101的机器码，即数模转换与模数转换。网卡就工作在这一层。</p><p><strong>数据链路层</strong>：在传输比特流的过程中会产生差错、数据传输不完整的可能，因此数据链路层应运而生。数据链路层定义了如何格式化数据以进行传输，以及如何控制对物理介质的访问。通常还提供错误检测和纠正以确保数据传输的可靠性。本层将比特数据组成了帧，其中交换机工作在这一层，将帧解码并根据帧中包含的信息把数据发送到正确的接收方。</p><p><strong>网络层</strong>：随着网络节点的不断增多，点对点通信时是需要经过多个节点的。那么如何找到最佳节点、如何选择最佳路径便成为了首要的需求，此时便有了网络层。网络层的首要功能是将网络地址翻译成对应的物理地址、并决定如何将数据从发送方路由到接收方。网络层通过综合考虑发送优先权、网络拥赛程度、服务质量以及可选路由的花费来决定从一个网络节点A到另一个网络中节点B的最佳路径。由于网络层处理并智能指导数据发送、 路由选择网络各段，所以路由器属于网络层，此层的数据我们成为数据包。</p><p><strong>传输层</strong>：随着网络通信需求的进一步加大，通信过程中需要发送大量的数据，如海量的文件传输，可能需要很长时间，而网络在通信的过程中会中断好多次，此时为了保证传输大量文件时的准确性，需要对发送方发送出去的数据进行切片，切割为一个个的段落即 <strong>Segment</strong>进行发送。那么便出现了数据段丢失、要不要重传、每个段落要按照顺序到达嘛等问题。传输层解决了主机间的数据传输、传输质量等问题。该层为OSI模型中最重要的一层。传输协议同时进行流量控制，或是基于接收方可接收数据的快慢程度规定适当的发送速率。除此以外传输层按照网络能处理的最大尺寸将数据分割成较小的数据片。同时对每一个数据片安排一个序列号，以便数据到达接收方节点的传输层时能以正确的顺序重组，该过程称为排序。</p><p><strong>会话层</strong>：现在我们已经保证给正确的计算机发送正确的封装过后的信息，但是用户的体验并不好。因为每次都需要我们手动的去调用TCP打包、然后调用IP协议去找路由。所以我们要建立一个自动收发包，自动寻址的功能，于是便有了会话层。会话层的作用即建立和管理应用程序之间的通信。</p><p><strong>表示层</strong>：现在我们可以保证了应用程序可以自动的收发包和寻址，但是对于不同系统之间的通信仍然存在语法的问题。例如用Linux给 windows发包，exe文件并不能在Linux下执行，shell 在windows下也不能执行，此时便出现了表示层。表示层帮我们解决了不同系统间的通信语法问题，在表示层数据将按照网络能理解的方案进行格式化，这种格式化也因所使用的网络的类型不同而不同。</p><p><strong>应用层</strong>：此时虽然发送方知道自己发送的是什么，转换成字节数组后有多长，但是接收方并不知道，所以应用层的网络协议诞生了，应用层规定发送方和接收方必须使用一个固定长度的消息头，消息头必须使用某种固定的组成，而且消息头中必须记录消息体的长度等一系列信息，以方便接收方能够正确的解析发送方发送过来的数据。</p><h2 id="TCP-IP参考模型"><a href="#TCP-IP参考模型" class="headerlink" title="TCP/IP参考模型"></a>TCP/IP参考模型</h2><p>TCP/IP参考模型首先由ARPANET所使用的网络体系结构，后来该结构被美国国防部用来做为计算机网络的标准。在其推动下，市场上绝大多数的厂商也以该标准为主，用以商用。基于 TCP/IP 的参考模型将协议分成四个层次，如上图所示，它们分别是：网络接口层、网络层、传输层、和应用层。</p><p><strong>应用层</strong>：TCP/IP 模型将 OSI 参考模型中的会话层、表示层和应用层的功能合并到一个应用层实现，通过不同的应用层协议为不同的应用提供服务。例如：FTP、Telnet、DNS、SMTP 等。</p><p><strong>传输层</strong>：该层对应于 OSI 参考模型的传输层，为上层实体提供源端到对端主机的通信功能。传输层定义了两个主要协议：传输控制协议（TCP）和用户数据报协议（UDP）。其中面向连接的 TCP 协议保证了数据的传输可靠性，面向无连接的 UDP 协议能够实现数据包简单、快速地传输。</p><p><strong>网际互联层</strong>：网际互联层对应 OSI 参考模型的网络层，主要负责相同或不同网络中计算机之间的通信。在网际互联层， IP 协议提供的是一个不可靠、无连接的数据报传递服务。该协议实现两个基本功能：寻址和分段。根据数据报报头中的目的地址将数据传送到目的地址，在这个过程中 IP 负责选择传送路线。除了 IP 协议外，该层另外两个主要协议是互联网组管理协议（IGMP）和互联网控制报文协议（ICMP）。</p><p><strong>网络接入层</strong>：网络接入层的功能对应于 OSI 参考模型中的物理层和数据链路层，它负责监视数据在主机和网络之间的交换。事实上，TCP/IP 并未真正描述这一层的实现，而由参与互连的各网络使用自己的物理层和数据链路层协议，然后与 TCP/IP 的网络接入层进行连接，因此具体的实现方法将随着网络类型的不同而有所差异。</p><h2 id="TCP-IP-五层参考模型"><a href="#TCP-IP-五层参考模型" class="headerlink" title="TCP/IP 五层参考模型"></a>TCP/IP 五层参考模型</h2><p>五层体系的协议结构是综合了 OSI 和 TCP/IP 优点的一种协议，包括<strong>应用层、传输层、网络层、数据链路层和物理层</strong>。五层协议的体系结构只是为介绍网络原理而设计的，实际应用还是 TCP/IP 四层体系结构。</p><h2 id="比较-TCP-IP-参考模型与-OSI-参考模型"><a href="#比较-TCP-IP-参考模型与-OSI-参考模型" class="headerlink" title="比较 TCP/IP 参考模型与 OSI 参考模型"></a>比较 TCP/IP 参考模型与 OSI 参考模型</h2><p><strong>共同点</strong>：</p><ul><li>都采用了层次结构的概念</li><li>都能够提供面向连接和无连接的通信服务机制</li></ul><p><strong>不同点</strong>：</p><ul><li>OSI 采用了七层模型，而 TCP/IP 是四层</li><li>OSI 是一个在协议开发前设计的、有清晰概念的模型；TCP/IP 是先有协议集然后建立的、事实上得到广泛应用的弱模型，功能描述和实现细节混在一起</li><li>TCP/IP 一开始就提出面向连接和无连接服务，而 OSI 一开始只强调面向连接服务，直到很晚才开始制定无连接的服务标准。</li></ul><h2 id="数据如何在各层之间传输【数据的封装过程】"><a href="#数据如何在各层之间传输【数据的封装过程】" class="headerlink" title="数据如何在各层之间传输【数据的封装过程】"></a>数据如何在各层之间传输【数据的封装过程】</h2><p>在发送主机端，一个应用层报文被传送到运输层。在最简单的情况下，运输层收取到报文并附上附加信息，该首部将被接收端的运输层使用。应用层报文和运输层首部信息一道构成了运输层报文段。附加的信息可能包括：允许接收端运输层向上向适当的应用程序交付报文的信息以及差错检测位信息。该信息让接收端能够判断报文中的比特是否在途中已被改变。运输层则向网络层传递该报文段，网络层增加了如源和目的端系统地址等网络层首部信息，生成了网络层数据报。该数据报接下来被传递给链路层，在数据链路层数据包添加发送端 MAC 地址和接收端 MAC 地址后被封装成数据帧，在物理层数据帧被封装成比特流，之后通过传输介质传送到对端。</p><img src="/2021/06/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E6%A6%82%E8%BF%B0/3.png" alt="3" style="zoom:80%;"><h1 id="TCP-IP-协议群"><a href="#TCP-IP-协议群" class="headerlink" title="TCP/IP 协议群"></a>TCP/IP 协议群</h1><table><thead><tr><th align="left">OSI 七层概念模型</th><th align="center">TCP/IP 四层参考模型</th><th>对应的网络协议</th></tr></thead><tbody><tr><td align="left">应用层（Application</td><td align="center"></td><td>HTTP, TFTP, FTP, NFS, WAIS, SMTP, Telnet, DNS, SNMP</td></tr><tr><td align="left">表示层（Presentation）</td><td align="center">应用层</td><td>TIFF, GIF, JPEG, PICT</td></tr><tr><td align="left">会话层（Session）</td><td align="center"></td><td>RPC, SQL, NFS, NetBIOS, names, AppleTalk</td></tr><tr><td align="left">传输层（Transport)</td><td align="center">传输层</td><td>TCP, UDP</td></tr><tr><td align="left">网络层（Network）</td><td align="center">网络层</td><td>IP, ICMP, ARP, RARP, RIP, IPX</td></tr><tr><td align="left">数据链路层（Data Link）</td><td align="center"></td><td>FDDI, Frame Relay, HDLC, SLIP, PPP</td></tr><tr><td align="left">物理层（Physical）</td><td align="center">网络接口层</td><td>EIA/TIA-232, EIA/TIA-499, V.35, 802.3</td></tr></tbody></table><p><strong>各层的常见协议详解如下：</strong></p><table><thead><tr><th align="center"><strong>协议</strong></th><th><strong>作用</strong></th></tr></thead><tbody><tr><td align="center"><strong>HTTP</strong></td><td>超文本传输协议（HyperText Transfer Protocol）</td></tr><tr><td align="center">FTP</td><td>文件传输协议（File Transfer Protocol）用于在客户端和服务器之间进行文件传输</td></tr><tr><td align="center">SMTP</td><td>简单邮件传输协议（Simple Mail Transfer Protocol）是一个在网络上传输电子邮件的标准</td></tr><tr><td align="center">DNS</td><td>域名系统（Domain Name System）是域名和 IP 地址相互映射的分布式数据库</td></tr><tr><td align="center">SSH</td><td>安全外壳协议（Secure Shell）是一种加密的网络传输协议，可在不安全的网络中为网络服务提供安全的传输环境</td></tr><tr><td align="center">DHCP</td><td>动态主机配置协议（Dynamic Host Configuration Protocol）的主要作用是集中管理、动态分配 IP 地址提升地址的使用率</td></tr><tr><td align="center"><strong>TCP</strong></td><td>传输控制协议（Transmission Control Protocol）是一种面向连接的、可靠的、基于字节流的传输层通信协议</td></tr><tr><td align="center">UDP</td><td>用户数据报协议（User Datagram Protocol）是一个简单的、无连接的、不可靠的、面向数据报的通信协议</td></tr><tr><td align="center"><strong>IP</strong></td><td>网际协议（Internet Protocol）是用于分组交换数据网络的一种协议，功能包括寻址、路由、尽最大努力交付数据包</td></tr><tr><td align="center">ICMP</td><td>互联网控制消息协议（Internet Control Message Protocol）用于返回通信环境的错误消息。traceroute 和 ping 都是基于 ICMP 消息实现的，traceroute 是通过发送含有特殊 TTL 的包，然后接收 ICMP 超时消息和目标不可达消息来实现的；ping 则是用 ICMP 的“Echo request (8)”和“Echo reply (0)”消息来实现的</td></tr><tr><td align="center">IGMP</td><td>因特网组管理协议（Internet Group Management Protocol ）管理 IP 协议多播组成员</td></tr><tr><td align="center">RIP</td><td>路由信息协议（Routing Information Protocol）是一种内部网关协议（IGP），是距离向量路由协议的一种实现</td></tr><tr><td align="center">OSFP</td><td>开放式最短路径优先（Open Shortest Path First）是一种内部网关协议（IGP），使用 Dijkstra 算法计算最短路径，是链路状态路由协议的一种实现</td></tr><tr><td align="center">BGP</td><td>边界网关协议（Border Gateway Protocol）是互联网上一个核心的去中心化自治路由协议，属于矢量路由协议。BGP 用于互联网上，将自治系统视作一个整体；每个自治系统使用 IGP（代表实现有 RIP 和 OSPF）进行路由</td></tr><tr><td align="center"><strong>ARP*</strong></td><td>地址解析协议（Address Resolution Protocol）通过 IP 寻找 MAC 地址</td></tr><tr><td align="center">ARQ</td><td>自动重传请求（Automatic Repeat-reQuest）是一种错误纠正协议</td></tr><tr><td align="center">IEEE802</td><td>IEEE 802 指 IEEE 标准中关于局域网和城域网的一系列标准，其中最广泛使用的有以太网、令牌环、无线局域网等</td></tr></tbody></table><h1 id="相关设备"><a href="#相关设备" class="headerlink" title="相关设备"></a>相关设备</h1><ul><li>集线器（Hub）是<strong>物理层</strong>的硬件，连接所有的线路，广播所有信息</li><li>网桥（Bridge）是<strong>数据链路层</strong>的硬件。网桥隔离两个端口，不同的端口形成单独的冲突域，减少网内冲突。网桥在不同或相同类型的 LAN 之间存储并转发数据帧，根据 MAC 头部来决定转发端口，显然是数据链路层的设备</li><li>交换机（Switch）是<strong>数据链路层</strong>的硬件，相当于多端口的网桥。交换机内部存储 MAC 表，只会将数据帧发送到指定的目的地址</li><li>路由器（Router）是<strong>网络层</strong>的硬件，根据 IP 地址进行寻址，不同子网间的数据传输隔离</li></ul><h1 id="计算机网络的性能指标"><a href="#计算机网络的性能指标" class="headerlink" title="计算机网络的性能指标"></a>计算机网络的性能指标</h1><ul><li>速率：比特（bit）是计算机中数据量的单位，也是信息论中使用的信息量的单位。速率的单位是 b/s，或kb/s, Mb/s, Gb/s 等</li><li>带宽 ：“带宽”是数字信道所能传送的“最高数据率”，单位是“比特每秒”，或 b/s (bit/s)。 </li><li>吞吐量：表示在单位时间内通过某个网络（或信道、接口）的数据量，吞吐量更经常地用于对现实世界中的网络的一种测量，以便知道实际上到底有多少数据量能够通过网络。吞吐量受网络的带宽或网络的额定速率的限制。  </li><li>传输时延：(发送时延 )发送数据时，数据块从结点进入到传输媒体所需要的时间。也就是从发送数据帧的第一个比特算起，到该帧的最后一个比特发送完毕所需的时间。 </li><li>传播时延：电磁波在信道中需要传播一定的距离而花费的时间。 </li><li>处理时延：交换结点为存储转发而进行一些必要的处理所花费的时间。 </li><li>排队时延：结点缓存队列中分组排队所经历的时延。排队时延的长短往往取决于网络中当时的通信量；</li><li>总时延：数据经历的总时延就是发送时延、传播时延、处理时延和排队时延之和。</li></ul><p><strong>参考资料</strong></p><ul><li><a href="https://leetcode-cn.com/leetbook/read/networks-interview-highlights/ekjhp7/" target="_blank" rel="noopener">力扣 (LeetCode)</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;协议层次及服务类型&quot;&gt;&lt;a href=&quot;#协议层次及服务类型&quot; class=&quot;headerlink&quot; title=&quot;协议层次及服务类型&quot;&gt;&lt;/a&gt;协议层次及服务类型&lt;/h1&gt;&lt;h2 id=&quot;OSI-七层模型&quot;&gt;&lt;a href=&quot;#OSI-七层模型&quot; class=&quot;headerlink&quot; title=&quot;OSI 七层模型&quot;&gt;&lt;/a&gt;OSI 七层模型&lt;/h2&gt;&lt;p&gt;OSI 模型全称为开放式通信系统互连参考模型，是国际标准化组织 ( ISO ) 提出的一个试图使各种计算机在世界范围内互连为网络的标准框架。OSI 将计算机网络体系结构划分为七层，每一层实现各自的功能和协议，并完成与相邻层的接口通信。OSI 的服务定义详细说明了各层所提供的服务。某一层的服务就是该层及其下各层的一种能力，它通过接口提供给更高一层。各层所提供的服务与这些服务是怎么实现的无关。OSI参考模型并没有提供一个可以实现的方法，只是描述了一些概念，用来协调进程间通信标准的制定。即OSI参考模型并不是一个标准，而是一个在制定标准时所使用的概念模型框架。&lt;/p&gt;</summary>
    
    
    
    
    <category term="计网" scheme="http://yoursite.com/tags/%E8%AE%A1%E7%BD%91/"/>
    
  </entry>
  
  <entry>
    <title>java多线程基础</title>
    <link href="http://yoursite.com/2021/06/03/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%9F%BA%E7%A1%80/"/>
    <id>http://yoursite.com/2021/06/03/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%9F%BA%E7%A1%80/</id>
    <published>2021-06-03T06:38:51.000Z</published>
    <updated>2021-09-27T08:13:02.044Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、-java进程与线程"><a href="#一、-java进程与线程" class="headerlink" title="一、 java进程与线程"></a>一、 java进程与线程</h1><ul><li>运行一个Java程序会产生一个Java进程，每一个Java进程至少包含三个线程：<code>main()</code> 主线程、<code>gc()</code> 线程、异常处理线程</li><li>每一个进程对应一个JVM实例，多个线程共享JVM里面的堆，每一个线程都有自己私有的栈</li><li>Java采用单线程编程模型，如果程序里面没有创建线程的话，只会自动创建一个线程-&gt;主线程</li><li>Java程序启动时，主线程立刻运行，在执行完各种子线程的关闭动作后才能完成执行</li></ul><p><strong>从 JVM 角度说进程和线程之间的关系</strong></p><img src="/2021/06/03/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%9F%BA%E7%A1%80/4.png" alt="4" style="zoom: 67%;"><p>如上图：一个进程中可以有多个线程，多个线程共享进程的<strong>堆</strong>和<strong>方法区 (JDK1.8 之后的元空间)资源，但是每个线程有自己的 程序计数器</strong>、<strong>虚拟机栈</strong> 和 <strong>本地方法栈</strong>。</p><h2 id="1-为什么要使用多线程"><a href="#1-为什么要使用多线程" class="headerlink" title="1. 为什么要使用多线程"></a>1. 为什么要使用多线程</h2><ul><li>提高计算机系统CPU的利用率</li><li>提高应用程序的响应，增强用户体验</li></ul><h2 id="2-使用多线程可能带来那些问题？"><a href="#2-使用多线程可能带来那些问题？" class="headerlink" title="2. 使用多线程可能带来那些问题？"></a>2. 使用多线程可能带来那些问题？</h2><p>并发编程的目的就是为了能提高程序的执行效率提高程序运行速度，但是并发编程可能会遇到很多问题。比如：内存泄漏、死锁、线程不安全等等</p><h2 id="3-单核CPU与多核CPU"><a href="#3-单核CPU与多核CPU" class="headerlink" title="3.单核CPU与多核CPU"></a>3.单核CPU与多核CPU</h2><ul><li>单核CPU：在一个时间单元内，只能执行一个线程的任务，其实是一种假的多线程。然而在单核的情况下，让用户看起来像同一时刻并发执行多个任务的原因是，CPU分配给单一任务执行的时间片很短、任务切换的频次高，造成所有任务都在并发执行的假象。</li><li>多核CPU：多核时代多线程主要是为了提高 CPU 利用率，同一时刻多个任务同时进行。</li></ul><h2 id="4-并行与并发"><a href="#4-并行与并发" class="headerlink" title="4.并行与并发"></a>4.并行与并发</h2><ul><li>并行：多个CPU同时执行多个任务</li><li>并发：单个CPU同时执行多个任务 (如：秒杀、抢票)</li></ul><h1 id="二、线程的创建及使用"><a href="#二、线程的创建及使用" class="headerlink" title="二、线程的创建及使用"></a>二、线程的创建及使用</h1><p><strong>创建线程四种方式</strong></p><ul><li>继承于<code>Thread</code>类</li><li>实现 <code>Runnable</code>接口</li><li>实现 <code>Callable</code> 接口的方式</li><li>线程池创建</li></ul><h2 id="1-继承于Thread类"><a href="#1-继承于Thread类" class="headerlink" title="1.继承于Thread类"></a>1.继承于Thread类</h2><ol><li>创建一个继承于<code>Thread</code>类的子类</li><li>重写 <code>Thread</code>类的 <code>run()</code>方法 ==&gt; 将此线程需要执行的操作声明在 <code>run()</code>中</li><li>创建<code>Thread</code>类的子类的对象 ==&gt; 主线程</li><li>通过此对象调用<code>start()</code>方法</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i % <span class="number">2</span> == <span class="number">0</span>) &#123;</span><br><span class="line">                System.out.println(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        MyThread t1 = <span class="keyword">new</span> MyThread();</span><br><span class="line">        t1.start();</span><br><span class="line">        <span class="comment">//如下操作在main线程中执行，此时主线程与子线程交替执行 同时抢占cpu资源</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i % <span class="number">2</span> != <span class="number">0</span>) &#123;</span><br><span class="line">                System.out.println(<span class="string">"main========&gt;hello world"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        MyThread t2 = <span class="keyword">new</span> MyThread();</span><br><span class="line">        t2.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-1-Thread类的常用方法"><a href="#1-1-Thread类的常用方法" class="headerlink" title="1.1 Thread类的常用方法"></a>1.1 Thread类的常用方法</h3><ul><li><code>start()</code> 启动当前线程；调用当前线程的run()</li><li><code>run()</code> 通常需要重写Thread类的此方法，将创建的线程要执行的操作声明在此方法中</li><li><code>currentThread()</code> 静态方法，返回执行当前代码的线程</li><li><code>getName()</code> 获取当前线程的名字</li><li><code>setName()</code> 设置当前线程的名字</li><li><code>getPriority()</code> 获取线程的优先级</li><li><code>setPriority()</code> 设置线程优先级</li><li><code>yield()</code> 释放当前线程CPU的执行权 =&gt; 很<strong>可能下一刻该线程又抢到CPU执行权</strong></li><li><code>join()</code> 在某个程序执行流程中调用其他线程的join()时，当前线程将会被阻塞，直到调用的线程执行完毕为止(插队)</li><li><code>sleep(long millitime)</code>让当前线程睡眠指定 <code>millitime</code>时间，此时该线程处于阻塞状态</li><li><code>stop()</code>  _中断线程 已经过时_：当执行此方法时，强制结束当前线程</li><li><code>interrupt()</code>  <em>目前使用的<strong>通知线程中断</strong>的方法</em> ：1. 如果线程处于被阻塞状态，那么线程将立即退出被阻塞状态，抛出一个<code>InterruptedException</code> 2. 如果线程处于正常活动状态，那么会将该线程的终端标志设置为true。被设置中断标志的线程将继续正常运行，不受影响。</li></ul><h3 id="1-2线程的优先级"><a href="#1-2线程的优先级" class="headerlink" title="1.2线程的优先级"></a>1.2线程的优先级</h3><ul><li><code>MIN_PRIORITY</code> = 1</li><li><code>NORM_PRIORITY</code>= 5</li><li><code>MAX_PRIORITY</code> = 10</li></ul><p>注意：高优先级的线程要抢占低优先级线程的cup执行权，只是概率上高优先级的线程有更高的概率被执行，并不意味着只有在高优先级的线程执行完后低线程的线程才执行。</p><h3 id="1-3-线程start-方法与-run-方法的区别"><a href="#1-3-线程start-方法与-run-方法的区别" class="headerlink" title="1.3 线程start() 方法与 run() 方法的区别"></a>1.3 线程start() 方法与 run() 方法的区别</h3><ul><li><code>start()</code>：启动当前线程并调用当前线程的<code>run()</code>。new 一个 Thread，线程进入了新建状态，调用 <code>start()</code>方法，会启动一个线程并使线程进入了就绪状态，当分配到时间片后就可以开始运行了。这是真正的多线程工作。同时一个线程对象只能调用一次<code>start()</code>方法，如果重复调用将抛出 异常<code>IllegalThreadStateException</code> 因为在执行完<code>start()</code>后该线程已经处于终止状态了。</li><li><code>run()</code>：直接执行 <code>run()</code> 方法，会把 <code>run()</code> 方法当成一个 main 线程下的普通方法去执行，并不会在某个线程中执行它，所以这并不是多线程工作。</li></ul><h3 id="1-4-如何给run-传参"><a href="#1-4-如何给run-传参" class="headerlink" title="1.4 如何给run()传参"></a>1.4 如何给<code>run()</code>传参</h3><ul><li>构造函数传参</li><li>成员变量传参</li><li>回调函数传参</li></ul><h2 id="2-实现-Runnable接口"><a href="#2-实现-Runnable接口" class="headerlink" title="2.实现 Runnable接口"></a>2.实现 Runnable接口</h2><ol><li>创建一个实现了<code>Runnable</code>接口的类</li><li>实现类去实现Runnable中的抽象方法 <code>run()</code></li><li>创建实现类的对象</li><li>将此对象作为参数传递到<code>Thread</code>类的构造器中，创建<code>Thread</code>类的对象</li><li>通过<code>Thread</code>类的对象调用<code>start()</code></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyThread2</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i % <span class="number">2</span> == <span class="number">0</span>) &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">"==&gt;"</span> + i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RunnableTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        MyThread2 myThread2 = <span class="keyword">new</span> MyThread2();</span><br><span class="line">        Thread t1 = <span class="keyword">new</span> Thread(myThread2);</span><br><span class="line">        t1.setName(<span class="string">"线程1"</span>);</span><br><span class="line">        t1.start();</span><br><span class="line">        Thread t2 = <span class="keyword">new</span> Thread(myThread2);</span><br><span class="line">        t2.setName(<span class="string">"线程2"</span>);</span><br><span class="line">        t2.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-1继承于Thread类与实现-Runnable接口-两种创建线程方式的联系与区别"><a href="#2-1继承于Thread类与实现-Runnable接口-两种创建线程方式的联系与区别" class="headerlink" title="2.1继承于Thread类与实现 Runnable接口 两种创建线程方式的联系与区别"></a>2.1继承于Thread类与实现 Runnable接口 两种创建线程方式的联系与区别</h3><ul><li><code>public class Thread implements Runnable</code> ==&gt; <code>Thread</code>类本身也实现了<code>Runnable</code>接口。都需要重写<code>run()</code>方法，将线程要执行的逻辑声明在<code>run()</code>中。</li><li>开发中我们优先选择实现 <code>Runnable</code>接口的方式：1.实现的方式没有类的单继承的局限性；2.实现的方式更适合来处理多个线程共享数据的情况</li></ul><h2 id="3-实现-Callable-接口的方式"><a href="#3-实现-Callable-接口的方式" class="headerlink" title="3.实现 Callable 接口的方式"></a>3.实现 Callable 接口的方式</h2><ol><li>创建一个实现了 <code>Callable</code> 接口的实现类</li><li>实现<code>call()</code>，将此线程需要执行的方法声明到<code>call()</code>中</li><li>创建<code>Callable</code>接口实现类的对象</li><li>将此<code>Callable</code>接口实现类的对象作为参数传递到<code>FutureTask</code>构造器中，创建<code>FutureTask</code> 的对象</li><li>将<code>FutureTask</code>对象作为参数传递到Thread类的构造器中，创建Thread类的对象并调用<code>start()</code>;</li><li>获取 <code>Callable</code>中的 <code>call</code>方法的返回值</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NumThread</span> <span class="keyword">implements</span> <span class="title">Callable</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i % <span class="number">2</span> == <span class="number">0</span>) &#123;</span><br><span class="line">                System.out.println(i);</span><br><span class="line">                sum += i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum; <span class="comment">//如果不需要返回值可以返回null      </span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CallableTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        NumThread numThread = <span class="keyword">new</span> NumThread();</span><br><span class="line">        FutureTask futureTask = <span class="keyword">new</span> FutureTask(numThread);</span><br><span class="line">        Thread t1 = <span class="keyword">new</span> Thread(futureTask);</span><br><span class="line">        t1.start(); <span class="comment">//new Thread(futureTask).start();</span></span><br><span class="line">        <span class="keyword">try</span> &#123; <span class="comment">//get()的返回值即为 FutureTask 构造器参数Callable实现类重写的call()的返回值</span></span><br><span class="line">            Object sum = futureTask.get();</span><br><span class="line">            System.out.println(sum);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ExecutionException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-1-如何实现处理线程的返回值"><a href="#3-1-如何实现处理线程的返回值" class="headerlink" title="3.1 如何实现处理线程的返回值"></a>3.1 如何实现处理线程的返回值</h3><ol><li>主线程等待法：当我们在<code>run()</code>方法中写返回值的时候，由于主线程往往比子线程先执行完毕所以根本无法接受子线程的返回值，所以我们可以在主线程中写循环等待算法，当子线程执行完毕后再执行主线程。缺点：当需要等待的变量很多则不合适，并且需要等待多久也不确定。</li><li>使用<code>Thread</code>类的<code>join()</code>方法阻塞当前线程等待子线程处理完毕后获取返回值。优点：是无需处理主线程循环等待算法，更精确；缺点：粒度不够细。</li><li>通过<code>Callable</code>接口实现：1. 通过<code>Future Task</code>  2. 线程池获取</li></ol><h3 id="3-2如何理解实现Callable接口的方式要比实现Runnable接口创建多线程的方式更好"><a href="#3-2如何理解实现Callable接口的方式要比实现Runnable接口创建多线程的方式更好" class="headerlink" title="3.2如何理解实现Callable接口的方式要比实现Runnable接口创建多线程的方式更好"></a>3.2如何理解实现<code>Callable</code>接口的方式要比实现<code>Runnable</code>接口创建多线程的方式更好</h3><ul><li><code>call()</code> 可以有返回值</li><li><code>call()</code> 可以抛出异常，被外面的异常捕获，获取异常的信息</li><li><code>Callable</code> 支持泛型</li></ul><h2 id="4-线程池"><a href="#4-线程池" class="headerlink" title="4. 线程池"></a>4. 线程池</h2><h3 id="4-1ThreadPoolExecutor-类"><a href="#4-1ThreadPoolExecutor-类" class="headerlink" title="4.1ThreadPoolExecutor 类"></a>4.1<code>ThreadPoolExecutor</code> 类</h3><p><strong><code>ThreadPoolExecutor</code> 3 个最重要的参数：</strong></p><ul><li><strong><code>corePoolSize</code> :</strong> 核心线程数线程数定义了最小可以同时运行的线程数量。</li><li><strong><code>maximumPoolSize</code> :</strong> 当队列中存放的任务达到队列容量的时候，当前可以同时运行的线程数量变为最大线程数。</li><li><strong><code>workQueue</code>:</strong> 当新任务来的时候会先判断当前运行的线程数量是否达到核心线程数，如果达到的话，新任务就会被存放在队列中。</li></ul><p><code>ThreadPoolExecutor</code>其他常见参数:</p><ul><li><strong><code>keepAliveTime</code></strong>:当线程池中的线程数量大于 <code>corePoolSize</code> 的时候，如果这时没有新的任务提交，核心线程外的线程不会立即销毁，而是会等待，直到等待的时间超过了 <code>keepAliveTime</code>才会被回收销毁；</li><li><strong><code>unit</code></strong> : <code>keepAliveTime</code> 参数的时间单位。</li><li><strong><code>threadFactory</code></strong> :executor 创建新线程的时候会用到。</li><li><strong><code>handler</code></strong> :饱和策略。</li></ul><p><strong>使用线程池创建线程</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NumberThread</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i % <span class="number">2</span> == <span class="number">0</span>) &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">":"</span> + i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NumberThread1</span> <span class="keyword">implements</span> <span class="title">Callable</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i % <span class="number">2</span> != <span class="number">0</span>) &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">":"</span> + i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PoolTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//提供指定线程数量的线程池</span></span><br><span class="line">        ExecutorService service = Executors.newFixedThreadPool(<span class="number">10</span>);</span><br><span class="line">        <span class="comment">//执行指定线程的操作，需要传入runnable接口或Callable接口实现类的对象</span></span><br><span class="line">        service.execute(<span class="keyword">new</span> NumberThread()); </span><br><span class="line">        service.submit(<span class="keyword">new</span> NumberThread1());  </span><br><span class="line">        <span class="comment">//关闭线程池</span></span><br><span class="line">        service.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-2为什么要使用线程池"><a href="#4-2为什么要使用线程池" class="headerlink" title="4.2为什么要使用线程池"></a>4.2为什么要使用线程池</h3><ul><li><strong>降低资源消耗</strong>。通过重复利用已创建的线程降低线程创建和销毁造成的消耗。</li><li><strong>提高响应速度</strong>。当任务到达时，任务可以不需要的等到线程创建就能立即执行。</li><li><strong>提高线程的可管理性</strong>。线程是稀缺资源，如果无限制的创建，不仅会消耗系统资源，还会降低系统的稳定性，使用线程池可以进行统一的分配，调优和监控。</li></ul><h3 id="4-3-执行-execute-方法和-submit-方法的区别"><a href="#4-3-执行-execute-方法和-submit-方法的区别" class="headerlink" title="4.3. 执行 execute()方法和 submit()方法的区别"></a>4.3. 执行 <code>execute()</code>方法和 <code>submit()</code>方法的区别</h3><ul><li><code>execute()</code>方法用于提交不需要返回值的任务，所以无法判断任务是否被线程池执行成功与否；</li><li><code>submit()</code>方法用于提交需要返回值的任务。线程池会返回一个 <code>Future</code> 类型的对象，通过这个 <code>Future</code> 对象可以判断任务是否执行成功，并且可以通过 <code>Future</code> 的 <code>get()</code>方法来获取返回值，<code>get()</code>方法会阻塞当前线程直到任务完成，而使用 <code>get（long timeout，TimeUnit unit）</code>方法则会阻塞当前线程一段时间后立即返回，这时候有可能任务没有执行完。</li></ul><h1 id="三、线程的生命周期及状态"><a href="#三、线程的生命周期及状态" class="headerlink" title="三、线程的生命周期及状态"></a>三、线程的生命周期及状态</h1><p> java 线程在运行的生命周期中一共有下面<strong>六种状态</strong>：</p><p><img src="/2021/06/03/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%9F%BA%E7%A1%80/6.png" alt="6"></p><p>线程在生命周期中并不是固定处于某一个状态而是<strong>随着代码的执行在不同状态之间切换</strong>。Java 线程状态变迁如下图所示：</p><img src="/2021/06/03/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%9F%BA%E7%A1%80/7.png" alt="7"><p>线程创建之后它将处于 <strong>NEW（新建）</strong> 状态，调用 <code>start()</code> 方法后开始运行，线程这时候处于 <strong>READY（可运行）</strong> 状态。可运行状态的线程获得了 CPU 时间片后就处于 <strong>RUNNING（运行）</strong> 状态。</p><p>当线程执行 <code>wait()</code>方法之后，线程进入 <strong>WAITING（等待）</strong> 状态。进入等待状态的线程不会被分配CPU执行时间，要等待被其他线程显式的唤醒后才能够返回到运行状态，而 <strong>TIME_WAITING(超时等待)</strong> 状态相当于在等待状态的基础上增加了超时限制，比如通过 <code>sleep（long millis）</code>方法或 <code>wait（long millis）</code>方法可以将 Java 线程置于 <strong>TIMED WAITING</strong> 状态。当超时时间到达后 Java 线程将会返回到 <strong>RUNNABLE</strong> 状态。</p><p>当线程调用同步方法时，在没有获取到锁的情况下，线程将会进入到 <strong>BLOCKED（阻塞）</strong> 状态。线程在执行完 <code>run()</code>方法之后将会进入到 <strong>TERMINATED（终止）</strong> 状态，并且一旦终止就不能再复生。</p><h1 id="四、线程的同步"><a href="#四、线程的同步" class="headerlink" title="四、线程的同步"></a>四、线程的同步</h1><h2 id="1-多线程的安全问题"><a href="#1-多线程的安全问题" class="headerlink" title="1.多线程的安全问题"></a>1.多线程的安全问题</h2><p><strong>问题的引出</strong></p><p>假设当前机场有100张票，我们创建3个线程来模拟三个窗口卖票</p><p><strong>代码实现</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Window</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> ticket = <span class="number">100</span>;</span><br><span class="line">    Object obj = <span class="keyword">new</span> Object();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (ticket &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">"卖票，票号为"</span> + ticket);</span><br><span class="line">                    ticket--;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WindowTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Window window = <span class="keyword">new</span> Window();</span><br><span class="line">        Thread w1 = <span class="keyword">new</span> Thread(window);</span><br><span class="line">        Thread w2 = <span class="keyword">new</span> Thread(window);</span><br><span class="line">        Thread w3 = <span class="keyword">new</span> Thread(window);</span><br><span class="line">        w1.setName(<span class="string">"窗口1"</span>);</span><br><span class="line">        w2.setName(<span class="string">"窗口2"</span>);</span><br><span class="line">        w3.setName(<span class="string">"窗口3"</span>);</span><br><span class="line">        w1.start();</span><br><span class="line">        w2.start();</span><br><span class="line">        w3.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>运行结果如下</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">窗口2卖票，票号为100</span><br><span class="line">窗口1卖票，票号为100</span><br><span class="line">窗口3卖票，票号为100</span><br><span class="line">窗口1卖票，票号为98</span><br><span class="line">窗口2卖票，票号为99</span><br><span class="line">窗口1卖票，票号为96</span><br><span class="line">......</span><br></pre></td></tr></table></figure><p><strong>问题分析</strong></p><p>通过上面运行结果我们发现，卖票的过程中出现了重票和错票的问题。原因是当某个线程操作卖票的过程中，尚未操作完成，其他的线程参与了进来，所以出现了多线程的安全问题。</p><p><strong>问题解决</strong></p><p>当一个线程w操作 ticket的时候其他的线程不允许操作进来，直到线程w操作完ticket其他的线程才允许操作ticket，即使线程 w 阻塞也不允许改变。这样便引出了线程同步的概念。</p><h2 id="2-通过同步机制来解决线程的同步问题"><a href="#2-通过同步机制来解决线程的同步问题" class="headerlink" title="2.通过同步机制来解决线程的同步问题"></a>2.通过同步机制来解决线程的同步问题</h2><p><strong>同步锁机制</strong></p><p>在并发操作中，当多个任务进行共享资源竞争时，为了防止出现线程同步的问题，就是当资源被一个任务使用时，在其上加锁。当资源被锁定后，其他任务在其被解锁前就无法访问它了，在其被解锁后，另一个任务才可以锁定并使用它。</p><p><strong>java中我们可以通过同步机制来解决线程的同步问题</strong></p><ul><li>同步代码块</li><li>同步方法</li><li>重入锁<code>ReentrantLock</code></li></ul><h3 id="2-1同步代码块"><a href="#2-1同步代码块" class="headerlink" title="2.1同步代码块"></a>2.1同步代码块</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">synchronized(同步监视器)&#123;</span><br><span class="line">   &#x2F;&#x2F;需要同步的代码</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>操作共享数据的代码即为同步的代码</li><li>共享数据==&gt;多个线程共同操作的数据</li><li>同步监视器 俗称==&gt; 锁 任何一个对象都可以充当锁  </li><li>多个线程必须共用同一把锁 (同步监视器声明的位置不可以在<code>run()</code>中)</li><li>在实现<code>Runnable</code>接口创建的多线程中可以考虑使用 <code>this</code>做同步监视器</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Window2</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> ticket = <span class="number">100</span>;</span><br><span class="line">    Object obj = <span class="keyword">new</span> Object();</span><br><span class="line">  </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (obj) &#123; <span class="comment">//此处的同步监视器可以是 this</span></span><br><span class="line">                <span class="keyword">if</span> (ticket &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">"卖票，票号为"</span> + ticket);</span><br><span class="line">                    ticket--;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-2-同步方法"><a href="#2-2-同步方法" class="headerlink" title="2.2 同步方法"></a>2.2 同步方法</h3><p>如果共享数据的代码完整的声明在一个方法中，我们不妨将此方法声明为同步的</p><ul><li>同步方法仍然涉及到同步监视器，只是不需要显示的声明</li><li>非静态的同步方法，同步器是 <code>this</code></li><li>静态的同步方法，同步器是 当前类本身</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Window3</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> ticket = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (ticket != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">//调用同步方法</span></span><br><span class="line">            show();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 创建同步方法</span></span><br><span class="line"><span class="comment">     * 注意：如果是通过extends继承类的方式创建同步方法需要用 static 修饰</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (ticket &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">10</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">"卖票，票号为"</span> + ticket);</span><br><span class="line">            ticket--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-3-重入锁ReentrantLock"><a href="#2-3-重入锁ReentrantLock" class="headerlink" title="2.3 重入锁ReentrantLock"></a>2.3 重入锁<code>ReentrantLock</code></h3><p><code>ReentrantLock</code>类实现了 <code>Lock</code> ，它拥有与 <code>synchronized</code> 相同的并发性和内存语义。在实现线程安全的控制中，<code>ReentrantLock</code>可以显式加锁、释放锁。</p><p><strong><code>ReentrantLock</code>常用方法</strong></p><ul><li><code>lock()</code> 获得锁</li><li><code>unlock()</code> 释放锁</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Window4</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> ticket = <span class="number">100</span>;</span><br><span class="line">    <span class="keyword">private</span> ReentrantLock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                lock.lock();</span><br><span class="line">                <span class="keyword">if</span> (ticket &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        Thread.sleep(<span class="number">100</span>);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">"售票-票号为"</span> + ticket);</span><br><span class="line">                    ticket--;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                lock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-4-synchronized-与-Lock-的区别"><a href="#2-4-synchronized-与-Lock-的区别" class="headerlink" title="2.4 synchronized 与 Lock 的区别"></a>2.4 <code>synchronized</code> 与 <code>Lock</code> 的区别</h3><ul><li>两者都可以解决线程的安全问题</li><li><code>Lock</code>是显式锁，手动开启和关闭锁；<code>synchronized</code>是隐式锁，出了作用域自动释放锁</li><li><code>Lock</code>只有代码块锁，<code>synchronized</code>有代码块锁和方法锁</li><li>使用<code>Lock</code>锁，JVM将花费较少的时间来调度线程，性能更好。并且具有 更好的扩展性</li></ul><h1 id="五、线程间通信"><a href="#五、线程间通信" class="headerlink" title="五、线程间通信"></a>五、线程间通信</h1><h2 id="1-锁池EntryList与等待池WaitSet"><a href="#1-锁池EntryList与等待池WaitSet" class="headerlink" title="1.锁池EntryList与等待池WaitSet"></a>1.锁池<code>EntryList</code>与等待池<code>WaitSet</code></h2><p><strong>锁池<code>EntryList</code></strong> ：假设线程A已经拥有了某个对象的锁，而其他线程B、C想要调用这个对象的某个<code>synchronized</code>方法（或者块），由于B、C线程在进入对象的<code>synchronized</code>方法（或者块）之前必须先获得该对象锁的拥有权，而恰巧该对象的所目前正被线程A所占用，此时B、C线程就会被阻塞，进入一个地方去等待锁的释放，这个地方就是该对象的锁池。</p><p><strong>等待池<code>WaitSet</code></strong>：假设线程A调用了某个对象的<code>wait()</code>方法，线程A就会释放该对象的锁，同时线程A就进入到了该对象的等待池中，进入到等待池中的线程不会去竞争该对象的锁</p><ul><li>锁池中的线程就会去竞争该对象的锁</li><li>优先级高的线程竞争到锁的概率就会变高</li><li>没有竞争到的线程就会留在锁池当中，不会进入到等待池当中</li><li>竞争到的线程就会运行直到执行完<code>synchronized</code>或者是遇到异常，然后释放锁</li><li>被<code>notify()</code>或<code>notifyAll()</code>唤醒的线程会进入到锁池当中</li></ul><h2 id="2-线程通信涉及的方法"><a href="#2-线程通信涉及的方法" class="headerlink" title="2.线程通信涉及的方法"></a>2.线程通信涉及的方法</h2><ul><li><code>wait()</code>：一旦执行此方法当前线程就进入阻塞状态，释放同步监视器，并进入到等待池中等待被唤醒</li><li><code>notify()</code> ：随机选取一个处于等待池中的线程进入锁池去竞争获取锁的机会</li><li><code>notifyAll()</code>：会让所有处于等待池的线程全部进入锁池去竞争获取锁的机会</li></ul><p><strong>注意</strong></p><p>三个方法执行线程通信时必须使用在同步代码块或同步方法中; 三个方法的调用者必须是 同步代码块或者同步方法的 同步监视器;三个方法都定义在 <code>java.lang.Object</code>中</p><h2 id="3-sleep-方法和wait-方法的区别"><a href="#3-sleep-方法和wait-方法的区别" class="headerlink" title="3. sleep()方法和wait() 方法的区别"></a>3. <code>sleep()</code>方法和<code>wait()</code> 方法的区别</h2><ul><li><code>sleep()</code> 是 <code>Thread</code> 类的方法；<code>wait()</code> 是 <code>Object</code> 类中定义的方法</li><li><code>sleep()</code> 方法可以在任何地方使用；<code>wait()</code> 只能在 <code>synchronized</code> 方法或者 <code>synchronized</code> 块中使用</li><li><strong><code>Thread.sleep</code> 只会让出 CPU，不会导致锁行为的改变；<code>Object.wait</code> 不仅会让出CPU，还会释放已经占有的同步资源锁</strong></li></ul><h2 id="4-实现线程间通信"><a href="#4-实现线程间通信" class="headerlink" title="4. 实现线程间通信"></a>4. 实现线程间通信</h2><p>实现两个线程交替打印 1 - 100</p><p><strong>代码实现</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Number</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> number = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">                notify();</span><br><span class="line">                <span class="keyword">if</span> (number &lt;= <span class="number">100</span>) &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        Thread.sleep(<span class="number">100</span>);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">":"</span> + number);</span><br><span class="line">                    number++;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        wait();</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Communication</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Number number = <span class="keyword">new</span> Number();</span><br><span class="line">        Thread t1 = <span class="keyword">new</span> Thread(number);</span><br><span class="line">        Thread t2 = <span class="keyword">new</span> Thread(number);</span><br><span class="line">        t1.setName(<span class="string">"线程1"</span>);</span><br><span class="line">        t2.setName(<span class="string">"线程2"</span>);</span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="5-线程死锁"><a href="#5-线程死锁" class="headerlink" title="5.线程死锁"></a>5.线程死锁</h2><h3 id="5-1什么是死锁"><a href="#5-1什么是死锁" class="headerlink" title="5.1什么是死锁"></a>5.1什么是死锁</h3><p>不同的线程分别占用对方需要的同步资源不放弃，都等待对方先放弃自己需要的同步资源，就形成了死锁</p><p>如下图所示，线程 A 持有资源 2，线程 B 持有资源 1，他们同时都想申请对方的资源，所以这两个线程就会互相等待而进入死锁状态。</p><p><img src="/2021/06/03/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%9F%BA%E7%A1%80/8.png" alt="8"></p><p>注意：出现死锁后，不会出现异常，不会出现提示，只是所有的线程都处于阻塞状态无法继续执行。</p><h3 id="5-2死锁演示"><a href="#5-2死锁演示" class="headerlink" title="5.2死锁演示"></a>5.2死锁演示</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DeadLockTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        StringBuffer strLock1 = <span class="keyword">new</span> StringBuffer();</span><br><span class="line">        StringBuffer strLock2 = <span class="keyword">new</span> StringBuffer();</span><br><span class="line">        <span class="comment">//线程1等待线程2释放 strLock2 ，而线程2等待线程1释放 strLock1 ===&gt;产生死锁</span></span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">synchronized</span> (strLock1) &#123;</span><br><span class="line">                    strLock1.append(<span class="string">"a"</span>);</span><br><span class="line">                    strLock2.append(<span class="string">"1"</span>);</span><br><span class="line">                    <span class="comment">//增加sleep()加大了产生死锁的可能</span></span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        Thread.sleep(<span class="number">100</span>);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">synchronized</span> (strLock2) &#123;</span><br><span class="line">                        strLock1.append(<span class="string">"b"</span>);</span><br><span class="line">                        strLock2.append(<span class="string">"2"</span>);</span><br><span class="line">                        System.out.println(strLock1);</span><br><span class="line">                        System.out.println(strLock2);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="string">"线程 1"</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">synchronized</span> (strLock2) &#123;</span><br><span class="line">                    strLock1.append(<span class="string">"c"</span>);</span><br><span class="line">                    strLock2.append(<span class="string">"3"</span>);</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        Thread.sleep(<span class="number">100</span>);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">synchronized</span> (strLock1) &#123;</span><br><span class="line">                        strLock1.append(<span class="string">"d"</span>);</span><br><span class="line">                        strLock2.append(<span class="string">"4"</span>);</span><br><span class="line">                        System.out.println(strLock1);</span><br><span class="line">                        System.out.println(strLock2);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="string">"线程 2"</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> <strong>参考资料</strong></p><ul><li><a href="https://github.com/Snailclimb/JavaGuide/blob/master/docs/java/multi-thread/2020最新Java并发基础常见面试题总结.md" target="_blank" rel="noopener">JavaGuide-java并发基础</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;一、-java进程与线程&quot;&gt;&lt;a href=&quot;#一、-java进程与线程&quot; class=&quot;headerlink&quot; title=&quot;一、 java进程与线程&quot;&gt;&lt;/a&gt;一、 java进程与线程&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;运行一个Java程序会产生一个Java进程，每一</summary>
      
    
    
    
    
    <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>步入Linux的世界</title>
    <link href="http://yoursite.com/2021/05/26/%E6%AD%A5%E5%85%A5Linux%E7%9A%84%E4%B8%96%E7%95%8C/"/>
    <id>http://yoursite.com/2021/05/26/%E6%AD%A5%E5%85%A5Linux%E7%9A%84%E4%B8%96%E7%95%8C/</id>
    <published>2021-05-26T08:08:15.000Z</published>
    <updated>2021-08-25T09:09:40.097Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Linux-初步认识"><a href="#Linux-初步认识" class="headerlink" title="Linux 初步认识"></a>Linux 初步认识</h1><h2 id="Linux的千奇百怪的版本"><a href="#Linux的千奇百怪的版本" class="headerlink" title="Linux的千奇百怪的版本"></a>Linux的千奇百怪的版本</h2><p>目前世界上主流的操作系统 –&gt; Windows Linux Unix MacOS</p><p><strong>Linux 严格上来说只是操作系统内核</strong>，我们所说的Linux操作系统实质上是 “GNU/Linux”</p><p> <strong>“GNU/Linux”</strong> –&gt; GNU项目 + Linux kernel就可以组成一个类Unix的操作系统</p><p>Linux主要运行在服务器和其他大型平台上</p><p><strong>Linux发行版</strong> –&gt; 在Linux kernel 加上一些件组成,不同的组合就构成了不同的发行版 如 Debian Fedora OpenSUSE </p><a id="more"></a>  <img src="/2021/05/26/%E6%AD%A5%E5%85%A5Linux%E7%9A%84%E4%B8%96%E7%95%8C/Unix.png" alt="Unix" style="zoom: 67%;"><h1 id="Linux四大组成部分"><a href="#Linux四大组成部分" class="headerlink" title="Linux四大组成部分"></a>Linux四大组成部分</h1><ul><li>Linux Kernel 内核</li><li>GNU工具</li><li>GUI Desktop环境</li><li>Application </li></ul><h3 id="Linux-Kernel"><a href="#Linux-Kernel" class="headerlink" title="Linux Kernel"></a>Linux Kernel</h3><ol><li>进程管理</li><li>内存管理</li><li>文件管理 （不同的文件系统主要是<strong>文件的读写标准</strong>不同  如Linux -&gt; ext，ext2  Windows -&gt; FAT32 NTFS ）</li><li>硬件设备管理</li></ol><h3 id="GNU"><a href="#GNU" class="headerlink" title="GNU"></a>GNU</h3><p>GNU -&gt; 理查德·斯托曼 创建的一个组织 发起了自由软件运动</p><p>“linux” 最初只是一个内核，不像Unix 有一些软件，Linux Kernel 本身没有，所以GNU 模仿 Unix 同样为 Linux 写了一些必要的软件</p><p><strong>GNU核心</strong></p><p>1.coreutils: 核心工具软件包</p><ul><li>用来处理文件的工具</li><li>用来操作文本的工具</li><li>用来管理进程的工具</li></ul><p>2.Shell: 提供给用户使用的软件,用户拿它使用电脑，实现人机交互</p><ul><li>图形界面shell (GUI shell  -&gt;  Graphical User Interface shell ）</li><li>命令行式shell (CLI  shell  -&gt; Command Line Interface shell)</li></ul><p><strong>传统意义上的shell指的是命令行式的shell</strong>,GNU 是为 Linux 写了 CLS</p><p> <strong>常用的shell 种类</strong></p><ul><li>bash (linux 默认的shell )</li><li>zsh (比较庞大的一种shell)</li><li>tcsh (tcsh是csh的增强版，csh是具有c语言风格的一种shell)</li><li>oh-my-zsh (是一款社区驱动的命令行工具,它基于 zsh 命令行)</li></ul><h3 id="GUI"><a href="#GUI" class="headerlink" title="GUI"></a>GUI</h3><p>人们使用计算机的方式</p><ul><li>命令行壳层提供一个命令行界面（CLI）</li><li>图像壳层提供一个<strong>图形用户界面</strong>（GUI）</li></ul><p><strong>GUI的类型</strong></p><p>1.Xwindows，2.KDE(一种主流的桌面设计理念 如 Windows ，Mac Os)，3.GNOME，4.Unity (用于 Ubantu)</p><h2 id="Bash-shell"><a href="#Bash-shell" class="headerlink" title="Bash shell"></a>Bash shell</h2><h3 id="Linux常用命令搜索"><a href="#Linux常用命令搜索" class="headerlink" title="Linux常用命令搜索"></a><a href="https://wangchujiang.com/linux-command/" target="_blank" rel="noopener">Linux常用命令搜索</a></h3><h4 id="find"><a href="#find" class="headerlink" title="find"></a>find</h4><p><strong>find命令</strong> 用来在指定目录下查找文件。任何位于参数之前的字符串都将被视为欲查找的目录名。如果使用该命令时，不设置任何参数，则find命令将在当前目录下查找子目录与文件。并且将查找到的子目录和文件全部进行显示。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">find ~ -name &quot;main.java&quot; -&gt; 精确查找文件</span><br><span class="line"></span><br><span class="line">find ~ -name &quot;main*&quot; -&gt; 模糊查找文件</span><br><span class="line"></span><br><span class="line">find ~ -iname &quot;mian*&quot;  -&gt; 不区分文件名大小写去查找文件</span><br><span class="line"></span><br><span class="line">man find  -&gt; 更多关于find 指令的使用说明</span><br></pre></td></tr></table></figure><h4 id="grep"><a href="#grep" class="headerlink" title="grep"></a>grep</h4><p><strong>grep</strong> （global search regular expression(RE) and print out the line，全面搜索正则表达式并把行打印出来）是一种强大的文本搜索工具，它能使用正则表达式搜索文本，并把匹配的行打印出来。用于过滤/搜索的特定字符。可使用正则表达式能配合多种命令使用，使用上十分灵活。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">grep [options] pattern file     </span><br><span class="line">grep &quot;hello world&quot; main*;  --&gt; 从以main字符打头的文件中查找文本内容中包含 &quot;hello world&quot; 字符串的行并打印出来</span><br></pre></td></tr></table></figure><h4 id="管道操作符"><a href="#管道操作符" class="headerlink" title="管道操作符|"></a>管道操作符|</h4><p>管道操作符可以将指令连接起来，前一个指令的输出可以作为后一个指令的输入</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">find ~ | grep &quot;hello world&quot;  </span><br><span class="line">--&gt; 在当前home目录下递归列出所有文件及目录 , 将左侧的标准输出内容作为标准输入传递到右边的grep命令中</span><br></pre></td></tr></table></figure><p><strong>使用管道注意的要点</strong></p><ul><li>只处理前一个命令正确的输出，不处理错误输出</li><li>右边命令必须能够接收标准输入流，否则传递过程中数据会被抛弃</li><li>常作为管道接收的命令有 -&gt; sed,awk,grep,cut,head,top,less,more,wc,join,sort,split 等</li></ul><p><strong>常用的grep命令</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">grep &#39;partial\[true\]&#39; bsc-plat-al-data.info.log -&gt; 在内容中查找包含某个字段的文件并将相关结果显示出来</span><br><span class="line">grep -o &#39;engine\[[0 - 9a-z]*\]&#39; -&gt; 通过选择-o 选项，筛选出相关的符合正则表达式的内容</span><br><span class="line">grep -v &#39;grep&#39;  -&gt; 过滤掉包含相关字符的内容</span><br></pre></td></tr></table></figure><h4 id="对文件内容做统计"><a href="#对文件内容做统计" class="headerlink" title="对文件内容做统计"></a>对文件内容做统计</h4><p><strong>awk</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">awk [options] &#39;cmd&#39; file</span><br><span class="line">一次读取一行文本，按输入分隔符进行切片，切成多个组成部分</span><br><span class="line">将切片直接保存在内建的变量中，$1,$2...($0表示行的全部)</span><br><span class="line">支持对单个切片的判断，支持循环判断，默认分隔符为空格</span><br></pre></td></tr></table></figure><p><strong>常用的awk命令</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">awk &#39;&#123;print $1, $4&#125;&#39; netstat.txt -&gt; 筛选出文件内容里的某些列的数据，其中筛选文件也可以是多个，按照空格传入多个文件即可</span><br><span class="line">awk &#39;$1 &#x3D;&#x3D; &quot;top&quot; &amp;&amp; $2 &#x3D;&#x3D; 1&#123;print $0&#125;&#39; netstat.txt -&gt; 按照一定的条件来筛选文件中某些列的信息</span><br><span class="line">awk &#39;&#123;enginearr[$1]++&#125;END&#123;for(i in enginearr)print i&quot;\t&quot; enginearr[i]&#125;&#39;</span><br><span class="line">-&gt; 对内容进行逐行的进行统计操作，并列出对应的统计结果</span><br></pre></td></tr></table></figure><h4 id="批量替换文本内容"><a href="#批量替换文本内容" class="headerlink" title="批量替换文本内容"></a>批量替换文本内容</h4><p><strong>sed</strong> 是一种流编辑器，它是文本处理中非常重要的工具，能够完美的配合正则表达式使用，功能不同凡响。处理时，把当前处理的行存储在临时缓冲区中，称为“模式空间”（pattern space），接着用sed命令处理缓冲区中的内容，处理完成后，把缓冲区的内容送往屏幕。接着处理下一行，这样不断重复，直到文件末尾。文件内容并没有 改变，除非你使用重定向存储输出。Sed主要用来自动编辑一个或多个文件；简化对文件的反复操作；编写转换程序等。</p><p><strong>sed常用的命令</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sed &#39;s&#x2F;book&#x2F;books&#x2F;&#39; file -&gt; 替换文本中的字符串</span><br><span class="line">sed -i &#39;s&#x2F;book&#x2F;books&#x2F;g&#39; file -&gt; 直接编辑文件 选项-i ，会匹配file文件中每一行的所有book替换为books</span><br><span class="line">sed &#39;s&#x2F;book&#x2F;books&#x2F;g&#39; file -&gt; 使用后缀 &#x2F;g 标记会替换每一行中的所有匹配</span><br><span class="line">sed &#39;&#x2F;^$&#x2F;d&#39; file  -&gt; 删除空白行</span><br></pre></td></tr></table></figure><p><strong>参考资料</strong></p><ul><li><a href="https://blog.csdn.net/qq_46207024/article/details/116431998#4Bash_shell_152" target="_blank" rel="noopener">★Bash shell命令</a></li><li><a href="https://www.bilibili.com/video/BV18U4y1W7av" target="_blank" rel="noopener">Frank步入Linux的现代方法</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;Linux-初步认识&quot;&gt;&lt;a href=&quot;#Linux-初步认识&quot; class=&quot;headerlink&quot; title=&quot;Linux 初步认识&quot;&gt;&lt;/a&gt;Linux 初步认识&lt;/h1&gt;&lt;h2 id=&quot;Linux的千奇百怪的版本&quot;&gt;&lt;a href=&quot;#Linux的千奇百怪的版本&quot; class=&quot;headerlink&quot; title=&quot;Linux的千奇百怪的版本&quot;&gt;&lt;/a&gt;Linux的千奇百怪的版本&lt;/h2&gt;&lt;p&gt;目前世界上主流的操作系统 –&amp;gt; Windows Linux Unix MacOS&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Linux 严格上来说只是操作系统内核&lt;/strong&gt;，我们所说的Linux操作系统实质上是 “GNU/Linux”&lt;/p&gt;
&lt;p&gt; &lt;strong&gt;“GNU/Linux”&lt;/strong&gt; –&amp;gt; GNU项目 + Linux kernel就可以组成一个类Unix的操作系统&lt;/p&gt;
&lt;p&gt;Linux主要运行在服务器和其他大型平台上&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Linux发行版&lt;/strong&gt; –&amp;gt; 在Linux kernel 加上一些件组成,不同的组合就构成了不同的发行版 如 Debian Fedora OpenSUSE &lt;/p&gt;</summary>
    
    
    
    
    <category term="linux" scheme="http://yoursite.com/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>系统调用的实现</title>
    <link href="http://yoursite.com/2021/05/23/%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%E7%9A%84%E5%AE%9E%E7%8E%B0/"/>
    <id>http://yoursite.com/2021/05/23/%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%E7%9A%84%E5%AE%9E%E7%8E%B0/</id>
    <published>2021-05-23T07:09:20.000Z</published>
    <updated>2021-06-02T12:56:16.634Z</updated>
    
    <content type="html"><![CDATA[<h2 id="操作系统的接口"><a href="#操作系统的接口" class="headerlink" title="操作系统的接口"></a>操作系统的接口</h2><p>接口即一些函数，操作系统为上层应用提供一种进入到内核中的手段</p><p>接口表现为函数调用又由系统提供，所以称为<strong>系统调用</strong></p><h3 id="操作系统向上连接的并不是用户而是应用程序"><a href="#操作系统向上连接的并不是用户而是应用程序" class="headerlink" title="操作系统向上连接的并不是用户而是应用程序"></a>操作系统向上连接的并不是用户而是应用程序</h3><p>接口是计算机系统中两个独立的部件进行信息交换的共享边界，应用程序与操作系统之间存在接口，操作系统和计算机硬件之间也存在接口。通过接口可以实现应用程序与操作系统之间的通信和操作系统与计算机硬件之间的通信。由此可见与操作系统相连接的并不是用户，而是应用程序。</p>  <a id="more"></a>  <h3 id="操作系统既然并不面向用户那么用户是如何使用操作系统的"><a href="#操作系统既然并不面向用户那么用户是如何使用操作系统的" class="headerlink" title="操作系统既然并不面向用户那么用户是如何使用操作系统的"></a>操作系统既然并不面向用户那么用户是如何使用操作系统的</h3><ul><li>命令行 (命令程序)</li><li>图形界面 （消息框架程序 + 消息处理程序）</li><li>应用程序</li></ul><h4 id="命令行"><a href="#命令行" class="headerlink" title="命令行"></a>命令行</h4><p>以Linux操作系统为例，当我们使用命令行在去执行hello world程序的时候，C语言代码中的printf函数会在Linux操作系统中生成gcc -o output output.c文件，然后通过shell命令去执行output.c文件，此时该文件会调用操作系统里的write函数，将printf里的字符串写到cmd命令行界面上。这里的write函数就是操作系统接口也叫系统调用。</p><h4 id="图形界面"><a href="#图形界面" class="headerlink" title="图形界面"></a>图形界面</h4><p>我们以图形化界面中的一个按钮举例。当鼠标点击按钮以后，硬件输入首先会进入一个系统消息队列，然后进入应用消息队列，此时应用消息程序会从消息队列中获得硬件输入的指令，应用消息程序中有WinMain消息循环函数，WinMain函数中有一个GetMassage函数，GetMassage函数从操作系统中获取系统调用，硬件输入的系统调用是OnOK()。在OnOK()中有fopen() 函数，printf() 函数，fclose() 函数，主要功能是获取硬件输入指令相应的信息，然后打印该信息最后关闭该信息。打印的信息作为OnOK()函数的返回值返回到getMassage函数，最后消息循环函数在处理这一硬件输入的循环过程结束，硬件输入的执行结果进入到消息队列中，最后返回给用户。</p><h3 id="一些常见的操作系统接口"><a href="#一些常见的操作系统接口" class="headerlink" title="一些常见的操作系统接口"></a>一些常见的操作系统接口</h3><p><strong>POSIX</strong>: Portable Operating System Interface of UNIX (IEEE 制定的一个标准族)</p><p>POSIX标准定义了操作系统应该为应用程序提供的接口标准，目的是为了增强程序的可移植性。</p><table><thead><tr><th align="center">分类</th><th align="center">POSIX 定义</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center"></td><td align="center">fork</td><td align="center">创建一个进程</td></tr><tr><td align="center"><strong>任务管理</strong></td><td align="center">execl</td><td align="center">运行一个可执行程序</td></tr><tr><td align="center"></td><td align="center">pthread_create</td><td align="center">创建一个线程</td></tr><tr><td align="center"></td><td align="center">open</td><td align="center">打开一个文件或目录</td></tr><tr><td align="center"><strong>文件系统</strong></td><td align="center">EACCES</td><td align="center">返回值：表示没有权限</td></tr><tr><td align="center"></td><td align="center">mode_tst_mode</td><td align="center">文件头结构：文件属性</td></tr></tbody></table><h2 id="系统调用的实现"><a href="#系统调用的实现" class="headerlink" title="系统调用的实现"></a>系统调用的实现</h2><p>实现一个 <strong>whoami</strong>  系统调用，一个放在操作系统内核中的字符串 ”I am cxy“ (系统引导时被载入的)被取出来并打印。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//假设该段为用户程序</span></span><br><span class="line">main()</span><br><span class="line">&#123;</span><br><span class="line">whoami();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//假设该段为内核代码</span></span><br><span class="line">whoami()</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="number">100</span>,<span class="number">8</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="string">"I am cxy"</span> <span class="comment">// 100</span></span><br></pre></td></tr></table></figure><p><strong>要求</strong></p><ul><li>不能jmp，不应该jmp  唉</li><li>凭什么不让我jmp 害</li><li>不jmp该怎么实现 呢</li></ul><h3 id="为什么不可以jmp"><a href="#为什么不可以jmp" class="headerlink" title="为什么不可以jmp"></a>为什么不可以jmp</h3><p>操作系统在内存中，应用程序也在内存中，想访问操作系统提供的功能为什么不直接跳进去？直接 mov 不行嘛？</p><p>no no no !!!</p><p>直接mov jmp 就成为了简单的函数调用。操作系统中存储着重要的信息，如root 的用户名和密码，如果可以轻松进入随便访问，那么root的用户名和密码就很可能被应用程序给<strong>捞</strong>上来，太不安全。所以绝对不可以jmp，mov 进入操作系统内部。</p><h3 id="为什么jmp不进去"><a href="#为什么jmp不进去" class="headerlink" title="为什么jmp不进去"></a>为什么jmp不进去</h3><p>特权环：将内核程序与用户程序<strong>隔离</strong>-&gt; 区分为 <strong>内核态 和用户态</strong> (一种处理器的硬件设计刚性的)</p><p>计算机对内存的使用是一段一段的，内核态可以访问任何数据，用户态不可以 访问内核态数据 -&gt; 由段寄存器实现</p><p>两个特殊的段寄存器</p><p>DPL ：目标内存段的特权级</p><p>CPL ：当前内存段的特权级</p><p>只有当 CPL &lt;= DPL 即 当前内存段的特权级小于等于目标内存段的特权级才能进入到目标内存段</p><img src="/2021/05/23/%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%E7%9A%84%E5%AE%9E%E7%8E%B0/1.png" alt="1" style="zoom:80%;"><p><strong>注解</strong></p><p>在操作系统初始化时，head.s执行时会针对内核态的代码和数据建立GDT表，对应的内核态的DPL为0 是初始化好的。当用户态执行的时候，启动一个用户程序，CS中的CPL = 3 (当操作系统初始化后推动用户态将CS的CPL置为3，之后就一直维持为3)。每次跳转或者mov 都要访问GDT表，当发现 CPL = 3 &gt; DPL = 0 时就直接挡住，根本不让你jmp mov ，所以也就无法通过 jmp、mov 进入内核。</p><h3 id="不jmp如何实现系统调用—中断"><a href="#不jmp如何实现系统调用—中断" class="headerlink" title="不jmp如何实现系统调用—中断"></a>不jmp如何实现系统调用—中断</h3><p>中断 -&gt; 硬件提供的“主动进入内核的方法” </p><p>中断是用户程序发起的调用内核代码的唯一方式</p><p>中断指令 int 0x80 -&gt; 操作系统初始化好的代码，只能从 int 0x80 这扇大门进入到操作系统内部 </p><p><strong>系统调用的核心</strong></p><ol><li>用户程序中包含一段含有int指令的代码</li><li>操作系统写中断处理，获取想调程序的编号</li><li>操作系统根据编号执行相应的代码</li></ol><h3 id="write-系统调用解析"><a href="#write-系统调用解析" class="headerlink" title="write()系统调用解析"></a>write()系统调用解析</h3><img src="/2021/05/23/%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%E7%9A%84%E5%AE%9E%E7%8E%B0/2.png" alt="2" style="zoom:80%;"><p>首先应用程序调用printf，在库函数中变成了printf</p><p>我们使用printf的写法是printf(“%d”,i); 但事实上printf()内部是调用了系统函数 write();</p><p><strong>write的函数头部</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// fd：要进行写操作的文件描述；buf：需要输出的缓冲区；count：最大输出字节计数</span></span><br><span class="line"><span class="function"><span class="keyword">ssize_t</span> <span class="title">write</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">const</span> <span class="keyword">void</span> *buf, <span class="keyword">size_t</span> count)</span></span>;</span><br></pre></td></tr></table></figure><p>我们可以发现，printf()函数的形参和write()的形参是不一样的。所以要想通过printf()调用write()的话，首先就需要库函数格式化输出，采用c语言的处理方式使其转化成符合write()函数的格式。</p><p><strong>在printf函数里面调用write</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;unisted.h&gt;</span></span></span><br><span class="line">_syscall3(<span class="keyword">int</span>, <span class="built_in">write</span>, <span class="keyword">int</span>, fd, <span class="keyword">const</span> <span class="keyword">char</span>* buf, <span class="keyword">off_t</span>, count)</span><br></pre></td></tr></table></figure><h4 id="syscall3-宏"><a href="#syscall3-宏" class="headerlink" title="_syscall3 宏"></a>_syscall3 宏</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _syscall3(type,name,atype,a,btype,b,ctype,c)\</span></span><br><span class="line">type name(atype a, btype b, ctype c) \</span><br><span class="line"><span class="comment">//内嵌汇编</span></span><br><span class="line">&#123; <span class="keyword">long</span> __res;\</span><br><span class="line"><span class="function">__asm__ <span class="title">volatile</span><span class="params">(“<span class="keyword">int</span> <span class="number">0x80</span>”:”=a”(__res):””(__NR_##name), <span class="comment">//执行中断处理函数 int0x80 输出 res 输入 __NR_writ </span></span></span></span><br><span class="line">”b”((long)(a)),”c”((long)(b)),“d”((long)(c)))); if(__res&gt;=0) return</span><br><span class="line">(type)__res; errno=-__res; <span class="keyword">return</span> <span class="number">-1</span>;&#125;</span><br></pre></td></tr></table></figure><p><strong>_syscall3 宏注解</strong></p><ul><li>可以看出在printf函数里面调用write其实是利用了_syscall3 这个宏, _syscall3 宏调用之后就是展开成上面的一段汇编代码。主要就是将宏展开代码中的type,name,atype,a,btype,b,ctype,c 替换成了int, write, int, fd, const char* buf, off_t, count。                              因此type name(atype a, btype b, ctype c) 就变成了int write(int fd,const char * buf, off_t count)；</li><li>展开的汇编代码一样会跟着变化，此时出现了中断代码 int 0x80, (该段代码为_syscall3 的核心代码)操作系统内核的大门即将打开。之前我们了解到在head.s里面会重新建立idt表，之后中断就会根据中断号查那个表，然会获得中断服务函数的入口地址。</li><li>”=a”(res):””(NR_##name) -&gt; :左边为输出右边为输入。<br>”“(<em>NR##name) name为之前传入的参数 write 所以该条指令就是将<strong>NR_write = 4 赋值给eax这个寄存器，</strong>NR_write称为系统调用号，就是根据它来区分不同的系统调用函数同时获得中断函数的入口地址。如在linux/inlcude/unistd.h中 # define <em>_NR_write 4<br>”=a”(</em></em> res) 为输出，将来要把eax赋给res</li><li>”b”((long)(a)),”c”((long)(b)),“d”((long)(c))就是把形参的a、b、c依次赋值给ebx、ecx、edx三个寄存器；输入完成之后就通过int 0x80这个中断号进入操作系统。</li><li>int 0x80这条指令执行完之后，eax中就会存放int 0x80的返回值，然后将这个返回值赋值给<strong>res，</strong>res就是int write()这个系统调用的返回值，至此write这个系统调用也就结束了。</li></ul><h4 id="int-0x80"><a href="#int-0x80" class="headerlink" title="int 0x80"></a>int 0x80</h4><p>int 0x80 的实现  -&gt; 通过<strong>set_system_gate 中断处理门</strong> 取出中断处理函数然后跳到那里去执行 </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sched_init</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123; set_system_gate(<span class="number">0x80</span>,&amp;system_call); &#125;</span><br></pre></td></tr></table></figure><p>int 0x80对应的中断处理函数就是system_call，init 代表初始化，0x80就是要用后面这个 system_call来处理。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">在linux/include/<span class="keyword">asm</span>/system.h中</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> set_system_gate(n, addr) \ <span class="comment">//n 中断处理号，addr 地址</span></span></span><br><span class="line">_set_gate(&amp;idt[n],<span class="number">15</span>,<span class="number">3</span>,addr); <span class="comment">//idt是中断向量表基址</span></span><br></pre></td></tr></table></figure><p>set_system_gate这个宏又调用了_set_gate这个宏</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">在linux/include/<span class="keyword">asm</span>/system.h中</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _set_gate(gate_addr, type, dpl, addr)\</span></span><br><span class="line">__asm__(“movw %%dx,%%ax\n\t” “movw %<span class="number">0</span>,%%dx\n\t”\</span><br><span class="line">“movl %%eax,%<span class="number">1</span>\n\t” “movl %%edx,%<span class="number">2</span>”:\</span><br><span class="line">:”i”((short)(<span class="number">0x8000</span>+(dpl&lt;&lt;<span class="number">13</span>)+type&lt;&lt;<span class="number">8</span>))),“o”(*(( \</span><br><span class="line"><span class="keyword">char</span>*)(gate_addr))),”o”(*(<span class="number">4</span>+(<span class="keyword">char</span>*)(gate_addr))),\</span><br><span class="line">“d”((<span class="keyword">char</span>*)(addr),”a”(<span class="number">0x00080000</span>))</span><br></pre></td></tr></table></figure><p>_set_gate这个宏建立了类似于下图的表格</p><p><img src="/2021/05/23/%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%E7%9A%84%E5%AE%9E%E7%8E%B0/3.png" alt="3"></p><p><strong>_set_gate的目的就是要改变特权级穿过特权环的隔离进入到内核</strong></p><p>用户态的程序如果要进入内核，必须使用0x80号中断，那么就必须先要进入idt表。用户态的CPL=3，且idt表的DPL故意设置成3，因此能够跳到idt表，跳到idt表中之后就能找到之后程序跳转的地方，也就是中断服务函数的起始地址，CS就是段选择符（8），ip就是”处理函数入口点偏移“。CS=8，IP =&amp;system_call就是跳到内核的system_call这个函数去执行；</p><p><strong>int 0x80 完整流程</strong></p><ul><li>初始化的时候0x80号中断的DPL设成3，让用户态的代码能跳进内核</li><li>进入内核后，设置CS = 8(CS 的最后两位为 00 所以 CPL 也就自然变成了0)，IP = &amp;system_call 来重置 PC指针</li><li>根据PC指针继续跳到 system_call 去执行</li><li>最后 int 0x80返回之后，CS最后两位再次变成3，变成用户态</li></ul><h4 id="system-call"><a href="#system-call" class="headerlink" title="system_call"></a>system_call</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">在linux/kernel/system_call.s中</span><br><span class="line">nr_system_calls=<span class="number">72</span></span><br><span class="line">.globl _system_call</span><br><span class="line">_system_call: cmpl $nr_system_calls<span class="number">-1</span>,%eax</span><br><span class="line">ja bad_sys_call</span><br><span class="line">push %ds push %es push %fs</span><br><span class="line">pushl %edx pushl %ecx pushl %ebx <span class="comment">//调用的参数</span></span><br><span class="line">movl $<span class="number">0x10</span>,%edx mov %dx,%ds mov %dx,%es <span class="comment">//内核数据</span></span><br><span class="line">movl $<span class="number">0x17</span>,%edx mov %dx,%fs <span class="comment">//fs可以找到用户数据</span></span><br><span class="line">call _sys_call_table(,%eax,<span class="number">4</span>) <span class="comment">//a(,%eax,4)=a+4*eax</span></span><br><span class="line">pushl %eax <span class="comment">//返回值压栈，留着ret_from_sys_call时用</span></span><br><span class="line">... <span class="comment">//其他代码</span></span><br><span class="line">ret_from_sys_call: popl %eax, 其他pop, iret</span><br></pre></td></tr></table></figure><p><strong>system_call注解</strong></p><ul><li>system_call 的核心代码为 call _sys_call_table(,%eax,4) -&gt;通过call 跳到另外一个地址去执行</li><li>_sys_call_table(,%eax,4) 为一种寻址方式 -&gt; _sys_call_table + 4 * %eax 等于相应的系统调用处理函数真正的入口地址</li><li>_sys_call_table-&gt;函数表 起始地址； 4 -&gt;每个系统调用占4个字节； eax -&gt; 系统调用号__NR_write 4</li></ul><h4 id="sys-call-table"><a href="#sys-call-table" class="headerlink" title="_sys_call_table"></a>_sys_call_table</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">在include/linux/sys.h中</span><br><span class="line">fn_ptr sys_call_table[]=</span><br><span class="line">&#123;sys_setup, sys_exit, sys_fork, sys_read, sys_write,</span><br><span class="line">...&#125;;</span><br><span class="line"></span><br><span class="line">在include/linux/sched.h中</span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">int</span> <span class="params">(fn_ptr*)</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><p><strong>_sys_call_table注解</strong></p><p>sys_call_table是一个fn_ptr类型的全局函数表，fn_ptr是一个函数指针，4个字节，这就是_sys_call_table+4*%eax  这里为什么要乘4的原因。查表然后就可以根据eax来知道要调用的真正中断服务函数的入口地址。此处 eax = __NR_write = 4, 找到下标4对应的函数即为 sys_write。所以 call _sys_call_table(,%eax,4) 就对应了 call sys_write 接着就真正开始执行系统函数 sys_write 了。</p><h4 id="write系统调用总结"><a href="#write系统调用总结" class="headerlink" title="write系统调用总结"></a>write系统调用总结</h4><p><strong>库函数printf -&gt; syscall3 -&gt; 库函数write -&gt; int 0x80 -&gt; system_call -&gt; sys_call_table -&gt; sys_write</strong></p><img src="/2021/05/23/%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%E7%9A%84%E5%AE%9E%E7%8E%B0/6.png" alt="6" style="zoom:80%;"><p>库函数printf 通过 _syscall3 这个宏来调用 write 函数，在 write 函数中调用 system_call 来处理 int 0x80, 在system_call 中调用 system_call_table 这个表知道要调用的真正中断服务函数的入口地址，再根据 eax 中存储的系统调用号就可以真正跳到sys_write这个系统函数去执行了。执行完成后输出返回值并跳回用户态至此write的系统调用结束。</p><h2 id="whoami-系统调用设计"><a href="#whoami-系统调用设计" class="headerlink" title="whoami  系统调用设计"></a><strong>whoami</strong>  系统调用设计</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//用户态代码</span></span><br><span class="line">main()</span><br><span class="line">&#123;</span><br><span class="line">eax = <span class="number">72</span>;</span><br><span class="line"><span class="keyword">int</span> <span class="number">0x80</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//中断处理</span></span><br><span class="line">system_call:</span><br><span class="line">_sys_call_table + eax * <span class="number">4</span>  <span class="comment">//sys_whoami() -&gt; 72</span></span><br><span class="line">call sys_whoami</span><br><span class="line"><span class="comment">//内核态代码 </span></span><br><span class="line">sys_whoami()</span><br><span class="line"> &#123;</span><br><span class="line"> printk(<span class="number">100</span>,<span class="number">8</span>);</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="string">"I am cxy"</span> <span class="comment">// 100地址处</span></span><br></pre></td></tr></table></figure><p>前面我们了解到，想要设计一个whoami() 系统调用，因为很不安全所以不允许jmp，此时用户态的CPL = 3，内核态代码DPL = 0,也根本跳不进来。我们要想设计一个系统调用就要必须通过操作系统硬件设计好的 int 0x80中断指令进入内核，所以我们自己设置系统调用号eax = 72 再通过int 0x80 进入到操作系统内部。那么此时我们用户态CPL = 3,  int 0x80 的DPL 也做成 3 ，就可以穿过接口了，一旦穿过去之后，CPL就会被置为0，然后就开始执行 system_call, 在 _sys_call_table中查表就调用了 sys_whoami(); 最终就真的进入到内核去执行sys_whoami()，这时候再用printk()将内存地址100 处的字符串 “I am cxy” 打印出来，故事就到这里结束了。</p><p><strong>参考资料</strong></p><ul><li><a href="https://www.bilibili.com/video/BV1d4411v7u7" target="_blank" rel="noopener">哈工大李治军操作系统</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;操作系统的接口&quot;&gt;&lt;a href=&quot;#操作系统的接口&quot; class=&quot;headerlink&quot; title=&quot;操作系统的接口&quot;&gt;&lt;/a&gt;操作系统的接口&lt;/h2&gt;&lt;p&gt;接口即一些函数，操作系统为上层应用提供一种进入到内核中的手段&lt;/p&gt;
&lt;p&gt;接口表现为函数调用又由系统提供，所以称为&lt;strong&gt;系统调用&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&quot;操作系统向上连接的并不是用户而是应用程序&quot;&gt;&lt;a href=&quot;#操作系统向上连接的并不是用户而是应用程序&quot; class=&quot;headerlink&quot; title=&quot;操作系统向上连接的并不是用户而是应用程序&quot;&gt;&lt;/a&gt;操作系统向上连接的并不是用户而是应用程序&lt;/h3&gt;&lt;p&gt;接口是计算机系统中两个独立的部件进行信息交换的共享边界，应用程序与操作系统之间存在接口，操作系统和计算机硬件之间也存在接口。通过接口可以实现应用程序与操作系统之间的通信和操作系统与计算机硬件之间的通信。由此可见与操作系统相连接的并不是用户，而是应用程序。&lt;/p&gt;</summary>
    
    
    
    
    <category term="操作系统" scheme="http://yoursite.com/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>操作系统的启动</title>
    <link href="http://yoursite.com/2021/05/20/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%90%AF%E5%8A%A8/"/>
    <id>http://yoursite.com/2021/05/20/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%90%AF%E5%8A%A8/</id>
    <published>2021-05-20T11:19:30.000Z</published>
    <updated>2021-08-09T02:37:21.810Z</updated>
    
    <content type="html"><![CDATA[<h2 id="打开电源那神秘的黑色背后发生着什么"><a href="#打开电源那神秘的黑色背后发生着什么" class="headerlink" title="打开电源那神秘的黑色背后发生着什么"></a>打开电源那神秘的黑色背后发生着什么</h2><ol><li>x86 PC刚开机时CPU处于实模式 （实模式即16bit，保护模式即32bit）</li><li>开始时，CS = 0xFFFF；IP = 0x0000；（CS-&gt; 段寄存器；IP-&gt;段内偏移; <strong>CS &lt;&lt; 4 + IP = 物理地址</strong>）</li><li>寻址 0xFFFF0(ROM BIOS 映射区)  （BIOS -&gt; Basic Input Output System；固化到内存地址为 0xFFFF0 处的一段代码）</li><li>检查RAM，键盘，显示器，软硬磁盘</li><li>将磁盘0磁道0扇区读入 0x7c00处 （0磁道0扇区为操作系统的引导扇区共 512byte）</li><li>设置CS = 0x07c0; IP = 0x0000;</li><li>寻址 0x7c00 开始执行操作系统引导扇区的代码</li></ol><a id="more"></a>  <p><strong>注解</strong></p><p>intel x86 PC机开机接通电源后，在内存0xFFFF0处固化了一段程序即 ROM BIOS ，由于计算机的工作原理是取指执行，如果内存中一片空白则无法进行取指执行，所以该段程序是由硬件已经做好的。刚一上电硬件自动设置 CS = 0xFFFF；IP = 0x0000；由于[CS &lt;&lt;4 + IP = 0xFFFF0] ，所以刚一上电就跳到了 BIOS区进行执行。执行该段固化好的代码-&gt; 1.检查RAM，键盘，显示器，软硬磁盘，2.将磁盘0磁道0扇区的代码读入到 0x7c00处 。然后更新 CS = 0x07c0; IP = 0x0000; 继续取指执行，寻址 0x7c00 开始执行操作系统引导扇区的代码。因此硬盘的第一个扇区上存放着开机后执行的第一段我们可以控制的程序。<strong>操作系统的故事从这里开始……</strong></p><h2 id="引导扇区代码-bootsect-s"><a href="#引导扇区代码-bootsect-s" class="headerlink" title="引导扇区代码 bootsect.s"></a>引导扇区代码 bootsect.s</h2><p><strong>为什么引导扇区的代码使用汇编</strong></p><p>在操作系统引导的过程中我们要保证有绝对的控制，使用汇编可以精准的变成机器指令去执行，而使用C语言则首先需要编译，在编译的过程中很可能会发生差错，没办法进行绝对的控制，就很可能发生死机的情况。</p><p><strong>bootsect核心代码</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">BOOTSEG = <span class="number">0x07c0</span></span><br><span class="line">INITSEG = <span class="number">0x9000</span></span><br><span class="line">SETUPSEG = <span class="number">0x9020</span></span><br><span class="line"></span><br><span class="line">entry start <span class="comment">//关键字entry告诉链接器“程序入口”</span></span><br><span class="line">start:</span><br><span class="line">    mov ax, #BOOTSEG mov ds, ax</span><br><span class="line">    mov ax, #INITSEG mov es, ax</span><br><span class="line">    mov cx, #<span class="number">256</span></span><br><span class="line">    sub si, si sub di,di</span><br><span class="line">    rep movw</span><br><span class="line">    jmpi go, INITSEG</span><br><span class="line"></span><br><span class="line">go: mov ax,cs <span class="comment">//cs=0x9000</span></span><br><span class="line">    mov ds,ax mov es,ax mov ss,ax mov sp,#<span class="number">0xff00</span></span><br><span class="line">load_setup: <span class="comment">//载入setup模块</span></span><br><span class="line">    mov dx,#<span class="number">0x0000</span> mov cx,#<span class="number">0x0002</span> mov bx,#<span class="number">0x0200</span></span><br><span class="line">    mov ax,#<span class="number">0x0200</span>+SETUPLEN <span class="keyword">int</span> <span class="number">0x13</span> <span class="comment">//BIOS中断</span></span><br><span class="line">    jnc ok_load_setup</span><br><span class="line">    mov dx,#<span class="number">0x0000</span></span><br><span class="line">    mov ax,#<span class="number">0x0000</span> <span class="comment">//复位</span></span><br><span class="line">    <span class="keyword">int</span> <span class="number">0x13</span></span><br><span class="line">    j load_setup <span class="comment">//重读</span></span><br></pre></td></tr></table></figure><ul><li>将磁盘上从第 2 到 5 的四个扇区构成的 setup 模块读入到了内存的0x90200 处；</li><li>然后打出一个 Logo；</li></ul><img src="/2021/05/20/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%90%AF%E5%8A%A8/1.png" alt="1" style="zoom:80%;"><p><strong>注解</strong></p><p>对于x86PC来说，bootsect  刚读进来是放在0x07c00这个位置，然后将其转移到0x90000这个位置，并继续执行；利用int 0x13中断，将操作系统的setup读入到0x90200开始的内存处；读入setup之后，bootsect 继续执行，在屏幕上显示开机logo “loading system…”，然后进入 read_it 继续读操作系统模块，并将控制权转移到setup中，执行setup中的内容。</p><h2 id="setup-s"><a href="#setup-s" class="headerlink" title="setup.s"></a>setup.s</h2><p><strong>setup-&gt;OS启动前的配置</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">SYSSEG = <span class="number">0x1000</span></span><br><span class="line"></span><br><span class="line">start: mov ax,          #INITSEG mov ds,ax mov ah,#<span class="number">0x03</span></span><br><span class="line">    <span class="keyword">xor</span> bh,bh <span class="keyword">int</span> <span class="number">0x10</span>  <span class="comment">//取光标位置dx mov [0],dx</span></span><br><span class="line">    mov ah,#<span class="number">0x88</span> <span class="keyword">int</span> <span class="number">0x15</span> mov [<span class="number">2</span>],ax ...</span><br><span class="line">    cli                 <span class="comment">//不允许中断</span></span><br><span class="line">    mov ax,             #<span class="number">0x0000</span> cld</span><br><span class="line">do_move: mov es,ax add ax,#<span class="number">0x1000</span></span><br><span class="line">    cmp ax,             #<span class="number">0x9000</span> jz end_move</span><br><span class="line">    mov ds,ax sub di,di</span><br><span class="line">    sub si,si</span><br><span class="line">    mov cx,             #<span class="number">0x8000</span></span><br><span class="line">    rep                 # 将system模块移到<span class="number">0</span>地址</span><br><span class="line">    movsw</span><br><span class="line">    jmp do_move</span><br></pre></td></tr></table></figure><ul><li>准备初始化参数 （将硬件参数存放到0x90000处）</li><li>将<strong>system操作系统主体模块</strong>移动到0地址处</li><li>临时建立GDT IDT表，<strong>jump 0，8</strong> 进入到保护模式下</li></ul><img src="/2021/05/20/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%90%AF%E5%8A%A8/2.png" alt="2" style="zoom: 80%;"><p><strong>注解</strong></p><p>操作系统是管理各种硬件的，要管理各种硬件就必须首先知道各种硬件参数。管理内存就要知道内存有多少，同时知道都被谁给占着，这就需要数据结构来存储这些信息。所以setup会获取各种硬件的信息并建立相应的数据结构来管理这些硬件。</p><p>CS是16bit寄存器，IP也是16bit的寄存器。CS&lt;&lt;4 + IP 最多只能形成一个 20 位地址放到地址总线上，所以最多只能寻址 <strong>1M</strong> 以内的内存。这对于现在的计算机是远远不够的。所以需要从实模式进入到保护模式下（1M -&gt; 4G）</p><p>16bit 模式和 32bit 模式的本质区别是 <strong>CPU的解释程序不同</strong></p><p>保护模式下的寻址方式不再是 CS&lt;&lt;4 + IP，而是根据<strong>CS(选择子) 查表 + IP</strong></p><h2 id="System"><a href="#System" class="headerlink" title="System"></a>System</h2><p>执行完bootsect与setup模块之后，接着跳到system操作系统的主体模块进行执行。</p><h3 id="head-s"><a href="#head-s" class="headerlink" title="head.s"></a>head.s</h3><p>head.s是system模块开始的第一个文件，存放在0地址处</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">stratup_32: movl $<span class="number">0x10</span>,%eax mov %ax,%ds mov %ax,%es</span><br><span class="line">    mov %as,%fs mov %as,%gs <span class="comment">//指向gdt的0x10项(数据段)</span></span><br><span class="line">    lss _stack_start,%esp <span class="comment">//设置栈(系统栈)</span></span><br><span class="line">    call setup_idt</span><br><span class="line">    call setup_gdt</span><br><span class="line">    xorl %eax,%eax</span><br><span class="line"><span class="number">1</span>:incl %eax</span><br><span class="line">    movl %eax,<span class="number">0x000000</span> cmpl %eax,<span class="number">0x100000</span></span><br><span class="line">    je <span class="number">1b</span> <span class="comment">//0地址处和1M地址处相同(A20没开启)，就死循环</span></span><br><span class="line">    jmp after_page_tables <span class="comment">//页表，什么东东?</span></span><br><span class="line">setup_idt: lea ignore_int,%edx</span><br><span class="line">    movl $<span class="number">0x00080000</span>,%eax movw %dx,%ax</span><br><span class="line">    lea _idt,%edi movl %eax,(%edi)</span><br></pre></td></tr></table></figure><ul><li>setup.s是进入保护模式，head.s是进入保护模式之后的初始化。</li><li>重新设置 GDT, IDT 表，重新开启A20地址线 （setup里设置的gdt与idt 是临时的，开启A20地址线后寻址范围就从1M变成了4G）</li><li>IDT表是中断函数表，从此int n 不再是DOS中断，而是在IDT表中找到中断函数的地址并执行。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">after_page_tables:</span><br><span class="line">    pushl $<span class="number">0</span> pushl $<span class="number">0</span> pushl $<span class="number">0</span> pushl $L6</span><br><span class="line">    pushl $_main jmp setup_paging</span><br><span class="line">L6: jmp L6</span><br><span class="line">setup_paging: 设置页表 ret</span><br></pre></td></tr></table></figure><ul><li>在前面开启20号地址线之后就jmp到after_page_tables这个标号处</li><li>在after_page_tables里面将main函数三个参数、L6、main函数的入口地址都压入栈中</li><li>在set_paging 执行完毕后，将ret到main() 函数执行</li></ul><p><strong>注解</strong></p><p>IDT,GDT 的查表都是硬件查表，都是硬件设计好的，目的就是为了速度快</p><p>head.s中使用的汇编和bootsect 及 setup的汇编不一样，head.s中使用的是32位的汇编代码，而bootsect及setup中使用的是16位的汇编代码。另外在操作系统的.c文件中还使用一种汇编为”内嵌汇编”。</p><h3 id="main-c"><a href="#main-c" class="headerlink" title="main.c"></a>main.c</h3><p><strong>main函数完成了各种硬件数据结构的初始化</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    mem_init();</span><br><span class="line">    trap_init();</span><br><span class="line">    blk_dev_init();</span><br><span class="line">    chr_dev_init();</span><br><span class="line">    tty_init();</span><br><span class="line">    time_init();</span><br><span class="line">    sched_init();</span><br><span class="line">    buffer_init();</span><br><span class="line">    hd_init();</span><br><span class="line">    floppy_init();</span><br><span class="line">    sti();</span><br><span class="line">    move_to_user_mode();</span><br><span class="line">    <span class="keyword">if</span>(!fork())&#123;init();&#125;   <span class="comment">// 这行永远不会退出</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>bootsect将操作系统从磁盘中读入进内存，setup获取一些硬件参数并进入到保护模式，head初始化一些gdt表，并初始化一些页表，之后跳到main函数，main中有一大堆init，完成对各种硬件数据结构的初始化。</p><p><strong>总体可以概括为两步</strong></p><ol><li>将操作系统读入到内存</li><li>初始化</li></ol><p>只有先将操作系统读入进内存后计算机才能进行取指执行</p><p>初始化是因为操作系统是管理计算机硬件的软件，要想管理硬件就先要对每一种硬件做出相应的数据结构。setup，head，main, mem-init 这些搭在一起就是为了 得到硬件参数，初始化关键的数据结构，为将来管理操作系统做准备。</p><p><strong>参考资料</strong></p><ul><li><a href="https://www.bilibili.com/video/BV1d4411v7u7" target="_blank" rel="noopener">哈工大李治军操作系统</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;打开电源那神秘的黑色背后发生着什么&quot;&gt;&lt;a href=&quot;#打开电源那神秘的黑色背后发生着什么&quot; class=&quot;headerlink&quot; title=&quot;打开电源那神秘的黑色背后发生着什么&quot;&gt;&lt;/a&gt;打开电源那神秘的黑色背后发生着什么&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;x86 PC刚开机时CPU处于实模式 （实模式即16bit，保护模式即32bit）&lt;/li&gt;
&lt;li&gt;开始时，CS = 0xFFFF；IP = 0x0000；（CS-&amp;gt; 段寄存器；IP-&amp;gt;段内偏移; &lt;strong&gt;CS &amp;lt;&amp;lt; 4 + IP = 物理地址&lt;/strong&gt;）&lt;/li&gt;
&lt;li&gt;寻址 0xFFFF0(ROM BIOS 映射区)  （BIOS -&amp;gt; Basic Input Output System；固化到内存地址为 0xFFFF0 处的一段代码）&lt;/li&gt;
&lt;li&gt;检查RAM，键盘，显示器，软硬磁盘&lt;/li&gt;
&lt;li&gt;将磁盘0磁道0扇区读入 0x7c00处 （0磁道0扇区为操作系统的引导扇区共 512byte）&lt;/li&gt;
&lt;li&gt;设置CS = 0x07c0; IP = 0x0000;&lt;/li&gt;
&lt;li&gt;寻址 0x7c00 开始执行操作系统引导扇区的代码&lt;/li&gt;
&lt;/ol&gt;</summary>
    
    
    
    
    <category term="操作系统" scheme="http://yoursite.com/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>操作系统概述</title>
    <link href="http://yoursite.com/2021/05/16/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0/"/>
    <id>http://yoursite.com/2021/05/16/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0/</id>
    <published>2021-05-16T08:44:16.000Z</published>
    <updated>2021-06-22T10:47:58.341Z</updated>
    
    <content type="html"><![CDATA[<h2 id="计算机是如何工作的"><a href="#计算机是如何工作的" class="headerlink" title="计算机是如何工作的"></a>计算机是如何工作的</h2><h3 id="从白纸到图灵机"><a href="#从白纸到图灵机" class="headerlink" title="从白纸到图灵机"></a><strong>从白纸到图灵机</strong></h3><p>计算机是如何工作的说到底就是一个<strong>计算模型</strong></p><p>1936年，英国数学家A.C.图灵提出了一种模型，通过纸带模拟人使用笔在纸上进行计算。即在纸带上读入3，在纸带上读入2，在纸带上读入 +，控制器查表知道是5，接着在纸带上写下5；<strong>此时图灵机只能进行加法运算</strong>。</p><a id="more"></a>  <p><img src="/2021/05/16/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0/7.jpg" alt="7"></p><h3 id="从图灵机到通用图灵机"><a href="#从图灵机到通用图灵机" class="headerlink" title="从图灵机到通用图灵机"></a><strong>从图灵机到通用图灵机</strong></h3><p>只能进行加法运算的计算模型显然是不够的，接着人们将控制器进行更改，当遇到加法操作时就改为加法控制器，当遇到乘法操作时就将控制器更改为乘法控制器。此时的通用图灵机就可以根据不同的运算方式来进行不同的计算控制，实现了通用的计算模型。</p><img src="/2021/05/16/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0/6.jpg" alt="6" style="zoom: 80%;"><h3 id="从通用图灵机到计算机"><a href="#从通用图灵机到计算机" class="headerlink" title="从通用图灵机到计算机"></a><strong>从通用图灵机到计算机</strong></h3><p><strong>冯·诺依曼</strong>首次提出<strong>存储程序</strong>的思想。</p><p>一种将程序指令存储器和数据存储器合并在一起的电脑设计概念结构</p><p>计算机由五大部分组成：<strong>运算器、控制器、存储器、输入设备、输出设备</strong>。</p><p>存储程序计算机在体系结构上主要特点有：1.以运算单元为中心；2.采用存储程序原理；3.存储器是按地址访问、线性编址的空间；3.控制流由指令流产生；4.指令由操作码和地址码组成；6.数据以二进制编码；</p><p>计算机在程序的控制下一步一步的从存储器中取出指令并进行处理，从此计算机工作的原理变成了<strong>取指执行</strong></p><img src="/2021/05/16/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0/55.png" alt="55" style="zoom:50%;"><h2 id="什么是操作系统"><a href="#什么是操作系统" class="headerlink" title="什么是操作系统"></a>什么是操作系统</h2><h3 id="维基百科的解释"><a href="#维基百科的解释" class="headerlink" title="维基百科的解释"></a><strong>维基百科的解释</strong></h3><p>操作系统（英语：<strong>O</strong>perating <strong>S</strong>ystem，缩写：<strong>OS</strong>）是一组主管并控制计算机操作、运用和运行硬件、软件资源和提供公共服务来组织用户交互的相互关联的系统软件程序，同时也是计算机系统的内核与基石。操作系统需要处理如管理与配置内存、决定系统资源供需的优先次序、控制输入与输出设备、操作网络与管理文件系统等基本事务。操作系统也提供一个让用户与系统交互的操作界面。</p><h3 id="简而言之"><a href="#简而言之" class="headerlink" title="简而言之"></a><strong>简而言之</strong></h3><p>键盘能输入，鼠标能点，显示器能看。人们可以在其上面进行听音乐、看电影、浏览网站等一系列<strong>人机交互</strong>动作的东西。</p><h3 id="将操作系统立起来"><a href="#将操作系统立起来" class="headerlink" title="将操作系统立起来"></a><strong>将操作系统立起来</strong></h3><p>操作系统是工作在应用程序与计算机硬件之间的一层软件。向上给应用程序提供接口，向下管理各种硬件。</p><img src="/2021/05/16/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0/1.jpg" alt="1" style="zoom: 50%;"><h3 id="操作系统都管理那些硬件"><a href="#操作系统都管理那些硬件" class="headerlink" title="操作系统都管理那些硬件"></a><strong>操作系统都管理那些硬件</strong></h3><p>CPU管理    内存管理    终端管理    磁盘管理    文件管理    <em>网络管理    电源管理    多核管理</em></p><img src="/2021/05/16/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0/8.jpg" alt="8" style="zoom:80%;"><h2 id="操作系统的历史"><a href="#操作系统的历史" class="headerlink" title="操作系统的历史"></a>操作系统的历史</h2><h3 id="多进程图谱主线"><a href="#多进程图谱主线" class="headerlink" title="多进程图谱主线"></a>多进程图谱主线</h3><h4 id="1955-1965-年-IBM-7094"><a href="#1955-1965-年-IBM-7094" class="headerlink" title="1955-1965 年 IBM 7094"></a>1955-1965 年 IBM 7094</h4><p>计算机使用只专注于科学计算</p><p>批处理操作系统</p><p>典型代表：IBSYS 监控系统</p><h4 id="1965-1980-从IBSYS-到-OS-360"><a href="#1965-1980-从IBSYS-到-OS-360" class="headerlink" title="1965-1980 从IBSYS 到 OS/360"></a>1965-1980 从IBSYS 到 OS/360</h4><p>计算机开始进入多个行业，开始让计算机做很多事，往往既有IO任务，又有计算任务，如果按照以往的批处理系统，在执行IO任务的时候cup就要停下来。你让这么重要的计算机停一会？你觉得合适嘛？</p><p>多进程结构和进程管理概念萌芽</p><p>所以这个时候就出现了 <strong>多道程序</strong>  作业间的切换 和 调度 成为了核心</p><h4 id="1965-1980-从OS-360到MULTICS"><a href="#1965-1980-从OS-360到MULTICS" class="headerlink" title="1965-1980 从OS/360到MULTICS"></a>1965-1980 从OS/360到MULTICS</h4><p> 从OS/360到MULTICS并没有本质的区别，核心同样都是任务切换多道处理，但是增加了<strong>分时系统</strong>的概念</p><p>此时OS/360操作系统已经可以同时执行多个程序但是进程的切换是 在<strong>执行不下去</strong>的情况才切换，所以就会出现个别程序得不到cpu调度始终无法得到执行的情况，始终等待老倒霉蛋了！</p><p>所以就进行优化出现了分时系统的概念，cpu根据时间定期的切换，每个进程都一段一段的向前推进。</p><p>从此多进程的结构更加的清晰</p><h4 id="1980-1990-MULTICS-到-UNIX"><a href="#1980-1990-MULTICS-到-UNIX" class="headerlink" title="1980-1990 MULTICS 到 UNIX"></a>1980-1990 MULTICS 到 UNIX</h4><p>小型化计算机出现</p><p>UNIX是一个简化的MULTICS，核心概念差不多，同样还是任务切换 分时系统，但是更加的灵活和成功</p><p>Ken Thompson 和 Dennis Ritchie于1969年在贝尔实验室开发  后来重新用c语言进行编写</p><p>他们两个人是唯一通过做出系统而获得图灵奖的人 同时c语言同样是他们创造的</p><h4 id="1990-2000从UNIX到Linux"><a href="#1990-2000从UNIX到Linux" class="headerlink" title="1990-2000从UNIX到Linux"></a>1990-2000从UNIX到Linux</h4><p>个人计算机开始普及，很多人开始使用计算机</p><p>1987年 Andrew Tanenbaum 发布了MINX(非常类似UNIX) 用于教学</p><p>Linus Torvalds 在360sx 兼容微机上学习 MINIX ,并作出小Linux 并于 1991年发布</p><p>1994年 Linux 1.0 采用GPL 协议发布</p><p>1998年以后，互联网世界里展开了一场历史性的Linux的产业化运动</p><h4 id="IBSYS-gt-OS-360-gt-MULTICS-gt-Unix-gt-Linux"><a href="#IBSYS-gt-OS-360-gt-MULTICS-gt-Unix-gt-Linux" class="headerlink" title="IBSYS - &gt; OS/360 - &gt; MULTICS -&gt; Unix -&gt; Linux"></a>IBSYS - &gt; OS/360 - &gt; MULTICS -&gt; Unix -&gt; Linux</h4><p><strong>总结历史</strong></p><p><strong>多进程结构是操作系统的基本图谱</strong></p><ul><li>用户通过执行程序来使用计算机-&gt; 吻合冯诺依曼思想</li><li>作为管理者，操作系统要让多个程序合理推进 -&gt; 进程管理</li><li>多进程推进时需要内存复用等等</li></ul><h3 id="文件操作视图辅线"><a href="#文件操作视图辅线" class="headerlink" title="文件操作视图辅线"></a>文件操作视图辅线</h3><h4 id="PC与DOS"><a href="#PC与DOS" class="headerlink" title="PC与DOS"></a>PC与DOS</h4><p>IBM推出 PC机后，操作系统出现了百家争鸣的局面</p><p>1975年 Digital Research 这家公司 为 Altair8800 开发了操作系统 CP/M</p><p> CP/M : 写命令让用户使用，执行命令对应的程序，为单任务执行</p><p>1980年 出现了 8080 16位芯片，从 CP/M 的基础上开发了 QDOS(Quick and Dirty OS)</p><h4 id="从QDOS到-MS-DOS"><a href="#从QDOS到-MS-DOS" class="headerlink" title="从QDOS到 MS-DOS"></a>从QDOS到 MS-DOS</h4><p><strong>Bill Gates</strong> 进入历史舞台…..</p><p>1975年，22岁的 Paul Allen 和 20 岁的 Bill Gates 为 Altair8800 开发了 BASIC 解释器，据此开创了微软</p><p>1977年，Bill Gates 开发了 FAT磁盘管理系统</p><p> <strong>QDOS 的成功在于 以 CP/M 为基础，将BASIC and FAT 整合了进来</strong></p><p>1980年，IBM 想和 Digital Research 合作要求授权使用 CP/M,但是没有成功，转而同微软合作</p><p>1981年，微软买下了 QDOS,并改名为 MS-DOS (Disk OS) 同 IBM PC 一起打包出售 火爆全场</p><h4 id="从MS-DOS到Windows"><a href="#从MS-DOS到Windows" class="headerlink" title="从MS-DOS到Windows"></a>从MS-DOS到Windows</h4><p>MS-DOS的磁盘 ，文件，命令，让人使用计算加很方便，但似乎可以更加的方便…</p><p>1989年，MS-DOS 4.0 出现，支持了鼠标和键盘，此时微软已经决定要放弃 MS - DOS</p><p>不久后，图形界面操作系统 Windows 3.0 大获成功 （乔布斯直呼内行hhh）</p><p>然后就一发不可收拾，95 、xp、Vista、Win7、Win8…</p><h4 id="Mac-OS-与-ios"><a href="#Mac-OS-与-ios" class="headerlink" title="Mac OS 与 ios"></a>Mac OS 与 ios</h4><p>1984年，苹果推出 PC(麦金塔机，Macintosh) ,简称Mac 机。其处理器使用 IBM Intel 或者AMD等 ，核心在于屏幕、能耗等</p><p>和 Mac 机一起发布 System X 系统，一上来就是 GUI 图形化系统</p><p>在System 7 以后改名为 Mac OS 8</p><p>2007年，苹果发布 ios，核心仍然是 Mac OS, 专为移动端设备使用</p><p><strong>Mac OS 的 核心是 Unix, 专注于界面、文件、媒体等 和用户有关的内容。</strong></p><h4 id="CP-M-gt-QDOS-gt-MS-DOS-gt-Windows-Unix-gt-System-gt-Mac-OS-gt-ios"><a href="#CP-M-gt-QDOS-gt-MS-DOS-gt-Windows-Unix-gt-System-gt-Mac-OS-gt-ios" class="headerlink" title="CP/M -&gt; QDOS -&gt; MS- DOS -&gt; Windows    /  Unix -&gt; System -&gt; Mac OS -&gt; ios"></a>CP/M -&gt; QDOS -&gt; MS- DOS -&gt; Windows    /  Unix -&gt; System -&gt; Mac OS -&gt; ios</h4><p><strong>总结历史</strong></p><ul><li>仍然是程序执行，多进程，程序执行带动其他设备使用的基本结构</li><li>但用户的体验感更受重视：各种文件、编程环境、图形界面</li></ul><p>至此操作系统两大基本主体伴随着操作系统历史更加的清晰！</p><p><strong>参考资料</strong></p><ul><li><a href="https://www.bilibili.com/video/BV1d4411v7u7" target="_blank" rel="noopener">哈工大李治军操作系统</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;计算机是如何工作的&quot;&gt;&lt;a href=&quot;#计算机是如何工作的&quot; class=&quot;headerlink&quot; title=&quot;计算机是如何工作的&quot;&gt;&lt;/a&gt;计算机是如何工作的&lt;/h2&gt;&lt;h3 id=&quot;从白纸到图灵机&quot;&gt;&lt;a href=&quot;#从白纸到图灵机&quot; class=&quot;headerlink&quot; title=&quot;从白纸到图灵机&quot;&gt;&lt;/a&gt;&lt;strong&gt;从白纸到图灵机&lt;/strong&gt;&lt;/h3&gt;&lt;p&gt;计算机是如何工作的说到底就是一个&lt;strong&gt;计算模型&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;1936年，英国数学家A.C.图灵提出了一种模型，通过纸带模拟人使用笔在纸上进行计算。即在纸带上读入3，在纸带上读入2，在纸带上读入 +，控制器查表知道是5，接着在纸带上写下5；&lt;strong&gt;此时图灵机只能进行加法运算&lt;/strong&gt;。&lt;/p&gt;</summary>
    
    
    
    
    <category term="操作系统" scheme="http://yoursite.com/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
</feed>
