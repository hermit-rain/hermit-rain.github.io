<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>鑫宇的个人博客</title>
  
  
  <link href="http://yoursite.com/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2021-06-09T11:08:43.567Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>rain</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>计算机网络概述</title>
    <link href="http://yoursite.com/2021/06/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    <id>http://yoursite.com/2021/06/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/</id>
    <published>2021-06-07T05:40:28.000Z</published>
    <updated>2021-06-09T11:08:43.567Z</updated>
    
    <content type="html"><![CDATA[<h1 id="协议层次及服务类型"><a href="#协议层次及服务类型" class="headerlink" title="协议层次及服务类型"></a>协议层次及服务类型</h1><h2 id="OSI-七层模型"><a href="#OSI-七层模型" class="headerlink" title="OSI 七层模型"></a>OSI 七层模型</h2><p>OSI 模型全称为开放式通信系统互连参考模型，是国际标准化组织 ( ISO ) 提出的一个试图使各种计算机在世界范围内互连为网络的标准框架。OSI 将计算机网络体系结构划分为七层，每一层实现各自的功能和协议，并完成与相邻层的接口通信。OSI 的服务定义详细说明了各层所提供的服务。某一层的服务就是该层及其下各层的一种能力，它通过接口提供给更高一层。各层所提供的服务与这些服务是怎么实现的无关。OSI参考模型并没有提供一个可以实现的方法，只是描述了一些概念，用来协调进程间通信标准的制定。即OSI参考模型并不是一个标准，而是一个在制定标准时所使用的概念模型框架。</p><a id="more"></a><p><img src="/2021/06/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/1.png" alt="1"></p><ul><li>物理层：机械、电子、定时接口通信信道上的原始比特流传输 -<strong>-比特(Bit)</strong></li><li>数据链路层：物理寻址、同时将原始比特流变成逻辑传输路线–<strong>帧(Frame)</strong></li><li>网络层：控制子网的运行，如逻辑编址、分组传输、路由选择–<strong>分组、数据包(Packet)</strong></li><li>传输层：将数据进行分割，并将这些数据交给网络层且保证这些数据段有效的到达对端 –<strong>数据段(Segment)</strong> </li><li>会话层：不同机器上的用户之间建立及管理会话 –<strong>数据(data)</strong></li><li>表示层：信息的语法语义以及它们的关系，如加密、解密、转换翻译、压缩解压缩 –<strong>数据(data)</strong></li><li>应用层 ：定义了应用进程之间的交互规则，通过不同的应用层协议为不同的网络应用提供服务 –<strong>消息/报文(message)</strong></li></ul><p><strong>注解</strong></p><ol><li><strong>物理层</strong>：首先要解决两台物理机之间的通信需求，具体就是机器A往机器B发送比特流，机器B能收到这些比特流。物理层主要定义了物理设备的标准，如网线的类型、光纤的接口类型、各种传输介质的传输速率等，主要作用是传输比特流，即 01010二进制数据，将它们转化成电流强弱来进行传输，到达目的主机后再转化成 010101的机器码，即数模转换与模数转换。网卡就工作在这一层。</li><li><strong>数据链路层</strong>：在传输比特流的过程中会产生差错、数据传输不完整的可能，因此数据链路层应运而生。数据链路层定义了如何格式化数据以进行传输，以及如何控制对物理介质的访问。通常还提供错误检测和纠正以确保数据传输的可靠性。本层将比特数据组成了帧，其中交换机工作在这一层，将帧解码并根据帧中包含的信息把数据发送到正确的接收方。</li><li><strong>网络层</strong>：随着网络节点的不断增多，点对点通信时是需要经过多个节点的。那么如何找到最佳节点、如何选择最佳路径便成为了首要的需求，此时便有了网络层。网络层的首要功能是将网络地址翻译成对应的物理地址、并决定如何将数据从发送方路由到接收方。网络层通过综合考虑发送优先权、网络拥赛程度、服务质量以及可选路由的花费来决定从一个网络节点A到另一个网络中节点B的最佳路径。由于网络层处理并智能指导数据发送、 路由选择网络各段，所以路由器属于网络层，此层的数据我们成为数据包。</li><li><strong>传输层</strong>：随着网络通信需求的进一步加大，通信过程中需要发送大量的数据，如海量的文件传输，可能需要很长时间，而网络在通信的过程中会中断好多次，此时为了保证传输大量文件时的准确性，需要对发送方发送出去的数据进行切片，切割为一个个的段落即 <strong>Segment</strong>进行发送。那么便出现了数据段丢失、要不要重传、每个段落要按照顺序到达嘛等问题。传输层解决了主机间的数据传输、传输质量等问题。该层为OSI模型中最重要的一层。传输协议同时进行流量控制，或是基于接收方可接收数据的快慢程度规定适当的发送速率。除此以外传输层按照网络能处理的最大尺寸将数据分割成较小的数据片。同时对每一个数据片安排一个序列号，以便数据到达接收方节点的传输层时能以正确的顺序重组，该过程称为排序。</li><li><strong>会话层</strong>：现在我们已经保证给正确的计算机发送正确的封装过后的信息，但是用户的体验并不要。因为每次都需要我们手动的去调用TCP打包、然后调用IP协议去找路由。所以我们要建立一个自动收发包，自动寻址的功能，于是便有了会话层。会话层的作用即建立和管理应用程序之间的通信。</li><li><strong>表示层</strong>：现在我们可以保证了应用程序可以自动的收发包和寻址，但是对于不同系统之间的通信仍然存在语法的问题。例如用Linux给 windows发包，exe文件并不能在Linux下执行，shell 在windows下也不能执行，此时便出现了表示层。表示层帮我们解决了不同系统间的通信语法问题，在表示层数据将按照网络能理解的方案进行格式化，这种格式化也因所使用的网络的类型不同而不同。</li><li><strong>应用层</strong>：此时虽然发送方知道自己发送的是什么，转换成字节数组后有多长，但是接收方并不知道，所以应用层的网络协议诞生了，应用层规定发送方和接收方必须使用一个固定长度的消息头，消息头必须使用某种固定的组成，而且消息头中必须记录消息体的长度等一系列信息，以方便接收方能够正确的解析发送方发送过来的数据。</li></ol><h2 id="TCP-IP参考模型"><a href="#TCP-IP参考模型" class="headerlink" title="TCP/IP参考模型"></a>TCP/IP参考模型</h2><p>TCP/IP参考模型首先由ARPANET所使用的网络体系结构，后来该结构被美国国防部用来做为计算机网络的标准。在其推动下，市场上绝大多数的厂商也以该标准为主，用以商用。基于 TCP/IP 的参考模型将协议分成四个层次，如上图所示，它们分别是：网络接口层、网络层、传输层、和应用层。</p><p><strong>注解</strong></p><ol><li><p>应用层：TCP/IP 模型将 OSI 参考模型中的会话层、表示层和应用层的功能合并到一个应用层实现，通过不同的应用层协议为不同的应用提供服务。例如：FTP、Telnet、DNS、SMTP 等。</p></li><li><p>传输层：该层对应于 OSI 参考模型的传输层，为上层实体提供源端到对端主机的通信功能。传输层定义了两个主要协议：传输控制协议（TCP）和用户数据报协议（UDP）。其中面向连接的 TCP 协议保证了数据的传输可靠性，面向无连接的 UDP 协议能够实现数据包简单、快速地传输。</p></li><li><p>网际互联层：网际互联层对应 OSI 参考模型的网络层，主要负责相同或不同网络中计算机之间的通信。在网际互联层， IP 协议提供的是一个不可靠、无连接的数据报传递服务。该协议实现两个基本功能：寻址和分段。根据数据报报头中的目的地址将数据传送到目的地址，在这个过程中 IP 负责选择传送路线。除了 IP 协议外，该层另外两个主要协议是互联网组管理协议（IGMP）和互联网控制报文协议（ICMP）。</p></li><li><p>网络接入层：网络接入层的功能对应于 OSI 参考模型中的物理层和数据链路层，它负责监视数据在主机和网络之间的交换。事实上，TCP/IP 并未真正描述这一层的实现，而由参与互连的各网络使用自己的物理层和数据链路层协议，然后与 TCP/IP 的网络接入层进行连接，因此具体的实现方法将随着网络类型的不同而有所差异。</p></li></ol><h2 id="TCP-IP-五层参考模型"><a href="#TCP-IP-五层参考模型" class="headerlink" title="TCP/IP 五层参考模型"></a>TCP/IP 五层参考模型</h2><p>五层体系的协议结构是综合了 OSI 和 TCP/IP 优点的一种协议，包括<strong>应用层、传输层、网络层、数据链路层和物理层</strong>。五层协议的体系结构只是为介绍网络原理而设计的，实际应用还是 TCP/IP 四层体系结构。</p><h2 id="比较-TCP-IP-参考模型与-OSI-参考模型"><a href="#比较-TCP-IP-参考模型与-OSI-参考模型" class="headerlink" title="比较 TCP/IP 参考模型与 OSI 参考模型"></a>比较 TCP/IP 参考模型与 OSI 参考模型</h2><p>共同点：</p><ul><li>都采用了层次结构的概念</li><li>都能够提供面向连接和无连接的通信服务机制</li></ul><p>不同点：</p><ul><li>OSI 采用了七层模型，而 TCP/IP 是四层</li><li>OSI 是一个在协议开发前设计的、有清晰概念的模型；TCP/IP 是先有协议集然后建立的、事实上得到广泛应用的弱模型，功能描述和实现细节混在一起</li><li>TCP/IP 一开始就提出面向连接和无连接服务，而 OSI 一开始只强调面向连接服务，直到很晚才开始制定无连接的服务标准。</li></ul><h2 id="数据如何在各层之间传输【数据的封装过程】"><a href="#数据如何在各层之间传输【数据的封装过程】" class="headerlink" title="数据如何在各层之间传输【数据的封装过程】"></a>数据如何在各层之间传输【数据的封装过程】</h2><p>在发送主机端，一个应用层报文被传送到运输层。在最简单的情况下，运输层收取到报文并附上附加信息，该首部将被接收端的运输层使用。应用层报文和运输层首部信息一道构成了运输层报文段。附加的信息可能包括：允许接收端运输层向上向适当的应用程序交付报文的信息以及差错检测位信息。该信息让接收端能够判断报文中的比特是否在途中已被改变。运输层则向网络层传递该报文段，网络层增加了如源和目的端系统地址等网络层首部信息，生成了网络层数据报。该数据报接下来被传递给链路层，在数据链路层数据包添加发送端 MAC 地址和接收端 MAC 地址后被封装成数据帧，在物理层数据帧被封装成比特流，之后通过传输介质传送到对端。</p><img src="/2021/06/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/3.png" alt="3" style="zoom:80%;"><h1 id="TCP-IP-协议群"><a href="#TCP-IP-协议群" class="headerlink" title="TCP/IP 协议群"></a>TCP/IP 协议群</h1><table><thead><tr><th align="left">OSI 七层概念模型</th><th align="center">TCP/IP 四层参考模型</th><th>对应的网络协议</th></tr></thead><tbody><tr><td align="left">应用层（Application</td><td align="center"></td><td>HTTP, TFTP, FTP, NFS, WAIS, SMTP, Telnet, DNS, SNMP</td></tr><tr><td align="left">表示层（Presentation）</td><td align="center">应用层</td><td>TIFF, GIF, JPEG, PICT</td></tr><tr><td align="left">会话层（Session）</td><td align="center"></td><td>RPC, SQL, NFS, NetBIOS, names, AppleTalk</td></tr><tr><td align="left">传输层（Transport)</td><td align="center">传输层</td><td>TCP, UDP</td></tr><tr><td align="left">网络层（Network）</td><td align="center">网络层</td><td>IP, ICMP, ARP, RARP, RIP, IPX</td></tr><tr><td align="left">数据链路层（Data Link）</td><td align="center"></td><td>FDDI, Frame Relay, HDLC, SLIP, PPP</td></tr><tr><td align="left">物理层（Physical）</td><td align="center">网络接口层</td><td>EIA/TIA-232, EIA/TIA-499, V.35, 802.3</td></tr></tbody></table><p><strong>各层的常见协议详解如下：</strong></p><table><thead><tr><th align="center"><strong>协议</strong></th><th><strong>作用</strong></th></tr></thead><tbody><tr><td align="center"><strong>HTTP</strong></td><td>超文本传输协议（HyperText Transfer Protocol）</td></tr><tr><td align="center">FTP</td><td>文件传输协议（File Transfer Protocol）用于在客户端和服务器之间进行文件传输</td></tr><tr><td align="center">SMTP</td><td>简单邮件传输协议（Simple Mail Transfer Protocol）是一个在网络上传输电子邮件的标准</td></tr><tr><td align="center">DNS</td><td>域名系统（Domain Name System）是域名和 IP 地址相互映射的分布式数据库</td></tr><tr><td align="center">SSH</td><td>安全外壳协议（Secure Shell）是一种加密的网络传输协议，可在不安全的网络中为网络服务提供安全的传输环境</td></tr><tr><td align="center">DHCP</td><td>动态主机配置协议（Dynamic Host Configuration Protocol）的主要作用是集中管理、动态分配 IP 地址提升地址的使用率</td></tr><tr><td align="center"><strong>TCP</strong></td><td>传输控制协议（Transmission Control Protocol）是一种面向连接的、可靠的、基于字节流的传输层通信协议</td></tr><tr><td align="center">UDP</td><td>用户数据报协议（User Datagram Protocol）是一个简单的、无连接的、不可靠的、面向数据报的通信协议</td></tr><tr><td align="center"><strong>IP</strong></td><td>网际协议（Internet Protocol）是用于分组交换数据网络的一种协议，功能包括寻址、路由、尽最大努力交付数据包</td></tr><tr><td align="center">ICMP</td><td>互联网控制消息协议（Internet Control Message Protocol）用于返回通信环境的错误消息。traceroute 和 ping 都是基于 ICMP 消息实现的，traceroute 是通过发送含有特殊 TTL 的包，然后接收 ICMP 超时消息和目标不可达消息来实现的；ping 则是用 ICMP 的“Echo request (8)”和“Echo reply (0)”消息来实现的</td></tr><tr><td align="center">IGMP</td><td>因特网组管理协议（Internet Group Management Protocol ）管理 IP 协议多播组成员</td></tr><tr><td align="center">RIP</td><td>路由信息协议（Routing Information Protocol）是一种内部网关协议（IGP），是距离向量路由协议的一种实现</td></tr><tr><td align="center">OSFP</td><td>开放式最短路径优先（Open Shortest Path First）是一种内部网关协议（IGP），使用 Dijkstra 算法计算最短路径，是链路状态路由协议的一种实现</td></tr><tr><td align="center">BGP</td><td>边界网关协议（Border Gateway Protocol）是互联网上一个核心的去中心化自治路由协议，属于矢量路由协议。BGP 用于互联网上，将自治系统视作一个整体；每个自治系统使用 IGP（代表实现有 RIP 和 OSPF）进行路由</td></tr><tr><td align="center"><strong>ARP*</strong></td><td>地址解析协议（Address Resolution Protocol）通过 IP 寻找 MAC 地址</td></tr><tr><td align="center">ARQ</td><td>自动重传请求（Automatic Repeat-reQuest）是一种错误纠正协议</td></tr><tr><td align="center">IEEE802</td><td>IEEE 802 指 IEEE 标准中关于局域网和城域网的一系列标准，其中最广泛使用的有以太网、令牌环、无线局域网等</td></tr></tbody></table><h1 id="相关设备"><a href="#相关设备" class="headerlink" title="相关设备"></a>相关设备</h1><ul><li>集线器（Hub）是<strong>物理层</strong>的硬件，连接所有的线路，广播所有信息</li><li>网桥（Bridge）是<strong>数据链路层</strong>的硬件。网桥隔离两个端口，不同的端口形成单独的冲突域，减少网内冲突。网桥在不同或相同类型的 LAN 之间存储并转发数据帧，根据 MAC 头部来决定转发端口，显然是数据链路层的设备</li><li>交换机（Switch）是<strong>数据链路层</strong>的硬件，相当于多端口的网桥。交换机内部存储 MAC 表，只会将数据帧发送到指定的目的地址</li><li>路由器（Router）是<strong>网络层</strong>的硬件，根据 IP 地址进行寻址，不同子网间的数据传输隔离</li></ul><h1 id="计算机网络的性能指标"><a href="#计算机网络的性能指标" class="headerlink" title="计算机网络的性能指标"></a>计算机网络的性能指标</h1><ul><li>速率：比特（bit）是计算机中数据量的单位，也是信息论中使用的信息量的单位。速率的单位是 b/s，或kb/s, Mb/s, Gb/s 等</li><li>带宽 ：“带宽”是数字信道所能传送的“最高数据率”，单位是“比特每秒”，或 b/s (bit/s)。 </li><li>吞吐量：表示在单位时间内通过某个网络（或信道、接口）的数据量，吞吐量更经常地用于对现实世界中的网络的一种测量，以便知道实际上到底有多少数据量能够通过网络。吞吐量受网络的带宽或网络的额定速率的限制。  </li><li>传输时延：(发送时延 )发送数据时，数据块从结点进入到传输媒体所需要的时间。也就是从发送数据帧的第一个比特算起，到该帧的最后一个比特发送完毕所需的时间。 </li><li>传播时延：电磁波在信道中需要传播一定的距离而花费的时间。 </li><li>处理时延：交换结点为存储转发而进行一些必要的处理所花费的时间。 </li><li>排队时延：结点缓存队列中分组排队所经历的时延。排队时延的长短往往取决于网络中当时的通信量；</li><li>总时延：数据经历的总时延就是发送时延、传播时延、处理时延和排队时延之和。</li></ul><p><strong>参考资料</strong></p><ul><li><a href="https://leetcode-cn.com/leetbook/read/networks-interview-highlights/ekjhp7/" target="_blank" rel="noopener">力扣 (LeetCode)</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;协议层次及服务类型&quot;&gt;&lt;a href=&quot;#协议层次及服务类型&quot; class=&quot;headerlink&quot; title=&quot;协议层次及服务类型&quot;&gt;&lt;/a&gt;协议层次及服务类型&lt;/h1&gt;&lt;h2 id=&quot;OSI-七层模型&quot;&gt;&lt;a href=&quot;#OSI-七层模型&quot; class=&quot;headerlink&quot; title=&quot;OSI 七层模型&quot;&gt;&lt;/a&gt;OSI 七层模型&lt;/h2&gt;&lt;p&gt;OSI 模型全称为开放式通信系统互连参考模型，是国际标准化组织 ( ISO ) 提出的一个试图使各种计算机在世界范围内互连为网络的标准框架。OSI 将计算机网络体系结构划分为七层，每一层实现各自的功能和协议，并完成与相邻层的接口通信。OSI 的服务定义详细说明了各层所提供的服务。某一层的服务就是该层及其下各层的一种能力，它通过接口提供给更高一层。各层所提供的服务与这些服务是怎么实现的无关。OSI参考模型并没有提供一个可以实现的方法，只是描述了一些概念，用来协调进程间通信标准的制定。即OSI参考模型并不是一个标准，而是一个在制定标准时所使用的概念模型框架。&lt;/p&gt;</summary>
    
    
    
    
    <category term="计网" scheme="http://yoursite.com/tags/%E8%AE%A1%E7%BD%91/"/>
    
  </entry>
  
  <entry>
    <title>java多线程基础</title>
    <link href="http://yoursite.com/2021/06/03/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%9F%BA%E7%A1%80/"/>
    <id>http://yoursite.com/2021/06/03/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%9F%BA%E7%A1%80/</id>
    <published>2021-06-03T06:38:51.000Z</published>
    <updated>2021-06-09T00:35:49.826Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、进程与线程"><a href="#一、进程与线程" class="headerlink" title="一、进程与线程"></a>一、进程与线程</h1><h2 id="1、程序、进程、线程"><a href="#1、程序、进程、线程" class="headerlink" title="1、程序、进程、线程"></a>1、程序、进程、线程</h2><p>程序：通过某种语言编写的一组指令 ，即一段<strong>静态的代码</strong>。</p><p>进程：程序的一次执行过程。将程序加载入内存分配空间并执行，该段静态代码程序便拥有了<strong>动态性</strong>。<strong>系统运行一个程序即是一个进程从创建，运行到消亡的过程</strong>。如下图所示，在 ubuntu中通过查看任务管理器的方式，我们就可以清楚看到 当前运行的进程。</p><a id="more"></a><img src="/2021/06/03/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%9F%BA%E7%A1%80/1.png" alt="1" style="zoom:80%;"><p><strong>线程概念的出现</strong></p><p>进程的出现使操作系统的并发成为了可能，但是随着计算机的普及，人们对<strong>实时性</strong>有了更高的要求。一个进程在一段时间只能做一件事情，如果一个进程有多个任务，只能逐一的去执行这些子任务。然而这些子任务之间并不存在顺序上的依赖，因此人们想到既然CPU可以按照时间片的方式轮流的切换执行不同的进程，那为什么不能也同样给进程子任务打上标签，让CPU按照更细的时间片来执行子任务呢？由于子任务共享内存等资源，因此隶属于同一个进程的子任务之间的切换是不需要切换页目录以使用新的地址空间的，这就为子任务的快速切换提供了可能。此时人们便提出了线程，让一个线程去执行子任务，这样一个进程就包括了多个线程，每个线程去负责独立的子任务，这样让进程的内部并发成为了可能，就实现了实时性的目的。</p><p>线程：<strong>进程进一步细化为线程，是一个程序内部的一条执行路径</strong>。也叫做轻量级进程。</p><p>如下图所示，在<code>CCleaner</code> 这一应用程序中，我们同时执行<code>Health Check</code> 以及 <code>Custom Clean</code> 两项子任务即为多线程。</p><img src="/2021/06/03/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%9F%BA%E7%A1%80/5.png" alt="5" style="zoom: 67%;"><h3 id="1-1-进程与线程的关系、区别"><a href="#1-1-进程与线程的关系、区别" class="headerlink" title="1.1 进程与线程的关系、区别"></a>1.1 进程与线程的关系、区别</h3><ul><li><strong>进程是资源分配的最小单位，线程是CPU调度的最小单位</strong></li><li>进程有独立的地址空间，相互不影响，多个线程只是进程的不同执行路径，共享其地址空间及资源</li><li>线程不能看做独立的应用，而进程可看作独立应用</li><li>多进程的程序比多线程的程序健壮</li><li>进程的切换比线程的切换开销大</li></ul><p><strong>注解</strong></p><p>进程是资源分配的基本单位，所有与该进程有关的资源都被记录在进程控制块PCB中，以表示该进程拥有或者正在使用这些资源。同时进程也是抢占处理机调度的单位，它拥有完整的虚拟内存和地址空间。当进程发生调度时，不同的进程拥有不同的虚拟地址空间，而同一进程中的不同线程共享同一地址空间。</p><p>线程与资源分配无关，它属于某一进程，并和该进程内的其他线程共享进程的资源。线程只由相关的堆、栈 寄存器、程序计数器和线程控制表TCB组成，其中寄存器用来存储线程内的局部变量，但并不存储其他线程的相关变量。每一个独立的线程有一个程序的入口、顺序执行序列以及程序的出口，但是线程并不能独立的执行，必须依存于某个应用程序中，由应用程序提供对多个线程的执行控制。</p><p>操作系统并没有将多个线程当作多个应用来实现进程的调度和管理以及资源的分配，而进程可作为独立的应用，拥有独立的内存空间。当一个进程崩溃后，在保护模式下并不会对其他进程产生影响，然而某个线程挂掉之后其所在的进程也会同样挂掉。</p><p>进程切换比线程切换开销大、耗费资源、效率差，对于要求同时进行，并且要求共享某些变量的并发操作只能用线程，不能用进程。</p><h3 id="1-2-java进程与线程"><a href="#1-2-java进程与线程" class="headerlink" title="1.2 java进程与线程"></a>1.2 java进程与线程</h3><ul><li>运行一个Java程序会产生一个Java进程，每一个Java进程至少包含三个线程：<code>main()</code> 主线程、<code>gc()</code> 线程、异常处理线程</li><li>每一个进程对应一个JVM实例，多个线程共享JVM里面的堆，每一个线程都有自己私有的栈</li><li>Java采用单线程编程模型，如果程序里面没有创建线程的话，只会自动创建一个线程-&gt;主线程</li><li>Java程序启动时，主线程立刻运行，在执行完各种子线程的关闭动作后才能完成执行</li></ul><p><strong>从 JVM 角度说进程和线程之间的关系</strong></p><img src="/2021/06/03/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%9F%BA%E7%A1%80/4.png" alt="4" style="zoom: 67%;"><p>如上图：一个进程中可以有多个线程，多个线程共享进程的<strong>堆</strong>和<strong>方法区 (JDK1.8 之后的元空间)资源，但是每个线程有自己的 程序计数器</strong>、<strong>虚拟机栈</strong> 和 <strong>本地方法栈</strong>。</p><h3 id="1-3-为什么要使用多线程"><a href="#1-3-为什么要使用多线程" class="headerlink" title="1.3 为什么要使用多线程"></a>1.3 为什么要使用多线程</h3><ul><li>提高计算机系统CPU的利用率</li><li>提高应用程序的响应，增强用户体验</li></ul><h3 id="1-4-使用多线程可能带来那些问题？"><a href="#1-4-使用多线程可能带来那些问题？" class="headerlink" title="1.4 使用多线程可能带来那些问题？"></a>1.4 使用多线程可能带来那些问题？</h3><p>并发编程的目的就是为了能提高程序的执行效率提高程序运行速度，但是并发编程可能会遇到很多问题。比如：内存泄漏、死锁、线程不安全等等</p><h2 id="2-单核CPU与多核CPU"><a href="#2-单核CPU与多核CPU" class="headerlink" title="2.单核CPU与多核CPU"></a>2.单核CPU与多核CPU</h2><ul><li>单核CPU：在一个时间单元内，只能执行一个线程的任务，其实是一种假的多线程。然而在单核的情况下，让用户看起来像同一时刻并发执行多个任务的原因是，CPU分配给单一任务执行的时间片很短、任务切换的频次高，造成所有任务都在并发执行的假象。</li><li>多核CPU：多核时代多线程主要是为了提高 CPU 利用率，同一时刻多个任务同时进行。</li></ul><h2 id="3-并行与并发"><a href="#3-并行与并发" class="headerlink" title="3.并行与并发"></a>3.并行与并发</h2><ul><li>并行：多个CPU同时执行多个任务</li><li>并发：单个CPU同时执行多个任务 (如：秒杀、抢票)</li></ul><h1 id="二、线程的创建及使用"><a href="#二、线程的创建及使用" class="headerlink" title="二、线程的创建及使用"></a>二、线程的创建及使用</h1><p><strong>创建线程四种方式</strong></p><ul><li>继承于<code>Thread</code>类</li><li>实现 <code>Runnable</code>接口</li><li>实现 <code>Callable</code> 接口的方式</li><li>线程池创建</li></ul><h2 id="1-继承于Thread类"><a href="#1-继承于Thread类" class="headerlink" title="1.继承于Thread类"></a>1.继承于Thread类</h2><ol><li>创建一个继承于<code>Thread</code>类的子类</li><li>重写 <code>Thread</code>类的 <code>run()</code>方法 ==&gt; 将此线程需要执行的操作声明在 <code>run()</code>中</li><li>创建<code>Thread</code>类的子类的对象 ==&gt; 主线程</li><li>通过此对象调用<code>start()</code>方法</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i % <span class="number">2</span> == <span class="number">0</span>) &#123;</span><br><span class="line">                System.out.println(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        MyThread t1 = <span class="keyword">new</span> MyThread();</span><br><span class="line">        t1.start();</span><br><span class="line">        <span class="comment">//如下操作在main线程中执行，此时主线程与子线程交替执行 同时抢占cpu资源</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i % <span class="number">2</span> != <span class="number">0</span>) &#123;</span><br><span class="line">                System.out.println(<span class="string">"main========&gt;hello world"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        MyThread t2 = <span class="keyword">new</span> MyThread();</span><br><span class="line">        t2.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-1-Thread类的常用方法"><a href="#1-1-Thread类的常用方法" class="headerlink" title="1.1 Thread类的常用方法"></a>1.1 Thread类的常用方法</h3><ul><li><code>start()</code> 启动当前线程；调用当前线程的run()</li><li><code>run()</code> 通常需要重写Thread类的此方法，将创建的线程要执行的操作声明在此方法中</li><li><code>currentThread()</code> 静态方法，返回执行当前代码的线程</li><li><code>getName()</code> 获取当前线程的名字</li><li><code>setName()</code> 设置当前线程的名字</li><li><code>getPriority()</code> 获取线程的优先级</li><li><code>setPriority()</code> 设置线程优先级</li><li><code>yield()</code> 释放当前线程CPU的执行权 =&gt; 很<strong>可能下一刻该线程又抢到CPU执行权</strong></li><li><code>join()</code> 在某个程序执行流程中调用其他线程的join()时，当前线程将会被阻塞，直到调用的线程执行完毕为止(插队)</li><li><code>sleep(long millitime)</code>让当前线程睡眠指定 <code>millitime</code>时间，此时该线程处于阻塞状态</li><li><code>stop()</code>  _中断线程 已经过时_：当执行此方法时，强制结束当前线程</li><li><code>interrupt()</code>  <em>目前使用的<strong>通知线程中断</strong>的方法</em> ：1. 如果线程处于被阻塞状态，那么线程将立即退出被阻塞状态，抛出一个<code>InterruptedException</code> 2. 如果线程处于正常活动状态，那么会将该线程的终端标志设置为true。被设置中断标志的线程将继续正常运行，不受影响。</li></ul><h3 id="1-2线程的优先级"><a href="#1-2线程的优先级" class="headerlink" title="1.2线程的优先级"></a>1.2线程的优先级</h3><ul><li><code>MIN_PRIORITY</code> = 1</li><li><code>NORM_PRIORITY</code>= 5</li><li><code>MAX_PRIORITY</code> = 10</li></ul><p>注意：高优先级的线程要抢占低优先级线程的cup执行权，只是概率上高优先级的线程有更高的概率被执行，并不意味着只有在高优先级的线程执行完后低线程的线程才执行。</p><h3 id="1-3-线程start-方法与-run-方法的区别"><a href="#1-3-线程start-方法与-run-方法的区别" class="headerlink" title="1.3 线程start() 方法与 run() 方法的区别"></a>1.3 线程start() 方法与 run() 方法的区别</h3><ul><li><code>start()</code>：启动当前线程并调用当前线程的<code>run()</code>。new 一个 Thread，线程进入了新建状态，调用 <code>start()</code>方法，会启动一个线程并使线程进入了就绪状态，当分配到时间片后就可以开始运行了。这是真正的多线程工作。同时一个线程对象只能调用一次<code>start()</code>方法，如果重复调用将抛出 异常<code>IllegalThreadStateException</code> 因为在执行完<code>start()</code>后该线程已经处于终止状态了。</li><li><code>run()</code>：直接执行 <code>run()</code> 方法，会把 <code>run()</code> 方法当成一个 main 线程下的普通方法去执行，并不会在某个线程中执行它，所以这并不是多线程工作。</li></ul><h3 id="1-4-如何给run-传参"><a href="#1-4-如何给run-传参" class="headerlink" title="1.4 如何给run()传参"></a>1.4 如何给<code>run()</code>传参</h3><ul><li>构造函数传参</li><li>成员变量传参</li><li>回调函数传参</li></ul><h2 id="2-实现-Runnable接口"><a href="#2-实现-Runnable接口" class="headerlink" title="2.实现 Runnable接口"></a>2.实现 Runnable接口</h2><ol><li>创建一个实现了<code>Runnable</code>接口的类</li><li>实现类去实现Runnable中的抽象方法 <code>run()</code></li><li>创建实现类的对象</li><li>将此对象作为参数传递到<code>Thread</code>类的构造器中，创建<code>Thread</code>类的对象</li><li>通过<code>Thread</code>类的对象调用<code>start()</code></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyThread2</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i % <span class="number">2</span> == <span class="number">0</span>) &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">"==&gt;"</span> + i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RunnableTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        MyThread2 myThread2 = <span class="keyword">new</span> MyThread2();</span><br><span class="line">        Thread t1 = <span class="keyword">new</span> Thread(myThread2);</span><br><span class="line">        t1.setName(<span class="string">"线程1"</span>);</span><br><span class="line">        t1.start();</span><br><span class="line">        Thread t2 = <span class="keyword">new</span> Thread(myThread2);</span><br><span class="line">        t2.setName(<span class="string">"线程2"</span>);</span><br><span class="line">        t2.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-1继承于Thread类与实现-Runnable接口-两种创建线程方式的联系与区别"><a href="#2-1继承于Thread类与实现-Runnable接口-两种创建线程方式的联系与区别" class="headerlink" title="2.1继承于Thread类与实现 Runnable接口 两种创建线程方式的联系与区别"></a>2.1继承于Thread类与实现 Runnable接口 两种创建线程方式的联系与区别</h3><ul><li><code>public class Thread implements Runnable</code> ==&gt; <code>Thread</code>类本身也实现了<code>Runnable</code>接口。都需要重写<code>run()</code>方法，将线程要执行的逻辑声明在<code>run()</code>中。</li><li>开发中我们优先选择实现 <code>Runnable</code>接口的方式：1.实现的方式没有类的单继承的局限性；2.实现的方式更适合来处理多个线程共享数据的情况</li></ul><h2 id="3-实现-Callable-接口的方式"><a href="#3-实现-Callable-接口的方式" class="headerlink" title="3.实现 Callable 接口的方式"></a>3.实现 Callable 接口的方式</h2><ol><li>创建一个实现了 <code>Callable</code> 接口的实现类</li><li>实现<code>call()</code>，将此线程需要执行的方法声明到<code>call()</code>中</li><li>创建<code>Callable</code>接口实现类的对象</li><li>将此<code>Callable</code>接口实现类的对象作为参数传递到<code>FutureTask</code>构造器中，创建<code>FutureTask</code> 的对象</li><li>将<code>FutureTask</code>对象作为参数传递到Thread类的构造器中，创建Thread类的对象并调用<code>start()</code>;</li><li>获取 <code>Callable</code>中的 <code>call</code>方法的返回值</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NumThread</span> <span class="keyword">implements</span> <span class="title">Callable</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i % <span class="number">2</span> == <span class="number">0</span>) &#123;</span><br><span class="line">                System.out.println(i);</span><br><span class="line">                sum += i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum; <span class="comment">//如果不需要返回值可以返回null      </span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CallableTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        NumThread numThread = <span class="keyword">new</span> NumThread();</span><br><span class="line">        FutureTask futureTask = <span class="keyword">new</span> FutureTask(numThread);</span><br><span class="line">        Thread t1 = <span class="keyword">new</span> Thread(futureTask);</span><br><span class="line">        t1.start(); <span class="comment">//new Thread(futureTask).start();</span></span><br><span class="line">        <span class="keyword">try</span> &#123; <span class="comment">//get()的返回值即为 FutureTask 构造器参数Callable实现类重写的call()的返回值</span></span><br><span class="line">            Object sum = futureTask.get();</span><br><span class="line">            System.out.println(sum);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ExecutionException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-1-如何实现处理线程的返回值"><a href="#3-1-如何实现处理线程的返回值" class="headerlink" title="3.1 如何实现处理线程的返回值"></a>3.1 如何实现处理线程的返回值</h3><ol><li>主线程等待法：当我们在<code>run()</code>方法中写返回值的时候，由于主线程往往比子线程先执行完毕所以根本无法接受子线程的返回值，所以我们可以在主线程中写循环等待算法，当子线程执行完毕后再执行主线程。缺点：当需要等待的变量很多则不合适，并且需要等待多久也不确定。</li><li>使用<code>Thread</code>类的<code>join()</code>方法阻塞当前线程等待子线程处理完毕后获取返回值。优点：是无需处理主线程循环等待算法，更精确；缺点：粒度不够细。</li><li>通过<code>Callable</code>接口实现：1. 通过<code>Future Task</code>  2. 线程池获取</li></ol><h3 id="3-2如何理解实现Callable接口的方式要比实现Runnable接口创建多线程的方式更好"><a href="#3-2如何理解实现Callable接口的方式要比实现Runnable接口创建多线程的方式更好" class="headerlink" title="3.2如何理解实现Callable接口的方式要比实现Runnable接口创建多线程的方式更好"></a>3.2如何理解实现<code>Callable</code>接口的方式要比实现<code>Runnable</code>接口创建多线程的方式更好</h3><ul><li><code>call()</code> 可以有返回值</li><li><code>call()</code> 可以抛出异常，被外面的异常捕获，获取异常的信息</li><li><code>Callable</code> 支持泛型</li></ul><h2 id="4-线程池"><a href="#4-线程池" class="headerlink" title="4. 线程池"></a>4. 线程池</h2><h3 id="4-1ThreadPoolExecutor-类"><a href="#4-1ThreadPoolExecutor-类" class="headerlink" title="4.1ThreadPoolExecutor 类"></a>4.1<code>ThreadPoolExecutor</code> 类</h3><p><strong><code>ThreadPoolExecutor</code> 3 个最重要的参数：</strong></p><ul><li><strong><code>corePoolSize</code> :</strong> 核心线程数线程数定义了最小可以同时运行的线程数量。</li><li><strong><code>maximumPoolSize</code> :</strong> 当队列中存放的任务达到队列容量的时候，当前可以同时运行的线程数量变为最大线程数。</li><li><strong><code>workQueue</code>:</strong> 当新任务来的时候会先判断当前运行的线程数量是否达到核心线程数，如果达到的话，新任务就会被存放在队列中。</li></ul><p><code>ThreadPoolExecutor</code>其他常见参数:</p><ul><li><strong><code>keepAliveTime</code></strong>:当线程池中的线程数量大于 <code>corePoolSize</code> 的时候，如果这时没有新的任务提交，核心线程外的线程不会立即销毁，而是会等待，直到等待的时间超过了 <code>keepAliveTime</code>才会被回收销毁；</li><li><strong><code>unit</code></strong> : <code>keepAliveTime</code> 参数的时间单位。</li><li><strong><code>threadFactory</code></strong> :executor 创建新线程的时候会用到。</li><li><strong><code>handler</code></strong> :饱和策略。</li></ul><p><strong>使用线程池创建线程</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NumberThread</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i % <span class="number">2</span> == <span class="number">0</span>) &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">":"</span> + i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NumberThread1</span> <span class="keyword">implements</span> <span class="title">Callable</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i % <span class="number">2</span> != <span class="number">0</span>) &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">":"</span> + i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PoolTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//提供指定线程数量的线程池</span></span><br><span class="line">        ExecutorService service = Executors.newFixedThreadPool(<span class="number">10</span>);</span><br><span class="line">        <span class="comment">//执行指定线程的操作，需要传入runnable接口或Callable接口实现类的对象</span></span><br><span class="line">        service.execute(<span class="keyword">new</span> NumberThread()); </span><br><span class="line">        service.submit(<span class="keyword">new</span> NumberThread1());  </span><br><span class="line">        <span class="comment">//关闭线程池</span></span><br><span class="line">        service.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-2为什么要使用线程池"><a href="#4-2为什么要使用线程池" class="headerlink" title="4.2为什么要使用线程池"></a>4.2为什么要使用线程池</h3><ul><li><strong>降低资源消耗</strong>。通过重复利用已创建的线程降低线程创建和销毁造成的消耗。</li><li><strong>提高响应速度</strong>。当任务到达时，任务可以不需要的等到线程创建就能立即执行。</li><li><strong>提高线程的可管理性</strong>。线程是稀缺资源，如果无限制的创建，不仅会消耗系统资源，还会降低系统的稳定性，使用线程池可以进行统一的分配，调优和监控。</li></ul><h3 id="4-3-执行-execute-方法和-submit-方法的区别"><a href="#4-3-执行-execute-方法和-submit-方法的区别" class="headerlink" title="4.3. 执行 execute()方法和 submit()方法的区别"></a>4.3. 执行 <code>execute()</code>方法和 <code>submit()</code>方法的区别</h3><ul><li><code>execute()</code>方法用于提交不需要返回值的任务，所以无法判断任务是否被线程池执行成功与否；</li><li><code>submit()</code>方法用于提交需要返回值的任务。线程池会返回一个 <code>Future</code> 类型的对象，通过这个 <code>Future</code> 对象可以判断任务是否执行成功，并且可以通过 <code>Future</code> 的 <code>get()</code>方法来获取返回值，<code>get()</code>方法会阻塞当前线程直到任务完成，而使用 <code>get（long timeout，TimeUnit unit）</code>方法则会阻塞当前线程一段时间后立即返回，这时候有可能任务没有执行完。</li></ul><h1 id="三、线程的生命周期及状态"><a href="#三、线程的生命周期及状态" class="headerlink" title="三、线程的生命周期及状态"></a>三、线程的生命周期及状态</h1><p> java 线程在运行的生命周期中一共有下面<strong>六种状态</strong>：</p><p><img src="/2021/06/03/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%9F%BA%E7%A1%80/6.png" alt="6"></p><p>线程在生命周期中并不是固定处于某一个状态而是<strong>随着代码的执行在不同状态之间切换</strong>。Java 线程状态变迁如下图所示：</p><img src="/2021/06/03/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%9F%BA%E7%A1%80/7.png" alt="7"><p>线程创建之后它将处于 <strong>NEW（新建）</strong> 状态，调用 <code>start()</code> 方法后开始运行，线程这时候处于 <strong>READY（可运行）</strong> 状态。可运行状态的线程获得了 CPU 时间片后就处于 <strong>RUNNING（运行）</strong> 状态。</p><p>当线程执行 <code>wait()</code>方法之后，线程进入 <strong>WAITING（等待）</strong> 状态。进入等待状态的线程不会被分配CPU执行时间，要等待被其他线程显式的唤醒后才能够返回到运行状态，而 <strong>TIME_WAITING(超时等待)</strong> 状态相当于在等待状态的基础上增加了超时限制，比如通过 <code>sleep（long millis）</code>方法或 <code>wait（long millis）</code>方法可以将 Java 线程置于 <strong>TIMED WAITING</strong> 状态。当超时时间到达后 Java 线程将会返回到 <strong>RUNNABLE</strong> 状态。</p><p>当线程调用同步方法时，在没有获取到锁的情况下，线程将会进入到 <strong>BLOCKED（阻塞）</strong> 状态。线程在执行完 <code>run()</code>方法之后将会进入到 <strong>TERMINATED（终止）</strong> 状态，并且一旦终止就不能再复生。</p><h1 id="四、线程的同步"><a href="#四、线程的同步" class="headerlink" title="四、线程的同步"></a>四、线程的同步</h1><h2 id="1-多线程的安全问题"><a href="#1-多线程的安全问题" class="headerlink" title="1.多线程的安全问题"></a>1.多线程的安全问题</h2><p><strong>问题的引出</strong></p><p>假设当前机场有100张票，我们创建3个线程来模拟三个窗口卖票</p><p><strong>代码实现</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Window</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> ticket = <span class="number">100</span>;</span><br><span class="line">    Object obj = <span class="keyword">new</span> Object();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (ticket &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">"卖票，票号为"</span> + ticket);</span><br><span class="line">                    ticket--;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WindowTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Window window = <span class="keyword">new</span> Window();</span><br><span class="line">        Thread w1 = <span class="keyword">new</span> Thread(window);</span><br><span class="line">        Thread w2 = <span class="keyword">new</span> Thread(window);</span><br><span class="line">        Thread w3 = <span class="keyword">new</span> Thread(window);</span><br><span class="line">        w1.setName(<span class="string">"窗口1"</span>);</span><br><span class="line">        w2.setName(<span class="string">"窗口2"</span>);</span><br><span class="line">        w3.setName(<span class="string">"窗口3"</span>);</span><br><span class="line">        w1.start();</span><br><span class="line">        w2.start();</span><br><span class="line">        w3.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>运行结果如下</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">窗口2卖票，票号为100</span><br><span class="line">窗口1卖票，票号为100</span><br><span class="line">窗口3卖票，票号为100</span><br><span class="line">窗口1卖票，票号为98</span><br><span class="line">窗口2卖票，票号为99</span><br><span class="line">窗口1卖票，票号为96</span><br><span class="line">......</span><br></pre></td></tr></table></figure><p><strong>问题分析</strong></p><p>通过上面运行结果我们发现，卖票的过程中出现了重票和错票的问题。原因是当某个线程操作卖票的过程中，尚未操作完成，其他的线程参与了进来，所以出现了多线程的安全问题。</p><p><strong>问题解决</strong></p><p>当一个线程w操作 ticket的时候其他的线程不允许操作进来，直到线程w操作完ticket其他的线程才允许操作ticket，即使线程 w 阻塞也不允许改变。这样便引出了线程同步的概念。</p><h2 id="2-通过同步机制来解决线程的同步问题"><a href="#2-通过同步机制来解决线程的同步问题" class="headerlink" title="2.通过同步机制来解决线程的同步问题"></a>2.通过同步机制来解决线程的同步问题</h2><p><strong>同步锁机制</strong></p><p>在并发操作中，当多个任务进行共享资源竞争时，为了防止出现线程同步的问题，就是当资源被一个任务使用时，在其上加锁。当资源被锁定后，其他任务在其被解锁前就无法访问它了，在其被解锁后，另一个任务才可以锁定并使用它。</p><p><strong>java中我们可以通过同步机制来解决线程的同步问题</strong></p><ul><li>同步代码块</li><li>同步方法</li><li>重入锁<code>ReentrantLock</code></li></ul><h3 id="2-1同步代码块"><a href="#2-1同步代码块" class="headerlink" title="2.1同步代码块"></a>2.1同步代码块</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">synchronized(同步监视器)&#123;</span><br><span class="line">   &#x2F;&#x2F;需要同步的代码</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>操作共享数据的代码即为同步的代码</li><li>共享数据==&gt;多个线程共同操作的数据</li><li>同步监视器 俗称==&gt; 锁 任何一个对象都可以充当锁  </li><li>多个线程必须共用同一把锁 (同步监视器声明的位置不可以在<code>run()</code>中)</li><li>在实现<code>Runnable</code>接口创建的多线程中可以考虑使用 <code>this</code>做同步监视器</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Window2</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> ticket = <span class="number">100</span>;</span><br><span class="line">    Object obj = <span class="keyword">new</span> Object();</span><br><span class="line">  </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (obj) &#123; <span class="comment">//此处的同步监视器可以是 this</span></span><br><span class="line">                <span class="keyword">if</span> (ticket &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">"卖票，票号为"</span> + ticket);</span><br><span class="line">                    ticket--;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-2-同步方法"><a href="#2-2-同步方法" class="headerlink" title="2.2 同步方法"></a>2.2 同步方法</h3><p>如果共享数据的代码完整的声明在一个方法中，我们不妨将此方法声明为同步的</p><ul><li>同步方法仍然涉及到同步监视器，只是不需要显示的声明</li><li>非静态的同步方法，同步器是 <code>this</code></li><li>静态的同步方法，同步器是 当前类本身</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Window3</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> ticket = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (ticket != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">//调用同步方法</span></span><br><span class="line">            show();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 创建同步方法</span></span><br><span class="line"><span class="comment">     * 注意：如果是通过extends继承类的方式创建同步方法需要用 static 修饰</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (ticket &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">10</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">"卖票，票号为"</span> + ticket);</span><br><span class="line">            ticket--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-3-重入锁ReentrantLock"><a href="#2-3-重入锁ReentrantLock" class="headerlink" title="2.3 重入锁ReentrantLock"></a>2.3 重入锁<code>ReentrantLock</code></h3><p><code>ReentrantLock</code>类实现了 <code>Lock</code> ，它拥有与 <code>synchronized</code> 相同的并发性和内存语义。在实现线程安全的控制中，<code>ReentrantLock</code>可以显式加锁、释放锁。</p><p><strong><code>ReentrantLock</code>常用方法</strong></p><ul><li><code>lock()</code> 获得锁</li><li><code>unlock()</code> 释放锁</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Window4</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> ticket = <span class="number">100</span>;</span><br><span class="line">    <span class="keyword">private</span> ReentrantLock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                lock.lock();</span><br><span class="line">                <span class="keyword">if</span> (ticket &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        Thread.sleep(<span class="number">100</span>);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">"售票-票号为"</span> + ticket);</span><br><span class="line">                    ticket--;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                lock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-4-synchronized-与-Lock-的区别"><a href="#2-4-synchronized-与-Lock-的区别" class="headerlink" title="2.4 synchronized 与 Lock 的区别"></a>2.4 <code>synchronized</code> 与 <code>Lock</code> 的区别</h3><ul><li>两者都可以解决线程的安全问题</li><li><code>Lock</code>是显式锁，手动开启和关闭锁；<code>synchronized</code>是隐式锁，出了作用域自动释放锁</li><li><code>Lock</code>只有代码块锁，<code>synchronized</code>有代码块锁和方法锁</li><li>使用<code>Lock</code>锁，JVM将花费较少的时间来调度线程，性能更好。并且具有 更好的扩展性</li></ul><h1 id="五、线程间通信"><a href="#五、线程间通信" class="headerlink" title="五、线程间通信"></a>五、线程间通信</h1><h2 id="1-锁池EntryList与等待池WaitSet"><a href="#1-锁池EntryList与等待池WaitSet" class="headerlink" title="1.锁池EntryList与等待池WaitSet"></a>1.锁池<code>EntryList</code>与等待池<code>WaitSet</code></h2><p><strong>锁池<code>EntryList</code></strong> ：假设线程A已经拥有了某个对象的锁，而其他线程B、C想要调用这个对象的某个<code>synchronized</code>方法（或者块），由于B、C线程在进入对象的<code>synchronized</code>方法（或者块）之前必须先获得该对象锁的拥有权，而恰巧该对象的所目前正被线程A所占用，此时B、C线程就会被阻塞，进入一个地方去等待锁的释放，这个地方就是该对象的锁池。</p><p><strong>等待池<code>WaitSet</code></strong>：假设线程A调用了某个对象的<code>wait()</code>方法，线程A就会释放该对象的锁，同时线程A就进入到了该对象的等待池中，进入到等待池中的线程不会去竞争该对象的锁</p><ul><li>锁池中的线程就会去竞争该对象的锁</li><li>优先级高的线程竞争到锁的概率就会变高</li><li>没有竞争到的线程就会留在锁池当中，不会进入到等待池当中</li><li>竞争到的线程就会运行直到执行完<code>synchronized</code>或者是遇到异常，然后释放锁</li><li>被<code>notify()</code>或<code>notifyAll()</code>唤醒的线程会进入到锁池当中</li></ul><h2 id="2-线程通信涉及的方法"><a href="#2-线程通信涉及的方法" class="headerlink" title="2.线程通信涉及的方法"></a>2.线程通信涉及的方法</h2><ul><li><code>wait()</code>：一旦执行此方法当前线程就进入阻塞状态，释放同步监视器，并进入到等待池中等待被唤醒</li><li><code>notify()</code> ：随机选取一个处于等待池中的线程进入锁池去竞争获取锁的机会</li><li><code>notifyAll()</code>：会让所有处于等待池的线程全部进入锁池去竞争获取锁的机会</li></ul><p><strong>注意</strong></p><p>三个方法执行线程通信时必须使用在同步代码块或同步方法中; 三个方法的调用者必须是 同步代码块或者同步方法的 同步监视器;三个方法都定义在 <code>java.lang.Object</code>中</p><h2 id="3-sleep-方法和wait-方法的区别"><a href="#3-sleep-方法和wait-方法的区别" class="headerlink" title="3. sleep()方法和wait() 方法的区别"></a>3. <code>sleep()</code>方法和<code>wait()</code> 方法的区别</h2><ul><li><code>sleep()</code> 是 <code>Thread</code> 类的方法；<code>wait()</code> 是 <code>Object</code> 类中定义的方法</li><li><code>sleep()</code> 方法可以在任何地方使用；<code>wait()</code> 只能在 <code>synchronized</code> 方法或者 <code>synchronized</code> 块中使用</li><li><strong><code>Thread.sleep</code> 只会让出 CPU，不会导致锁行为的改变；<code>Object.wait</code> 不仅会让出CPU，还会释放已经占有的同步资源锁</strong></li></ul><h2 id="4-实现线程间通信"><a href="#4-实现线程间通信" class="headerlink" title="4. 实现线程间通信"></a>4. 实现线程间通信</h2><p>实现两个线程交替打印 1 - 100</p><p><strong>代码实现</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Number</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> number = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">                notify();</span><br><span class="line">                <span class="keyword">if</span> (number &lt;= <span class="number">100</span>) &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        Thread.sleep(<span class="number">100</span>);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">":"</span> + number);</span><br><span class="line">                    number++;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        wait();</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Communication</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Number number = <span class="keyword">new</span> Number();</span><br><span class="line">        Thread t1 = <span class="keyword">new</span> Thread(number);</span><br><span class="line">        Thread t2 = <span class="keyword">new</span> Thread(number);</span><br><span class="line">        t1.setName(<span class="string">"线程1"</span>);</span><br><span class="line">        t2.setName(<span class="string">"线程2"</span>);</span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="5-线程死锁"><a href="#5-线程死锁" class="headerlink" title="5.线程死锁"></a>5.线程死锁</h2><h3 id="5-1什么是死锁"><a href="#5-1什么是死锁" class="headerlink" title="5.1什么是死锁"></a>5.1什么是死锁</h3><p>不同的线程分别占用对方需要的同步资源不放弃，都等待对方先放弃自己需要的同步资源，就形成了死锁</p><p>如下图所示，线程 A 持有资源 2，线程 B 持有资源 1，他们同时都想申请对方的资源，所以这两个线程就会互相等待而进入死锁状态。</p><p><img src="/2021/06/03/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%9F%BA%E7%A1%80/8.png" alt="8"></p><p>注意：出现死锁后，不会出现异常，不会出现提示，只是所有的线程都处于阻塞状态无法继续执行。</p><h3 id="5-2死锁演示"><a href="#5-2死锁演示" class="headerlink" title="5.2死锁演示"></a>5.2死锁演示</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DeadLockTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        StringBuffer strLock1 = <span class="keyword">new</span> StringBuffer();</span><br><span class="line">        StringBuffer strLock2 = <span class="keyword">new</span> StringBuffer();</span><br><span class="line">        <span class="comment">//线程1等待线程2释放 strLock2 ，而线程2等待线程1释放 strLock1 ===&gt;产生死锁</span></span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">synchronized</span> (strLock1) &#123;</span><br><span class="line">                    strLock1.append(<span class="string">"a"</span>);</span><br><span class="line">                    strLock2.append(<span class="string">"1"</span>);</span><br><span class="line">                    <span class="comment">//增加sleep()加大了产生死锁的可能</span></span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        Thread.sleep(<span class="number">100</span>);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">synchronized</span> (strLock2) &#123;</span><br><span class="line">                        strLock1.append(<span class="string">"b"</span>);</span><br><span class="line">                        strLock2.append(<span class="string">"2"</span>);</span><br><span class="line">                        System.out.println(strLock1);</span><br><span class="line">                        System.out.println(strLock2);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="string">"线程 1"</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">synchronized</span> (strLock2) &#123;</span><br><span class="line">                    strLock1.append(<span class="string">"c"</span>);</span><br><span class="line">                    strLock2.append(<span class="string">"3"</span>);</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        Thread.sleep(<span class="number">100</span>);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">synchronized</span> (strLock1) &#123;</span><br><span class="line">                        strLock1.append(<span class="string">"d"</span>);</span><br><span class="line">                        strLock2.append(<span class="string">"4"</span>);</span><br><span class="line">                        System.out.println(strLock1);</span><br><span class="line">                        System.out.println(strLock2);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="string">"线程 2"</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> <strong>参考资料</strong></p><ul><li><a href="https://github.com/Snailclimb/JavaGuide/blob/master/docs/java/multi-thread/2020最新Java并发基础常见面试题总结.md" target="_blank" rel="noopener">JavaGuide-java并发基础</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;一、进程与线程&quot;&gt;&lt;a href=&quot;#一、进程与线程&quot; class=&quot;headerlink&quot; title=&quot;一、进程与线程&quot;&gt;&lt;/a&gt;一、进程与线程&lt;/h1&gt;&lt;h2 id=&quot;1、程序、进程、线程&quot;&gt;&lt;a href=&quot;#1、程序、进程、线程&quot; class=&quot;headerlink&quot; title=&quot;1、程序、进程、线程&quot;&gt;&lt;/a&gt;1、程序、进程、线程&lt;/h2&gt;&lt;p&gt;程序：通过某种语言编写的一组指令 ，即一段&lt;strong&gt;静态的代码&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;进程：程序的一次执行过程。将程序加载入内存分配空间并执行，该段静态代码程序便拥有了&lt;strong&gt;动态性&lt;/strong&gt;。&lt;strong&gt;系统运行一个程序即是一个进程从创建，运行到消亡的过程&lt;/strong&gt;。如下图所示，在 ubuntu中通过查看任务管理器的方式，我们就可以清楚看到 当前运行的进程。&lt;/p&gt;</summary>
    
    
    
    
    <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>步入Linux的世界</title>
    <link href="http://yoursite.com/2021/05/26/%E6%AD%A5%E5%85%A5Linux%E7%9A%84%E4%B8%96%E7%95%8C/"/>
    <id>http://yoursite.com/2021/05/26/%E6%AD%A5%E5%85%A5Linux%E7%9A%84%E4%B8%96%E7%95%8C/</id>
    <published>2021-05-26T08:08:15.000Z</published>
    <updated>2021-06-02T12:56:22.442Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Linux-初步认识"><a href="#Linux-初步认识" class="headerlink" title="Linux 初步认识"></a>Linux 初步认识</h1><h2 id="Linux的千奇百怪的版本"><a href="#Linux的千奇百怪的版本" class="headerlink" title="Linux的千奇百怪的版本"></a>Linux的千奇百怪的版本</h2><p>目前世界上主流的操作系统 –&gt; Windows Linux Unix MacOS</p><p><strong>Linux 严格上来说只是操作系统内核</strong>，我们所说的Linux操作系统实质上是 “GNU/Linux”</p><p> <strong>“GNU/Linux”</strong> –&gt; GNU项目 + Linux kernel就可以组成一个类Unix的操作系统</p><p>Linux主要运行在服务器和其他大型平台上</p><p><strong>Linux发行版</strong> –&gt; 在Linux kernel 加上一些件组成,不同的组合就构成了不同的发行版 如 Debian Fedora OpenSUSE </p><a id="more"></a>  <img src="/2021/05/26/%E6%AD%A5%E5%85%A5Linux%E7%9A%84%E4%B8%96%E7%95%8C/Unix.png" alt="Unix" style="zoom: 67%;"><h1 id="Linux四大组成部分"><a href="#Linux四大组成部分" class="headerlink" title="Linux四大组成部分"></a>Linux四大组成部分</h1><ul><li>Linux Kernel 内核</li><li>GNU工具</li><li>GUI Desktop环境</li><li>Application </li></ul><h3 id="Linux-Kernel"><a href="#Linux-Kernel" class="headerlink" title="Linux Kernel"></a>Linux Kernel</h3><ol><li>进程管理</li><li>内存管理</li><li>文件管理 （不同的文件系统主要是<strong>文件的读写标准</strong>不同  如Linux -&gt; ext，ext2  Windows -&gt; FAT32 NTFS ）</li><li>硬件设备管理</li></ol><h3 id="GNU"><a href="#GNU" class="headerlink" title="GNU"></a>GNU</h3><p>GNU -&gt; 理查德·斯托曼 创建的一个组织 发起了自由软件运动</p><p>“linux” 最初只是一个内核，不像Unix 有一些软件，Linux Kernel 本身没有，所以GNU 模仿 Unix 同样为 Linux 写了一些必要的软件</p><p><strong>GNU核心</strong></p><p>1.coreutils: 核心工具软件包</p><ul><li>用来处理文件的工具</li><li>用来操作文本的工具</li><li>用来管理进程的工具</li></ul><p>2.Shell: 提供给用户使用的软件,用户拿它使用电脑，实现人机交互</p><ul><li>图形界面shell (GUI shell  -&gt;  Graphical User Interface shell ）</li><li>命令行式shell (CLI  shell  -&gt; Command Line Interface shell)</li></ul><p><strong>传统意义上的shell指的是命令行式的shell</strong>,GNU 是为 Linux 写了 CLS</p><p> <strong>常用的shell 种类</strong></p><ul><li>bash (linux 默认的shell )</li><li>zsh (比较庞大的一种shell)</li><li>tcsh (tcsh是csh的增强版，csh是具有c语言风格的一种shell)</li><li>oh-my-zsh (是一款社区驱动的命令行工具,它基于 zsh 命令行)</li></ul><h3 id="GUI"><a href="#GUI" class="headerlink" title="GUI"></a>GUI</h3><p>人们使用计算机的方式</p><ul><li>命令行壳层提供一个命令行界面（CLI）</li><li>图像壳层提供一个<strong>图形用户界面</strong>（GUI）</li></ul><p><strong>GUI的类型</strong></p><p>1.Xwindows，2.KDE(一种主流的桌面设计理念 如 Windows ，Mac Os)，3.GNOME，4.Unity (用于 Ubantu)</p><h1 id="Bash-shell"><a href="#Bash-shell" class="headerlink" title="Bash shell"></a>Bash shell</h1><h3 id="Linux常用命令搜索"><a href="#Linux常用命令搜索" class="headerlink" title="Linux常用命令搜索"></a><a href="https://wangchujiang.com/linux-command/" target="_blank" rel="noopener">Linux常用命令搜索</a></h3><p><strong>参考资料</strong></p><ul><li><a href="https://blog.csdn.net/qq_46207024/article/details/116431998#4Bash_shell_152" target="_blank" rel="noopener">★Bash shell命令</a></li><li><a href="https://www.bilibili.com/video/BV18U4y1W7av" target="_blank" rel="noopener">Frank步入Linux的现代方法</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;Linux-初步认识&quot;&gt;&lt;a href=&quot;#Linux-初步认识&quot; class=&quot;headerlink&quot; title=&quot;Linux 初步认识&quot;&gt;&lt;/a&gt;Linux 初步认识&lt;/h1&gt;&lt;h2 id=&quot;Linux的千奇百怪的版本&quot;&gt;&lt;a href=&quot;#Linux的千奇百怪的版本&quot; class=&quot;headerlink&quot; title=&quot;Linux的千奇百怪的版本&quot;&gt;&lt;/a&gt;Linux的千奇百怪的版本&lt;/h2&gt;&lt;p&gt;目前世界上主流的操作系统 –&amp;gt; Windows Linux Unix MacOS&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Linux 严格上来说只是操作系统内核&lt;/strong&gt;，我们所说的Linux操作系统实质上是 “GNU/Linux”&lt;/p&gt;
&lt;p&gt; &lt;strong&gt;“GNU/Linux”&lt;/strong&gt; –&amp;gt; GNU项目 + Linux kernel就可以组成一个类Unix的操作系统&lt;/p&gt;
&lt;p&gt;Linux主要运行在服务器和其他大型平台上&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Linux发行版&lt;/strong&gt; –&amp;gt; 在Linux kernel 加上一些件组成,不同的组合就构成了不同的发行版 如 Debian Fedora OpenSUSE &lt;/p&gt;</summary>
    
    
    
    
    <category term="linux" scheme="http://yoursite.com/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>系统调用的实现</title>
    <link href="http://yoursite.com/2021/05/23/%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%E7%9A%84%E5%AE%9E%E7%8E%B0/"/>
    <id>http://yoursite.com/2021/05/23/%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%E7%9A%84%E5%AE%9E%E7%8E%B0/</id>
    <published>2021-05-23T07:09:20.000Z</published>
    <updated>2021-06-02T12:56:16.634Z</updated>
    
    <content type="html"><![CDATA[<h2 id="操作系统的接口"><a href="#操作系统的接口" class="headerlink" title="操作系统的接口"></a>操作系统的接口</h2><p>接口即一些函数，操作系统为上层应用提供一种进入到内核中的手段</p><p>接口表现为函数调用又由系统提供，所以称为<strong>系统调用</strong></p><h3 id="操作系统向上连接的并不是用户而是应用程序"><a href="#操作系统向上连接的并不是用户而是应用程序" class="headerlink" title="操作系统向上连接的并不是用户而是应用程序"></a>操作系统向上连接的并不是用户而是应用程序</h3><p>接口是计算机系统中两个独立的部件进行信息交换的共享边界，应用程序与操作系统之间存在接口，操作系统和计算机硬件之间也存在接口。通过接口可以实现应用程序与操作系统之间的通信和操作系统与计算机硬件之间的通信。由此可见与操作系统相连接的并不是用户，而是应用程序。</p>  <a id="more"></a>  <h3 id="操作系统既然并不面向用户那么用户是如何使用操作系统的"><a href="#操作系统既然并不面向用户那么用户是如何使用操作系统的" class="headerlink" title="操作系统既然并不面向用户那么用户是如何使用操作系统的"></a>操作系统既然并不面向用户那么用户是如何使用操作系统的</h3><ul><li>命令行 (命令程序)</li><li>图形界面 （消息框架程序 + 消息处理程序）</li><li>应用程序</li></ul><h4 id="命令行"><a href="#命令行" class="headerlink" title="命令行"></a>命令行</h4><p>以Linux操作系统为例，当我们使用命令行在去执行hello world程序的时候，C语言代码中的printf函数会在Linux操作系统中生成gcc -o output output.c文件，然后通过shell命令去执行output.c文件，此时该文件会调用操作系统里的write函数，将printf里的字符串写到cmd命令行界面上。这里的write函数就是操作系统接口也叫系统调用。</p><h4 id="图形界面"><a href="#图形界面" class="headerlink" title="图形界面"></a>图形界面</h4><p>我们以图形化界面中的一个按钮举例。当鼠标点击按钮以后，硬件输入首先会进入一个系统消息队列，然后进入应用消息队列，此时应用消息程序会从消息队列中获得硬件输入的指令，应用消息程序中有WinMain消息循环函数，WinMain函数中有一个GetMassage函数，GetMassage函数从操作系统中获取系统调用，硬件输入的系统调用是OnOK()。在OnOK()中有fopen() 函数，printf() 函数，fclose() 函数，主要功能是获取硬件输入指令相应的信息，然后打印该信息最后关闭该信息。打印的信息作为OnOK()函数的返回值返回到getMassage函数，最后消息循环函数在处理这一硬件输入的循环过程结束，硬件输入的执行结果进入到消息队列中，最后返回给用户。</p><h3 id="一些常见的操作系统接口"><a href="#一些常见的操作系统接口" class="headerlink" title="一些常见的操作系统接口"></a>一些常见的操作系统接口</h3><p><strong>POSIX</strong>: Portable Operating System Interface of UNIX (IEEE 制定的一个标准族)</p><p>POSIX标准定义了操作系统应该为应用程序提供的接口标准，目的是为了增强程序的可移植性。</p><table><thead><tr><th align="center">分类</th><th align="center">POSIX 定义</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center"></td><td align="center">fork</td><td align="center">创建一个进程</td></tr><tr><td align="center"><strong>任务管理</strong></td><td align="center">execl</td><td align="center">运行一个可执行程序</td></tr><tr><td align="center"></td><td align="center">pthread_create</td><td align="center">创建一个线程</td></tr><tr><td align="center"></td><td align="center">open</td><td align="center">打开一个文件或目录</td></tr><tr><td align="center"><strong>文件系统</strong></td><td align="center">EACCES</td><td align="center">返回值：表示没有权限</td></tr><tr><td align="center"></td><td align="center">mode_tst_mode</td><td align="center">文件头结构：文件属性</td></tr></tbody></table><h2 id="系统调用的实现"><a href="#系统调用的实现" class="headerlink" title="系统调用的实现"></a>系统调用的实现</h2><p>实现一个 <strong>whoami</strong>  系统调用，一个放在操作系统内核中的字符串 ”I am cxy“ (系统引导时被载入的)被取出来并打印。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//假设该段为用户程序</span></span><br><span class="line">main()</span><br><span class="line">&#123;</span><br><span class="line">whoami();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//假设该段为内核代码</span></span><br><span class="line">whoami()</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="number">100</span>,<span class="number">8</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="string">"I am cxy"</span> <span class="comment">// 100</span></span><br></pre></td></tr></table></figure><p><strong>要求</strong></p><ul><li>不能jmp，不应该jmp  唉</li><li>凭什么不让我jmp 害</li><li>不jmp该怎么实现 呢</li></ul><h3 id="为什么不可以jmp"><a href="#为什么不可以jmp" class="headerlink" title="为什么不可以jmp"></a>为什么不可以jmp</h3><p>操作系统在内存中，应用程序也在内存中，想访问操作系统提供的功能为什么不直接跳进去？直接 mov 不行嘛？</p><p>no no no !!!</p><p>直接mov jmp 就成为了简单的函数调用。操作系统中存储着重要的信息，如root 的用户名和密码，如果可以轻松进入随便访问，那么root的用户名和密码就很可能被应用程序给<strong>捞</strong>上来，太不安全。所以绝对不可以jmp，mov 进入操作系统内部。</p><h3 id="为什么jmp不进去"><a href="#为什么jmp不进去" class="headerlink" title="为什么jmp不进去"></a>为什么jmp不进去</h3><p>特权环：将内核程序与用户程序<strong>隔离</strong>-&gt; 区分为 <strong>内核态 和用户态</strong> (一种处理器的硬件设计刚性的)</p><p>计算机对内存的使用是一段一段的，内核态可以访问任何数据，用户态不可以 访问内核态数据 -&gt; 由段寄存器实现</p><p>两个特殊的段寄存器</p><p>DPL ：目标内存段的特权级</p><p>CPL ：当前内存段的特权级</p><p>只有当 CPL &lt;= DPL 即 当前内存段的特权级小于等于目标内存段的特权级才能进入到目标内存段</p><img src="/2021/05/23/%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%E7%9A%84%E5%AE%9E%E7%8E%B0/1.png" alt="1" style="zoom:80%;"><p><strong>注解</strong></p><p>在操作系统初始化时，head.s执行时会针对内核态的代码和数据建立GDT表，对应的内核态的DPL为0 是初始化好的。当用户态执行的时候，启动一个用户程序，CS中的CPL = 3 (当操作系统初始化后推动用户态将CS的CPL置为3，之后就一直维持为3)。每次跳转或者mov 都要访问GDT表，当发现 CPL = 3 &gt; DPL = 0 时就直接挡住，根本不让你jmp mov ，所以也就无法通过 jmp、mov 进入内核。</p><h3 id="不jmp如何实现系统调用—中断"><a href="#不jmp如何实现系统调用—中断" class="headerlink" title="不jmp如何实现系统调用—中断"></a>不jmp如何实现系统调用—中断</h3><p>中断 -&gt; 硬件提供的“主动进入内核的方法” </p><p>中断是用户程序发起的调用内核代码的唯一方式</p><p>中断指令 int 0x80 -&gt; 操作系统初始化好的代码，只能从 int 0x80 这扇大门进入到操作系统内部 </p><p><strong>系统调用的核心</strong></p><ol><li>用户程序中包含一段含有int指令的代码</li><li>操作系统写中断处理，获取想调程序的编号</li><li>操作系统根据编号执行相应的代码</li></ol><h3 id="write-系统调用解析"><a href="#write-系统调用解析" class="headerlink" title="write()系统调用解析"></a>write()系统调用解析</h3><img src="/2021/05/23/%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%E7%9A%84%E5%AE%9E%E7%8E%B0/2.png" alt="2" style="zoom:80%;"><p>首先应用程序调用printf，在库函数中变成了printf</p><p>我们使用printf的写法是printf(“%d”,i); 但事实上printf()内部是调用了系统函数 write();</p><p><strong>write的函数头部</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// fd：要进行写操作的文件描述；buf：需要输出的缓冲区；count：最大输出字节计数</span></span><br><span class="line"><span class="function"><span class="keyword">ssize_t</span> <span class="title">write</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">const</span> <span class="keyword">void</span> *buf, <span class="keyword">size_t</span> count)</span></span>;</span><br></pre></td></tr></table></figure><p>我们可以发现，printf()函数的形参和write()的形参是不一样的。所以要想通过printf()调用write()的话，首先就需要库函数格式化输出，采用c语言的处理方式使其转化成符合write()函数的格式。</p><p><strong>在printf函数里面调用write</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;unisted.h&gt;</span></span></span><br><span class="line">_syscall3(<span class="keyword">int</span>, <span class="built_in">write</span>, <span class="keyword">int</span>, fd, <span class="keyword">const</span> <span class="keyword">char</span>* buf, <span class="keyword">off_t</span>, count)</span><br></pre></td></tr></table></figure><h4 id="syscall3-宏"><a href="#syscall3-宏" class="headerlink" title="_syscall3 宏"></a>_syscall3 宏</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _syscall3(type,name,atype,a,btype,b,ctype,c)\</span></span><br><span class="line">type name(atype a, btype b, ctype c) \</span><br><span class="line"><span class="comment">//内嵌汇编</span></span><br><span class="line">&#123; <span class="keyword">long</span> __res;\</span><br><span class="line"><span class="function">__asm__ <span class="title">volatile</span><span class="params">(“<span class="keyword">int</span> <span class="number">0x80</span>”:”=a”(__res):””(__NR_##name), <span class="comment">//执行中断处理函数 int0x80 输出 res 输入 __NR_writ </span></span></span></span><br><span class="line">”b”((long)(a)),”c”((long)(b)),“d”((long)(c)))); if(__res&gt;=0) return</span><br><span class="line">(type)__res; errno=-__res; <span class="keyword">return</span> <span class="number">-1</span>;&#125;</span><br></pre></td></tr></table></figure><p><strong>_syscall3 宏注解</strong></p><ul><li>可以看出在printf函数里面调用write其实是利用了_syscall3 这个宏, _syscall3 宏调用之后就是展开成上面的一段汇编代码。主要就是将宏展开代码中的type,name,atype,a,btype,b,ctype,c 替换成了int, write, int, fd, const char* buf, off_t, count。                              因此type name(atype a, btype b, ctype c) 就变成了int write(int fd,const char * buf, off_t count)；</li><li>展开的汇编代码一样会跟着变化，此时出现了中断代码 int 0x80, (该段代码为_syscall3 的核心代码)操作系统内核的大门即将打开。之前我们了解到在head.s里面会重新建立idt表，之后中断就会根据中断号查那个表，然会获得中断服务函数的入口地址。</li><li>”=a”(res):””(NR_##name) -&gt; :左边为输出右边为输入。<br>”“(<em>NR##name) name为之前传入的参数 write 所以该条指令就是将<strong>NR_write = 4 赋值给eax这个寄存器，</strong>NR_write称为系统调用号，就是根据它来区分不同的系统调用函数同时获得中断函数的入口地址。如在linux/inlcude/unistd.h中 # define <em>_NR_write 4<br>”=a”(</em></em> res) 为输出，将来要把eax赋给res</li><li>”b”((long)(a)),”c”((long)(b)),“d”((long)(c))就是把形参的a、b、c依次赋值给ebx、ecx、edx三个寄存器；输入完成之后就通过int 0x80这个中断号进入操作系统。</li><li>int 0x80这条指令执行完之后，eax中就会存放int 0x80的返回值，然后将这个返回值赋值给<strong>res，</strong>res就是int write()这个系统调用的返回值，至此write这个系统调用也就结束了。</li></ul><h4 id="int-0x80"><a href="#int-0x80" class="headerlink" title="int 0x80"></a>int 0x80</h4><p>int 0x80 的实现  -&gt; 通过<strong>set_system_gate 中断处理门</strong> 取出中断处理函数然后跳到那里去执行 </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sched_init</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123; set_system_gate(<span class="number">0x80</span>,&amp;system_call); &#125;</span><br></pre></td></tr></table></figure><p>int 0x80对应的中断处理函数就是system_call，init 代表初始化，0x80就是要用后面这个 system_call来处理。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">在linux/include/<span class="keyword">asm</span>/system.h中</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> set_system_gate(n, addr) \ <span class="comment">//n 中断处理号，addr 地址</span></span></span><br><span class="line">_set_gate(&amp;idt[n],<span class="number">15</span>,<span class="number">3</span>,addr); <span class="comment">//idt是中断向量表基址</span></span><br></pre></td></tr></table></figure><p>set_system_gate这个宏又调用了_set_gate这个宏</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">在linux/include/<span class="keyword">asm</span>/system.h中</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _set_gate(gate_addr, type, dpl, addr)\</span></span><br><span class="line">__asm__(“movw %%dx,%%ax\n\t” “movw %<span class="number">0</span>,%%dx\n\t”\</span><br><span class="line">“movl %%eax,%<span class="number">1</span>\n\t” “movl %%edx,%<span class="number">2</span>”:\</span><br><span class="line">:”i”((short)(<span class="number">0x8000</span>+(dpl&lt;&lt;<span class="number">13</span>)+type&lt;&lt;<span class="number">8</span>))),“o”(*(( \</span><br><span class="line"><span class="keyword">char</span>*)(gate_addr))),”o”(*(<span class="number">4</span>+(<span class="keyword">char</span>*)(gate_addr))),\</span><br><span class="line">“d”((<span class="keyword">char</span>*)(addr),”a”(<span class="number">0x00080000</span>))</span><br></pre></td></tr></table></figure><p>_set_gate这个宏建立了类似于下图的表格</p><p><img src="/2021/05/23/%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%E7%9A%84%E5%AE%9E%E7%8E%B0/3.png" alt="3"></p><p><strong>_set_gate的目的就是要改变特权级穿过特权环的隔离进入到内核</strong></p><p>用户态的程序如果要进入内核，必须使用0x80号中断，那么就必须先要进入idt表。用户态的CPL=3，且idt表的DPL故意设置成3，因此能够跳到idt表，跳到idt表中之后就能找到之后程序跳转的地方，也就是中断服务函数的起始地址，CS就是段选择符（8），ip就是”处理函数入口点偏移“。CS=8，IP =&amp;system_call就是跳到内核的system_call这个函数去执行；</p><p><strong>int 0x80 完整流程</strong></p><ul><li>初始化的时候0x80号中断的DPL设成3，让用户态的代码能跳进内核</li><li>进入内核后，设置CS = 8(CS 的最后两位为 00 所以 CPL 也就自然变成了0)，IP = &amp;system_call 来重置 PC指针</li><li>根据PC指针继续跳到 system_call 去执行</li><li>最后 int 0x80返回之后，CS最后两位再次变成3，变成用户态</li></ul><h4 id="system-call"><a href="#system-call" class="headerlink" title="system_call"></a>system_call</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">在linux/kernel/system_call.s中</span><br><span class="line">nr_system_calls=<span class="number">72</span></span><br><span class="line">.globl _system_call</span><br><span class="line">_system_call: cmpl $nr_system_calls<span class="number">-1</span>,%eax</span><br><span class="line">ja bad_sys_call</span><br><span class="line">push %ds push %es push %fs</span><br><span class="line">pushl %edx pushl %ecx pushl %ebx <span class="comment">//调用的参数</span></span><br><span class="line">movl $<span class="number">0x10</span>,%edx mov %dx,%ds mov %dx,%es <span class="comment">//内核数据</span></span><br><span class="line">movl $<span class="number">0x17</span>,%edx mov %dx,%fs <span class="comment">//fs可以找到用户数据</span></span><br><span class="line">call _sys_call_table(,%eax,<span class="number">4</span>) <span class="comment">//a(,%eax,4)=a+4*eax</span></span><br><span class="line">pushl %eax <span class="comment">//返回值压栈，留着ret_from_sys_call时用</span></span><br><span class="line">... <span class="comment">//其他代码</span></span><br><span class="line">ret_from_sys_call: popl %eax, 其他pop, iret</span><br></pre></td></tr></table></figure><p><strong>system_call注解</strong></p><ul><li>system_call 的核心代码为 call _sys_call_table(,%eax,4) -&gt;通过call 跳到另外一个地址去执行</li><li>_sys_call_table(,%eax,4) 为一种寻址方式 -&gt; _sys_call_table + 4 * %eax 等于相应的系统调用处理函数真正的入口地址</li><li>_sys_call_table-&gt;函数表 起始地址； 4 -&gt;每个系统调用占4个字节； eax -&gt; 系统调用号__NR_write 4</li></ul><h4 id="sys-call-table"><a href="#sys-call-table" class="headerlink" title="_sys_call_table"></a>_sys_call_table</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">在include/linux/sys.h中</span><br><span class="line">fn_ptr sys_call_table[]=</span><br><span class="line">&#123;sys_setup, sys_exit, sys_fork, sys_read, sys_write,</span><br><span class="line">...&#125;;</span><br><span class="line"></span><br><span class="line">在include/linux/sched.h中</span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">int</span> <span class="params">(fn_ptr*)</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><p><strong>_sys_call_table注解</strong></p><p>sys_call_table是一个fn_ptr类型的全局函数表，fn_ptr是一个函数指针，4个字节，这就是_sys_call_table+4*%eax  这里为什么要乘4的原因。查表然后就可以根据eax来知道要调用的真正中断服务函数的入口地址。此处 eax = __NR_write = 4, 找到下标4对应的函数即为 sys_write。所以 call _sys_call_table(,%eax,4) 就对应了 call sys_write 接着就真正开始执行系统函数 sys_write 了。</p><h4 id="write系统调用总结"><a href="#write系统调用总结" class="headerlink" title="write系统调用总结"></a>write系统调用总结</h4><p><strong>库函数printf -&gt; syscall3 -&gt; 库函数write -&gt; int 0x80 -&gt; system_call -&gt; sys_call_table -&gt; sys_write</strong></p><img src="/2021/05/23/%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%E7%9A%84%E5%AE%9E%E7%8E%B0/6.png" alt="6" style="zoom:80%;"><p>库函数printf 通过 _syscall3 这个宏来调用 write 函数，在 write 函数中调用 system_call 来处理 int 0x80, 在system_call 中调用 system_call_table 这个表知道要调用的真正中断服务函数的入口地址，再根据 eax 中存储的系统调用号就可以真正跳到sys_write这个系统函数去执行了。执行完成后输出返回值并跳回用户态至此write的系统调用结束。</p><h2 id="whoami-系统调用设计"><a href="#whoami-系统调用设计" class="headerlink" title="whoami  系统调用设计"></a><strong>whoami</strong>  系统调用设计</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//用户态代码</span></span><br><span class="line">main()</span><br><span class="line">&#123;</span><br><span class="line">eax = <span class="number">72</span>;</span><br><span class="line"><span class="keyword">int</span> <span class="number">0x80</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//中断处理</span></span><br><span class="line">system_call:</span><br><span class="line">_sys_call_table + eax * <span class="number">4</span>  <span class="comment">//sys_whoami() -&gt; 72</span></span><br><span class="line">call sys_whoami</span><br><span class="line"><span class="comment">//内核态代码 </span></span><br><span class="line">sys_whoami()</span><br><span class="line"> &#123;</span><br><span class="line"> printk(<span class="number">100</span>,<span class="number">8</span>);</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="string">"I am cxy"</span> <span class="comment">// 100地址处</span></span><br></pre></td></tr></table></figure><p>前面我们了解到，想要设计一个whoami() 系统调用，因为很不安全所以不允许jmp，此时用户态的CPL = 3，内核态代码DPL = 0,也根本跳不进来。我们要想设计一个系统调用就要必须通过操作系统硬件设计好的 int 0x80中断指令进入内核，所以我们自己设置系统调用号eax = 72 再通过int 0x80 进入到操作系统内部。那么此时我们用户态CPL = 3,  int 0x80 的DPL 也做成 3 ，就可以穿过接口了，一旦穿过去之后，CPL就会被置为0，然后就开始执行 system_call, 在 _sys_call_table中查表就调用了 sys_whoami(); 最终就真的进入到内核去执行sys_whoami()，这时候再用printk()将内存地址100 处的字符串 “I am cxy” 打印出来，故事就到这里结束了。</p><p><strong>参考资料</strong></p><ul><li><a href="https://www.bilibili.com/video/BV1d4411v7u7" target="_blank" rel="noopener">哈工大李治军操作系统</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;操作系统的接口&quot;&gt;&lt;a href=&quot;#操作系统的接口&quot; class=&quot;headerlink&quot; title=&quot;操作系统的接口&quot;&gt;&lt;/a&gt;操作系统的接口&lt;/h2&gt;&lt;p&gt;接口即一些函数，操作系统为上层应用提供一种进入到内核中的手段&lt;/p&gt;
&lt;p&gt;接口表现为函数调用又由系统提供，所以称为&lt;strong&gt;系统调用&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&quot;操作系统向上连接的并不是用户而是应用程序&quot;&gt;&lt;a href=&quot;#操作系统向上连接的并不是用户而是应用程序&quot; class=&quot;headerlink&quot; title=&quot;操作系统向上连接的并不是用户而是应用程序&quot;&gt;&lt;/a&gt;操作系统向上连接的并不是用户而是应用程序&lt;/h3&gt;&lt;p&gt;接口是计算机系统中两个独立的部件进行信息交换的共享边界，应用程序与操作系统之间存在接口，操作系统和计算机硬件之间也存在接口。通过接口可以实现应用程序与操作系统之间的通信和操作系统与计算机硬件之间的通信。由此可见与操作系统相连接的并不是用户，而是应用程序。&lt;/p&gt;</summary>
    
    
    
    
    <category term="操作系统" scheme="http://yoursite.com/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>操作系统的启动</title>
    <link href="http://yoursite.com/2021/05/20/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%90%AF%E5%8A%A8/"/>
    <id>http://yoursite.com/2021/05/20/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%90%AF%E5%8A%A8/</id>
    <published>2021-05-20T11:19:30.000Z</published>
    <updated>2021-06-02T12:56:04.172Z</updated>
    
    <content type="html"><![CDATA[<h2 id="打开电源那神秘的黑色背后发生着什么"><a href="#打开电源那神秘的黑色背后发生着什么" class="headerlink" title="打开电源那神秘的黑色背后发生着什么"></a>打开电源那神秘的黑色背后发生着什么</h2><ol><li>x86 PC刚开机时CPU处于实模式 （实模式即16bit，保护模式即32bit）</li><li>开始时，CS = 0xFFFF；IP = 0x0000；（CS-&gt; 段寄存器；IP-&gt;段内偏移; <strong>CS &lt;&lt; 4 + IP = 物理地址</strong>）</li><li>寻址 0xFFFF0(ROM BIOS 映射区)  （BIOS -&gt; Basic Input Output System；固化到内存地址为 0xFFFF0 处的一段代码）</li><li>检查RAM，键盘，显示器，软硬磁盘</li><li>将磁盘0磁道0扇区读入 0x7c00处 （0磁道0扇区为操作系统的引导扇区共 512byte）</li><li>设置CS = 0x07c0; IP = 0x0000;</li><li>寻址 0x7c00 开始执行操作系统引导扇区的代码</li></ol><a id="more"></a>  <p><strong>注解</strong></p><p>intel x86 PC机开机接通电源后，在内存0xFFFF0处固化了一段程序即 ROM BIOS ，由于计算机的工作原理是取指执行，如果内存中一片空白则无法进行取指执行，所以该段程序是由硬件已经做好的。刚一上电硬件自动设置 CS = 0xFFFF；IP = 0x0000；由于[CS &lt;&lt;4 + IP = 0xFFFF0] ，所以刚一上电就跳到了 BIOS区进行执行。执行该段固化好的代码-&gt; 1.检查RAM，键盘，显示器，软硬磁盘，2.将磁盘0磁道0扇区的代码读入到 0x7c00处 。然后更新 CS = 0x07c0; IP = 0x0000; 继续取指执行，寻址 0x7c00 开始执行操作系统引导扇区的代码。因此硬盘的第一个扇区上存放着开机后执行的第一段我们可以控制的程序。<strong>操作系统的故事从这里开始……</strong></p><h2 id="引导扇区代码-bootsect-s"><a href="#引导扇区代码-bootsect-s" class="headerlink" title="引导扇区代码 bootsect.s"></a>引导扇区代码 bootsect.s</h2><p><strong>为什么引导扇区的代码使用汇编</strong></p><p>在操作系统引导的过程中我们要保证有绝对的控制，使用汇编可以精准的变成机器指令去执行，而使用C语言则首先需要编译，在编译的过程中很可能会发生差错，没办法进行绝对的控制，就很可能发生死机的情况。</p><p><strong>bootsect核心代码</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">BOOTSEG = <span class="number">0x07c0</span></span><br><span class="line">INITSEG = <span class="number">0x9000</span></span><br><span class="line">SETUPSEG = <span class="number">0x9020</span></span><br><span class="line"></span><br><span class="line">entry start <span class="comment">//关键字entry告诉链接器“程序入口”</span></span><br><span class="line">start:</span><br><span class="line">    mov ax, #BOOTSEG mov ds, ax</span><br><span class="line">    mov ax, #INITSEG mov es, ax</span><br><span class="line">    mov cx, #<span class="number">256</span></span><br><span class="line">    sub si, si sub di,di</span><br><span class="line">    rep movw</span><br><span class="line">    jmpi go, INITSEG</span><br><span class="line"></span><br><span class="line">go: mov ax,cs <span class="comment">//cs=0x9000</span></span><br><span class="line">    mov ds,ax mov es,ax mov ss,ax mov sp,#<span class="number">0xff00</span></span><br><span class="line">load_setup: <span class="comment">//载入setup模块</span></span><br><span class="line">    mov dx,#<span class="number">0x0000</span> mov cx,#<span class="number">0x0002</span> mov bx,#<span class="number">0x0200</span></span><br><span class="line">    mov ax,#<span class="number">0x0200</span>+SETUPLEN <span class="keyword">int</span> <span class="number">0x13</span> <span class="comment">//BIOS中断</span></span><br><span class="line">    jnc ok_load_setup</span><br><span class="line">    mov dx,#<span class="number">0x0000</span></span><br><span class="line">    mov ax,#<span class="number">0x0000</span> <span class="comment">//复位</span></span><br><span class="line">    <span class="keyword">int</span> <span class="number">0x13</span></span><br><span class="line">    j load_setup <span class="comment">//重读</span></span><br></pre></td></tr></table></figure><ul><li>将磁盘上从第 2 到 5 的四个扇区构成的 setup 模块读入到了内存的0x90200 处；</li><li>然后打出一个 Logo；</li></ul><img src="/2021/05/20/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%90%AF%E5%8A%A8/1.png" alt="1" style="zoom:80%;"><p><strong>注解</strong></p><p>对于x86PC来说，bootsect  刚读进来是放在0x07c00这个位置，然后将其转移到0x90000这个位置，并继续执行；利用int 0x13中断，将操作系统的setup读入到0x90200开始的内存处；读入setup之后，bootsect 继续执行，在屏幕上显示开机logo “loading system…”，然后进入 read_it 继续读操作系统模块，并将控制权转移到setup中，执行setup中的内容。</p><h2 id="setup-s"><a href="#setup-s" class="headerlink" title="setup.s"></a>setup.s</h2><p><strong>setup-&gt;OS启动前的配置</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">SYSSEG = <span class="number">0x1000</span></span><br><span class="line"></span><br><span class="line">start: mov ax,          #INITSEG mov ds,ax mov ah,#<span class="number">0x03</span></span><br><span class="line">    <span class="keyword">xor</span> bh,bh <span class="keyword">int</span> <span class="number">0x10</span>  <span class="comment">//取光标位置dx mov [0],dx</span></span><br><span class="line">    mov ah,#<span class="number">0x88</span> <span class="keyword">int</span> <span class="number">0x15</span> mov [<span class="number">2</span>],ax ...</span><br><span class="line">    cli                 <span class="comment">//不允许中断</span></span><br><span class="line">    mov ax,             #<span class="number">0x0000</span> cld</span><br><span class="line">do_move: mov es,ax add ax,#<span class="number">0x1000</span></span><br><span class="line">    cmp ax,             #<span class="number">0x9000</span> jz end_move</span><br><span class="line">    mov ds,ax sub di,di</span><br><span class="line">    sub si,si</span><br><span class="line">    mov cx,             #<span class="number">0x8000</span></span><br><span class="line">    rep                 # 将system模块移到<span class="number">0</span>地址</span><br><span class="line">    movsw</span><br><span class="line">    jmp do_move</span><br></pre></td></tr></table></figure><ul><li>准备初始化参数 （将硬件参数存放到0x90000处）</li><li>将<strong>system操作系统主体模块</strong>移动到0地址处</li><li>临时建立GDT IDT表，<strong>jump 0，8</strong> 进入到保护模式下</li></ul><img src="/2021/05/20/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%90%AF%E5%8A%A8/2.png" alt="2" style="zoom: 80%;"><p><strong>注解</strong></p><p>操作系统是管理各种硬件的，要管理各种硬件就必须首先知道各种硬件参数。管理内存就要知道内存有多少，同时知道都被谁给占着，这就需要数据结构来存储这些信息。所以setup会获取各种硬件的信息并建立相应的数据结构来管理这些硬件。</p><p>CS是16bit寄存器，IP也是16bit的寄存器。CS&lt;&lt;4 + IP 最多只能形成一个 20 位地址放到地址总线上，所以最多只能寻址 <strong>1M</strong> 以内的内存。这对于现在的计算机是远远不够的。所以需要从实模式进入到保护模式下（1M -&gt; 4G）</p><p>16bit 模式和 32bit 模式的本质区别是 <strong>CPU的解释程序不同</strong></p><p>保护模式下的寻址方式不再是 CS&lt;&lt;4 + IP，而是根据<strong>CS(选择子) 查表 + IP</strong></p><h2 id="System"><a href="#System" class="headerlink" title="System"></a>System</h2><p>执行完bootsect与setup模块之后，接着跳到system操作系统的主体模块进行执行。</p><h3 id="head-s"><a href="#head-s" class="headerlink" title="head.s"></a>head.s</h3><p>head.s是system模块开始的第一个文件，存放在0地址处</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">stratup_32: movl $<span class="number">0x10</span>,%eax mov %ax,%ds mov %ax,%es</span><br><span class="line">    mov %as,%fs mov %as,%gs <span class="comment">//指向gdt的0x10项(数据段)</span></span><br><span class="line">    lss _stack_start,%esp <span class="comment">//设置栈(系统栈)</span></span><br><span class="line">    call setup_idt</span><br><span class="line">    call setup_gdt</span><br><span class="line">    xorl %eax,%eax</span><br><span class="line"><span class="number">1</span>:incl %eax</span><br><span class="line">    movl %eax,<span class="number">0x000000</span> cmpl %eax,<span class="number">0x100000</span></span><br><span class="line">    je <span class="number">1b</span> <span class="comment">//0地址处和1M地址处相同(A20没开启)，就死循环</span></span><br><span class="line">    jmp after_page_tables <span class="comment">//页表，什么东东?</span></span><br><span class="line">setup_idt: lea ignore_int,%edx</span><br><span class="line">    movl $<span class="number">0x00080000</span>,%eax movw %dx,%ax</span><br><span class="line">    lea _idt,%edi movl %eax,(%edi)</span><br></pre></td></tr></table></figure><ul><li>setup.s是进入保护模式，head.s是进入保护模式之后的初始化。</li><li>重新设置 GDT, IDT 表，重新开启A20地址线 （setup里设置的gdt与idt 是临时的，开启A20地址线后寻址范围就从1M变成了4G）</li><li>IDT表是中断函数表，从此int n 不再是DOS中断，而是在IDT表中找到中断函数的地址并执行。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">after_page_tables:</span><br><span class="line">    pushl $<span class="number">0</span> pushl $<span class="number">0</span> pushl $<span class="number">0</span> pushl $L6</span><br><span class="line">    pushl $_main jmp setup_paging</span><br><span class="line">L6: jmp L6</span><br><span class="line">setup_paging: 设置页表 ret</span><br></pre></td></tr></table></figure><ul><li>在前面开启20号地址线之后就jmp到after_page_tables这个标号处</li><li>在after_page_tables里面将main函数三个参数、L6、main函数的入口地址都压入栈中</li><li>在set_paging 执行完毕后，将ret到main() 函数执行</li></ul><p><strong>注解</strong></p><p>IDT,GDT 的查表都是硬件查表，都是硬件设计好的，目的就是为了速度快</p><p>head.s中使用的汇编和bootsect 及 setup的汇编不一样，head.s中使用的是32位的汇编代码，而bootsect及setup中使用的是16位的汇编代码。另外在操作系统的.c文件中还使用一种汇编为”内嵌汇编”。</p><h3 id="main-c"><a href="#main-c" class="headerlink" title="main.c"></a>main.c</h3><p><strong>main函数完成了各种硬件数据结构的初始化</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    mem_init();</span><br><span class="line">    trap_init();</span><br><span class="line">    blk_dev_init();</span><br><span class="line">    chr_dev_init();</span><br><span class="line">    tty_init();</span><br><span class="line">    time_init();</span><br><span class="line">    sched_init();</span><br><span class="line">    buffer_init();</span><br><span class="line">    hd_init();</span><br><span class="line">    floppy_init();</span><br><span class="line">    sti();</span><br><span class="line">    move_to_user_mode();</span><br><span class="line">    <span class="keyword">if</span>(!fork())&#123;init();&#125;   <span class="comment">// 这行永远不会退出</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>bootsect将操作系统从磁盘中读入进内存，setup获取一些硬件参数并进入到保护模式，head初始化一些gdt表，并初始化一些页表，之后跳到main函数，main中有一大堆init，完成对各种硬件数据结构的初始化。</p><p><strong>总体可以概括为两步</strong></p><ol><li>将操作系统读入到内存</li><li>初始化</li></ol><p>只有先将操作系统读入进内存后计算机才能进行取指执行</p><p>初始化是因为操作系统是管理计算机硬件的软件，要想管理硬件就先要对每一种硬件做出相应的数据结构。setup，head，main, mem-init 这些搭在一起就是为了 得到硬件参数，初始化关键的数据结构，为将来管理操作系统做准备。</p><p><strong>参考资料</strong></p><ul><li><a href="https://www.bilibili.com/video/BV1d4411v7u7" target="_blank" rel="noopener">哈工大李治军操作系统</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;打开电源那神秘的黑色背后发生着什么&quot;&gt;&lt;a href=&quot;#打开电源那神秘的黑色背后发生着什么&quot; class=&quot;headerlink&quot; title=&quot;打开电源那神秘的黑色背后发生着什么&quot;&gt;&lt;/a&gt;打开电源那神秘的黑色背后发生着什么&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;x86 PC刚开机时CPU处于实模式 （实模式即16bit，保护模式即32bit）&lt;/li&gt;
&lt;li&gt;开始时，CS = 0xFFFF；IP = 0x0000；（CS-&amp;gt; 段寄存器；IP-&amp;gt;段内偏移; &lt;strong&gt;CS &amp;lt;&amp;lt; 4 + IP = 物理地址&lt;/strong&gt;）&lt;/li&gt;
&lt;li&gt;寻址 0xFFFF0(ROM BIOS 映射区)  （BIOS -&amp;gt; Basic Input Output System；固化到内存地址为 0xFFFF0 处的一段代码）&lt;/li&gt;
&lt;li&gt;检查RAM，键盘，显示器，软硬磁盘&lt;/li&gt;
&lt;li&gt;将磁盘0磁道0扇区读入 0x7c00处 （0磁道0扇区为操作系统的引导扇区共 512byte）&lt;/li&gt;
&lt;li&gt;设置CS = 0x07c0; IP = 0x0000;&lt;/li&gt;
&lt;li&gt;寻址 0x7c00 开始执行操作系统引导扇区的代码&lt;/li&gt;
&lt;/ol&gt;</summary>
    
    
    
    
    <category term="操作系统" scheme="http://yoursite.com/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>操作系统概述</title>
    <link href="http://yoursite.com/2021/05/16/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0/"/>
    <id>http://yoursite.com/2021/05/16/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0/</id>
    <published>2021-05-16T08:44:16.000Z</published>
    <updated>2021-06-09T00:16:48.538Z</updated>
    
    <content type="html"><![CDATA[<h2 id="计算机是如何工作的"><a href="#计算机是如何工作的" class="headerlink" title="计算机是如何工作的"></a>计算机是如何工作的</h2><h3 id="从白纸到图灵机"><a href="#从白纸到图灵机" class="headerlink" title="从白纸到图灵机"></a><strong>从白纸到图灵机</strong></h3><p>计算机是如何工作的说到底就是一个<strong>计算模型</strong></p><p>1936年，英国数学家A.C.图灵提出了一种模型，通过纸带模拟人使用笔在纸上进行计算。即在纸带上读入3，在纸带上读入2，在纸带上读入 +，控制器查表知道是5，接着在纸带上写下5；<strong>此时图灵机只能进行加法运算</strong>。</p><a id="more"></a>  <p><img src="/2021/05/16/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0/7.jpg" alt="7"></p><h3 id="从图灵机到通用图灵机"><a href="#从图灵机到通用图灵机" class="headerlink" title="从图灵机到通用图灵机"></a><strong>从图灵机到通用图灵机</strong></h3><p>只能进行加法运算的计算模型显然是不够的，接着人们将控制器进行更改，当遇到加法操作时就改为加法控制器，当遇到乘法操作时就将控制器更改为乘法控制器。此时的通用图灵机就可以根据不同的运算方式来进行不同的计算控制，实现了通用的计算模型。</p><img src="/2021/05/16/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0/6.jpg" alt="6" style="zoom: 80%;"><h3 id="从通用图灵机到计算机"><a href="#从通用图灵机到计算机" class="headerlink" title="从通用图灵机到计算机"></a><strong>从通用图灵机到计算机</strong></h3><p><strong>冯·诺依曼</strong>首次提出<strong>存储程序</strong>的思想。</p><p>一种将程序指令存储器和数据存储器合并在一起的电脑设计概念结构</p><p>计算机由五大部分组成：<strong>运算器、控制器、存储器、输入设备、输出设备</strong>。</p><p>存储程序计算机在体系结构上主要特点有：1.以运算单元为中心；2.采用存储程序原理；3.存储器是按地址访问、线性编址的空间；3.控制流由指令流产生；4.指令由操作码和地址码组成；6.数据以二进制编码；</p><p>计算机在程序的控制下一步一步的从存储器中取出指令并进行处理，从此计算机工作的原理变成了<strong>取指执行</strong></p><img src="/2021/05/16/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0/55.png" alt="55" style="zoom:50%;"><h2 id="什么是操作系统"><a href="#什么是操作系统" class="headerlink" title="什么是操作系统"></a>什么是操作系统</h2><h3 id="维基百科的解释"><a href="#维基百科的解释" class="headerlink" title="维基百科的解释"></a><strong>维基百科的解释</strong></h3><p>操作系统（英语：<strong>O</strong>perating <strong>S</strong>ystem，缩写：<strong>OS</strong>）是一组主管并控制计算机操作、运用和运行硬件、软件资源和提供公共服务来组织用户交互的相互关联的系统软件程序，同时也是计算机系统的内核与基石。操作系统需要处理如管理与配置内存、决定系统资源供需的优先次序、控制输入与输出设备、操作网络与管理文件系统等基本事务。操作系统也提供一个让用户与系统交互的操作界面。</p><h3 id="简而言之"><a href="#简而言之" class="headerlink" title="简而言之"></a><strong>简而言之</strong></h3><p>键盘能输入，鼠标能点，显示器能看。人们可以在其上面进行听音乐、看小电影、浏览网站等一系列<strong>人机交互</strong>动作的啥东西。</p><h3 id="将操作系统立起来"><a href="#将操作系统立起来" class="headerlink" title="将操作系统立起来"></a><strong>将操作系统立起来</strong></h3><p>操作系统是工作在应用程序与计算机硬件之间的一层软件。向上给应用程序提供接口，向下管理各种硬件。</p><img src="/2021/05/16/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0/1.jpg" alt="1" style="zoom: 50%;"><h3 id="操作系统都管理那些硬件"><a href="#操作系统都管理那些硬件" class="headerlink" title="操作系统都管理那些硬件"></a><strong>操作系统都管理那些硬件</strong></h3><p>CPU管理    内存管理    终端管理    磁盘管理    文件管理    <em>网络管理    电源管理    多核管理</em></p><img src="/2021/05/16/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0/8.jpg" alt="8" style="zoom:80%;"><h2 id="操作系统的历史"><a href="#操作系统的历史" class="headerlink" title="操作系统的历史"></a>操作系统的历史</h2><h3 id="多进程图谱主线"><a href="#多进程图谱主线" class="headerlink" title="多进程图谱主线"></a>多进程图谱主线</h3><h4 id="1955-1965-年-IBM-7094"><a href="#1955-1965-年-IBM-7094" class="headerlink" title="1955-1965 年 IBM 7094"></a>1955-1965 年 IBM 7094</h4><p>计算机使用只专注于科学计算</p><p>批处理操作系统</p><p>典型代表：IBSYS 监控系统</p><h4 id="1965-1980-从IBSYS-到-OS-360"><a href="#1965-1980-从IBSYS-到-OS-360" class="headerlink" title="1965-1980 从IBSYS 到 OS/360"></a>1965-1980 从IBSYS 到 OS/360</h4><p>计算机开始进入多个行业，开始让计算机做很多事，往往既有IO任务，又有计算任务，如果按照以往的批处理系统，在执行IO任务的时候cup就要停下来。你让这么重要的计算机停一会？你觉得合适嘛？</p><p>多进程结构和进程管理概念萌芽</p><p>所以这个时候就出现了 <strong>多道程序</strong>  作业间的切换 和 调度 成为了核心</p><h4 id="1965-1980-从OS-360到MULTICS"><a href="#1965-1980-从OS-360到MULTICS" class="headerlink" title="1965-1980 从OS/360到MULTICS"></a>1965-1980 从OS/360到MULTICS</h4><p> 从OS/360到MULTICS并没有本质的区别，核心同样都是任务切换多道处理，但是增加了<strong>分时系统</strong>的概念</p><p>此时OS/360操作系统已经可以同时执行多个程序但是进程的切换是 在<strong>执行不下去</strong>的情况才切换，所以就会出现个别程序得不到cpu调度始终无法得到执行的情况，始终等待老倒霉蛋了！</p><p>所以就进行优化出现了分时系统的概念，cpu根据时间定期的切换，每个进程都一段一段的向前推进。</p><p>从此多进程的结构更加的清晰</p><h4 id="1980-1990-MULTICS-到-UNIX"><a href="#1980-1990-MULTICS-到-UNIX" class="headerlink" title="1980-1990 MULTICS 到 UNIX"></a>1980-1990 MULTICS 到 UNIX</h4><p>小型化计算机出现</p><p>UNIX是一个简化的MULTICS，核心概念差不多，同样还是任务切换 分时系统，但是更加的灵活和成功</p><p>Ken Thompson 和 Dennis Ritchie于1969年在贝尔实验室开发  后来重新用c语言进行编写</p><p>他们两个人是唯一通过做出系统而获得图灵奖的人 同时c语言同样是他们创造的</p><h4 id="1990-2000从UNIX到Linux"><a href="#1990-2000从UNIX到Linux" class="headerlink" title="1990-2000从UNIX到Linux"></a>1990-2000从UNIX到Linux</h4><p>个人计算机开始普及，很多人开始使用计算机</p><p>1987年 Andrew Tanenbaum 发布了MINX(非常类似UNIX) 用于教学</p><p>Linus Torvalds 在360sx 兼容微机上学习 MINIX ,并作出小Linux 并于 1991年发布</p><p>1994年 Linux 1.0 采用GPL 协议发布</p><p>1998年以后，互联网世界里展开了一场历史性的Linux的产业化运动</p><h4 id="IBSYS-gt-OS-360-gt-MULTICS-gt-Unix-gt-Linux"><a href="#IBSYS-gt-OS-360-gt-MULTICS-gt-Unix-gt-Linux" class="headerlink" title="IBSYS - &gt; OS/360 - &gt; MULTICS -&gt; Unix -&gt; Linux"></a>IBSYS - &gt; OS/360 - &gt; MULTICS -&gt; Unix -&gt; Linux</h4><p><strong>总结历史</strong></p><p><strong>多进程结构是操作系统的基本图谱</strong></p><ul><li>用户通过执行程序来使用计算机-&gt; 吻合冯诺依曼思想</li><li>作为管理者，操作系统要让多个程序合理推进 -&gt; 进程管理</li><li>多进程推进时需要内存复用等等</li></ul><h3 id="文件操作视图辅线"><a href="#文件操作视图辅线" class="headerlink" title="文件操作视图辅线"></a>文件操作视图辅线</h3><h4 id="PC与DOS"><a href="#PC与DOS" class="headerlink" title="PC与DOS"></a>PC与DOS</h4><p>IBM推出 PC机后，操作系统出现了百家争鸣的局面</p><p>1975年 Digital Research 这家公司 为 Altair8800 开发了操作系统 CP/M</p><p> CP/M : 写命令让用户使用，执行命令对应的程序，为单任务执行</p><p>1980年 出现了 8080 16位芯片，从 CP/M 的基础上开发了 QDOS(Quick and Dirty OS)</p><h4 id="从QDOS到-MS-DOS"><a href="#从QDOS到-MS-DOS" class="headerlink" title="从QDOS到 MS-DOS"></a>从QDOS到 MS-DOS</h4><p><strong>Bill Gates</strong> 进入历史舞台…..</p><p>1975年，22岁的 Paul Allen 和 20 岁的 Bill Gates 为 Altair8800 开发了 BASIC 解释器，据此开创了微软</p><p>1977年，Bill Gates 开发了 FAT磁盘管理系统</p><p> <strong>QDOS 的成功在于 以 CP/M 为基础，将BASIC and FAT 整合了进来</strong></p><p>1980年，IBM 想和 Digital Research 合作要求授权使用 CP/M,但是没有成功，转而同微软合作</p><p>1981年，微软买下了 QDOS,并改名为 MS-DOS (Disk OS) 同 IBM PC 一起打包出售 火爆全场</p><h4 id="从MS-DOS到Windows"><a href="#从MS-DOS到Windows" class="headerlink" title="从MS-DOS到Windows"></a>从MS-DOS到Windows</h4><p>MS-DOS的磁盘 ，文件，命令，让人使用计算加很方便，但似乎可以更加的方便…</p><p>1989年，MS-DOS 4.0 出现，支持了鼠标和键盘，此时微软已经决定要放弃 MS - DOS</p><p>不久后，图形界面操作系统 Windows 3.0 大获成功 （乔布斯直呼内行hhh）</p><p>然后就一发不可收拾，95 、xp、Vista、Win7、Win8…</p><h4 id="Mac-OS-与-ios"><a href="#Mac-OS-与-ios" class="headerlink" title="Mac OS 与 ios"></a>Mac OS 与 ios</h4><p>1984年，苹果推出 PC(麦金塔机，Macintosh) ,简称Mac 机。其处理器使用 IBM Intel 或者AMD等 ，核心在于屏幕、能耗等</p><p>和 Mac 机一起发布 System X 系统，一上来就是 GUI 图形化系统</p><p>在System 7 以后改名为 Mac OS 8</p><p>2007年，苹果发布 ios，核心仍然是 Mac OS, 专为移动端设备使用</p><p><strong>Mac OS 的 核心是 Unix, 专注于界面、文件、媒体等 和用户有关的内容。</strong></p><h4 id="CP-M-gt-QDOS-gt-MS-DOS-gt-Windows-Unix-gt-System-gt-Mac-OS-gt-ios"><a href="#CP-M-gt-QDOS-gt-MS-DOS-gt-Windows-Unix-gt-System-gt-Mac-OS-gt-ios" class="headerlink" title="CP/M -&gt; QDOS -&gt; MS- DOS -&gt; Windows    /  Unix -&gt; System -&gt; Mac OS -&gt; ios"></a>CP/M -&gt; QDOS -&gt; MS- DOS -&gt; Windows    /  Unix -&gt; System -&gt; Mac OS -&gt; ios</h4><p><strong>总结历史</strong></p><ul><li>仍然是程序执行，多进程，程序执行带动其他设备使用的基本结构</li><li>但用户的体验感更受重视：各种文件、编程环境、图形界面</li></ul><p>至此操作系统两大基本主体伴随着操作系统历史更加的清晰！</p><p><strong>参考资料</strong></p><ul><li><a href="https://www.bilibili.com/video/BV1d4411v7u7" target="_blank" rel="noopener">哈工大李治军操作系统</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;计算机是如何工作的&quot;&gt;&lt;a href=&quot;#计算机是如何工作的&quot; class=&quot;headerlink&quot; title=&quot;计算机是如何工作的&quot;&gt;&lt;/a&gt;计算机是如何工作的&lt;/h2&gt;&lt;h3 id=&quot;从白纸到图灵机&quot;&gt;&lt;a href=&quot;#从白纸到图灵机&quot; class=&quot;headerlink&quot; title=&quot;从白纸到图灵机&quot;&gt;&lt;/a&gt;&lt;strong&gt;从白纸到图灵机&lt;/strong&gt;&lt;/h3&gt;&lt;p&gt;计算机是如何工作的说到底就是一个&lt;strong&gt;计算模型&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;1936年，英国数学家A.C.图灵提出了一种模型，通过纸带模拟人使用笔在纸上进行计算。即在纸带上读入3，在纸带上读入2，在纸带上读入 +，控制器查表知道是5，接着在纸带上写下5；&lt;strong&gt;此时图灵机只能进行加法运算&lt;/strong&gt;。&lt;/p&gt;</summary>
    
    
    
    
    <category term="操作系统" scheme="http://yoursite.com/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>java 基础类</title>
    <link href="http://yoursite.com/2020/09/17/java%E5%9F%BA%E7%A1%80%E5%BA%93%E7%B1%BB/"/>
    <id>http://yoursite.com/2020/09/17/java%E5%9F%BA%E7%A1%80%E5%BA%93%E7%B1%BB/</id>
    <published>2020-09-17T13:15:21.168Z</published>
    <updated>2021-05-23T07:10:35.960Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Main类"><a href="#Main类" class="headerlink" title="Main类"></a>Main类</h2><blockquote><p> JVM运行Java应用程序的时候，首先会调用main方法<br>  调用时不实例化这个类的对象,而是通过类名直接调用<br>  因此需要是限制为public static<br> main()方法定义：“public static void main(String[]  字符串数组参数名)”  </p></blockquote><h2 id="jvm有限制，不能有返回值，因此返回值类型为void"><a href="#jvm有限制，不能有返回值，因此返回值类型为void" class="headerlink" title="jvm有限制，不能有返回值，因此返回值类型为void"></a>jvm有限制，不能有返回值，因此返回值类型为void</h2>  <a id="more"></a>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span>  </span>&#123;</span><br><span class="line"><span class="comment">//主方法入口</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">    </span><br><span class="line"><span class="comment">//输出args数组的长度</span></span><br><span class="line">    System.out.println(args.length);</span><br><span class="line">    System.out.println(<span class="string">"打印main方法中的输出参数"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;args.length;i++)&#123;</span><br><span class="line">    System.out.println(args[i]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Object类"><a href="#Object类" class="headerlink" title="Object类"></a>Object类</h2><blockquote><p>  Object类在java.lang包中<br>   所有Java类都直接或间接扩展Object类<br>   所有Java类都是Object类的子类Object类是所有类的超类<br>   Object类本身没有超类<br>   Object类的引用变量可以保存任何类的对象的引用</p></blockquote><h3 id="Object类方法"><a href="#Object类方法" class="headerlink" title="Object类方法"></a>Object类方法</h3><ul><li><p>public String toString()<br>我们可以自定义它， 它返回对象的字符串表示形式 通常它用于调试目的<br> 如果类中未重写该方法，则输出：”类名@十六进制的hashcode值”，若重写，则输出表述该对象信息的字符串</p></li><li><p>System.out.println(xx)<br>括号里面的“xx”对象如果不是String类型的话，就自动调用xx的toString()方法</p></li><li><p>public boolean equals(Object obj) </p><p>它用于比较两个对象的相等性</p></li><li><p>public int hashCode()<br>它返回对象的哈希码（整数）值, 根据一定的规则将与对象相关的信息（比如对象的存储地址，对象的字段等）映射成一个数值，这个数值称作为散列值</p></li><li><p>protected void finalize() throws Throwable </p><p>它不是在Object类中实现 它在对象被销毁之前被垃圾收集器调用。</p></li><li><p>public final Class getClass()<br>  它返回对象的Class对象的引用即可以返回对象的父类等相关信息</p></li></ul><hr><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ObjectTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span> <span class="params">(String[] args)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        String strObj = <span class="keyword">new</span> String();</span><br><span class="line">        ObjectTest obj = <span class="keyword">new</span> ObjectTest();</span><br><span class="line"></span><br><span class="line">        printClassInfo(strObj);</span><br><span class="line">        printClassInfo(obj);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        String str1 =<span class="keyword">new</span> String(<span class="string">"123456"</span>);</span><br><span class="line">        <span class="comment">//调用hasCode方法输出对象的哈希值</span></span><br><span class="line">        System.out.println(<span class="string">"str字符串的哈希值为："</span>+str1.hashCode());</span><br><span class="line">        equalsTest(str1);</span><br><span class="line">        <span class="comment">//调用toString方法返回str对象的字符串形式</span></span><br><span class="line">        System.out.println(<span class="string">"返回str对象的字符串形式："</span>+str1.toString());</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//定义一个printClassInfo()方法来描述getClass()方法</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printClassInfo</span><span class="params">(Object obj)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//获取类名</span></span><br><span class="line">        System.out.println(<span class="string">"类名："</span> + obj.getClass().getName());</span><br><span class="line">        <span class="comment">//获取父类名</span></span><br><span class="line">        System.out.println(<span class="string">"父类："</span>+obj.getClass().getSuperclass().getName());</span><br><span class="line">        <span class="comment">//获取接口信息并输出</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; obj.getClass().getInterfaces().length; i++) &#123;</span><br><span class="line">            System.out.println(obj.getClass().getInterfaces()[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//定义一个equalsTest方法来描述equals()方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">equalsTest</span><span class="params">(String str)</span></span>&#123;</span><br><span class="line">        String passworld = <span class="string">"123456"</span>;</span><br><span class="line">        <span class="keyword">boolean</span> con;</span><br><span class="line">        <span class="keyword">if</span> (str.equals(passworld)) con = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            con=<span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(con);</span><br><span class="line">        <span class="keyword">return</span>  con;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="String-StringBuffer-StringBuilder类"><a href="#String-StringBuffer-StringBuilder类" class="headerlink" title="String StringBuffer StringBuilder类"></a>String StringBuffer StringBuilder类</h2><blockquote><p>String 类一旦创建将不会改变<br>与String 类不同的是，StringBuffer 和 StringBuilder 类的对象能够被多次的修改，并且不产生新的未使用对象<br>tringBuffer用法和StringBuilder一样，不过，StringBuffer是线程安全的<br> StringBuilder 相较于 StringBuffer 有速度优势，所以多数情况下建议使用 StringBuilder类</p></blockquote><h3 id="String类方法"><a href="#String类方法" class="headerlink" title="String类方法"></a>String类方法</h3><ul><li>char charAt(int index)<br>取字符串中的某一个字符，其中的参数index指的是字符串中序数。<br>   字符串的序数从0开始到length()-1    </li><li>int compareTo(String anotherString)<br>当前String对象与anotherString比较<br>  相等关系返回０；不相等时，从两个字符串第0个字符开始比较，返回第一个不相等的字符差<br>   另一种情况，较长字符串的前面部分恰巧是较短的字符串，返回它们的长度差  </li></ul><hr>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StringTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> String str;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span> <span class="params">(String[] args)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建字符串</span></span><br><span class="line">        String greeting =<span class="string">"hello world"</span>;</span><br><span class="line">        System.out.println(greeting);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//string和StringBuffer类的相互转换</span></span><br><span class="line">        <span class="comment">//注意：可以=解决scanner类输入字符串进行修改的问题</span></span><br><span class="line">        String aa =<span class="keyword">new</span> String(<span class="string">"123456"</span>);</span><br><span class="line">        StringBuilder bb = <span class="keyword">new</span>  StringBuilder(aa);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//初始化字符转</span></span><br><span class="line">        <span class="keyword">char</span> [] helloArray = &#123;<span class="string">'a'</span>,<span class="string">'b'</span>,<span class="string">'c'</span>&#125;;</span><br><span class="line">        String arrayTest = <span class="keyword">new</span> String(helloArray);</span><br><span class="line">        System.out.println(arrayTest);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//输出字符串的长度</span></span><br><span class="line">        System.out.println(arrayTest.length());</span><br><span class="line"></span><br><span class="line">        <span class="comment">//取字符串中的特定字符</span></span><br><span class="line">        System.out.println(arrayTest.charAt(<span class="number">1</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">//将两个字符串进行比较</span></span><br><span class="line">        String str1 = <span class="keyword">new</span> String(<span class="string">"i love cat"</span>);</span><br><span class="line">        String str2 = <span class="keyword">new</span> String(<span class="string">"i love cat"</span>);</span><br><span class="line">        String str3 = <span class="keyword">new</span> String(<span class="string">"i love cat and dogs"</span>);</span><br><span class="line">        System.out.println(str1.compareTo(str2));</span><br><span class="line">        System.out.println(str1.compareTo(str3));</span><br><span class="line"></span><br><span class="line">        <span class="comment">//连接两个字符串的方法</span></span><br><span class="line">        String str4 =<span class="string">"我的github网站："</span>;</span><br><span class="line">        String str5 =<span class="string">"https://github.com/hermit-rain"</span>;</span><br><span class="line">        System.out.println(str1.concat(str2));</span><br><span class="line"></span><br><span class="line">        <span class="comment">//描述StringBuilder类中主要使用的方法</span></span><br><span class="line">        StringBuilder str6 = <span class="keyword">new</span> StringBuilder(<span class="string">"hello "</span>);</span><br><span class="line">        <span class="comment">//追加</span></span><br><span class="line">        System.out.println(str6.append(<span class="string">"java"</span>));</span><br><span class="line">        <span class="comment">//反转</span></span><br><span class="line">        System.out.println(str6.reverse());</span><br><span class="line">        <span class="comment">//移除</span></span><br><span class="line">        System.out.println(str6.delete(<span class="number">1</span>,<span class="number">3</span>));</span><br><span class="line">        <span class="comment">//替换</span></span><br><span class="line">        System.out.println(str6.insert(<span class="number">0</span>,<span class="string">"hello java"</span>));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Scanner类"><a href="#Scanner类" class="headerlink" title="Scanner类"></a>Scanner类</h2><blockquote><p>Scanner类包括文件输入和字符输入两种格式<br>next无法读取空格 遇到空格即停止编译  nextLine可以识别空格并成功输出<br>注意：Scanner类只能返回String类的对象 不能返回StringBuffer类的对象,要想调用StringBuffer方法必须将String类型转化成StringBuffer类型</p></blockquote><h3 id="Scanner类方法"><a href="#Scanner类方法" class="headerlink" title="Scanner类方法"></a>Scanner类方法</h3><ul><li>hasNext hasNextLine作为判断判否还有下一行输入  </li><li>next  nextLine 返回输入源中的下一行字符串</li></ul><hr><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ScannerTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> FileNotFoundException </span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//创建Scanner类对象</span></span><br><span class="line">        Scanner scan = <span class="keyword">new</span> Scanner(System.in) ;</span><br><span class="line">     </span><br><span class="line">        <span class="comment">//用next返回输入源中的下一行字符串</span></span><br><span class="line">        <span class="keyword">if</span> (scan.hasNext())&#123;</span><br><span class="line">            String str1 =scan.next();</span><br><span class="line">            System.out.println(<span class="string">"输出的数据是："</span>+str1);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//用 nextLine返回输入源中的下一行字符串</span></span><br><span class="line">        <span class="keyword">if</span> (scan.hasNextLine())&#123;</span><br><span class="line">            String str2 = scan.nextLine();</span><br><span class="line">            System.out.println(<span class="string">"输入字符串str2："</span>+str2);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        scan.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="System类"><a href="#System类" class="headerlink" title="System类"></a>System类</h2><blockquote><p>System类中包括类有 3 个静态成员变量<br>分别是 PrintStream out、InputStream in 和 PrintStream err  </p></blockquote><h3 id="System类方法"><a href="#System类方法" class="headerlink" title="System类方法"></a>System类方法</h3><ul><li>arrayCopy() 方法 该方法的作用是数组复制，即从指定源数组中复制一个数组 </li><li>currentTimeMillis() 方法 该方法的作用是返回当前的计算机时间  </li><li>identityHashCode(Object x) 该方法返回指定对象的精确hashCode值  <blockquote><blockquote><p>identityHashCode(Object x)与hashCode()两种方法的区别<br>Object的hashCode()默认是返回内存地址的，但是hashCode()可以重写，所以hashCode()不能代表内存地址的不同<br>System.identityHashCode(Object x)方法可以返回对象的内存地址,不管该对象的类是否重写了hashCode()方法<br>该方法返回指定对象的精确hashCode值，也就是根据该对象的地址计算得到的hashCode值，可以唯一地标识一个对象<br>判断两个对象是否是指向同一地址，应该用System.identityHashCode(Object x)方法进行判断 </p></blockquote></blockquote></li></ul><hr><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SystemTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span> <span class="params">(String[] args)</span></span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">//类方法arrayCopy</span></span><br><span class="line">        <span class="comment">// public static void arraycopy(Object src,int srcPos,Object dest,int destPos,int length)</span></span><br><span class="line">        <span class="comment">//src 表示源数组，srcPos 表示从源数组中复制的起始位置</span></span><br><span class="line">        <span class="comment">//dest 表示目标数组，destPos 表示要复制到的目标数组的起始位置，length 表示复制的个数。</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">char</span>[] srcArray = &#123;<span class="string">'A'</span>,<span class="string">'B'</span>,<span class="string">'C'</span>,<span class="string">'D'</span>&#125;;</span><br><span class="line">        <span class="keyword">char</span>[] destArray = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="number">4</span>];</span><br><span class="line">        System.arraycopy(srcArray,<span class="number">1</span>,destArray,<span class="number">1</span>,<span class="number">2</span>);</span><br><span class="line">        System.out.println(<span class="string">"输出原数组："</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;srcArray.length;i++)&#123;</span><br><span class="line">            System.out.println(srcArray[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"输出目标数组"</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;destArray.length; j++)&#123;</span><br><span class="line">            System.out.println(destArray[j]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//currentTimeMillis() 方法</span></span><br><span class="line">        <span class="comment">//该方法的作用是返回当前的计算机时间，</span></span><br><span class="line">        <span class="comment">// 时间的格式为当前计算机时间与 GMT 时间（格林尼治时间）1970 年 1 月 1 日 0 时 0 分 0 秒所差的毫秒数</span></span><br><span class="line">        <span class="keyword">long</span> startTime = System.currentTimeMillis();</span><br><span class="line">        System.out.println(startTime);</span><br><span class="line">        <span class="keyword">int</span> i;</span><br><span class="line">        <span class="keyword">long</span> trem=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (i=<span class="number">0</span>;i&lt;<span class="number">100000000</span>;i++)&#123;</span><br><span class="line">            trem = trem+i;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(trem);</span><br><span class="line">        <span class="keyword">long</span> endTime = System.currentTimeMillis();</span><br><span class="line">        <span class="keyword">long</span> soTime=endTime-startTime;</span><br><span class="line">        System.out.println(soTime);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">// identityHashCode(Object x)与hashCode()方法返回相同的哈希值</span></span><br><span class="line">        String  str1= <span class="string">"hello"</span>;</span><br><span class="line">        String str2= <span class="string">"hello"</span>;</span><br><span class="line">        System.out.println(str1.hashCode()+<span class="string">"--------"</span>+str2.hashCode());</span><br><span class="line">        System.out.println(System.identityHashCode(str1)+<span class="string">"-----"</span>+System.identityHashCode(str2));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        String str3 =<span class="keyword">new</span> String(<span class="string">"Hello"</span>);</span><br><span class="line">        String str4 = <span class="keyword">new</span> String(<span class="string">"Hello"</span>);</span><br><span class="line">        <span class="comment">//不同对象通过重写的hashCode()方法返回的值可能相同</span></span><br><span class="line">        System.out.println(str3 .hashCode()+<span class="string">"------"</span>+str4.hashCode());</span><br><span class="line">        <span class="comment">//因为str3和str4为两种不同的对象所以他们通过identityHashCode方法返回的内存地址不相同；</span></span><br><span class="line">        System.out.println(System.identityHashCode(str3)+<span class="string">"-----"</span>+System.identityHashCode(str4));</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Math类"><a href="#Math类" class="headerlink" title="Math类"></a>Math类</h2><blockquote><p>提供了两个静态变量：PI和E，值分别为：π和e<br>包含了用于执行基本数学运算的属性和方法，如初等指数、对数、平方根和三角函数等<br>Math 的方法都被定义为 static 形式，通过 Math 类可以在主函数中直接调用</p></blockquote><hr><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MathTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> a, b;</span><br><span class="line">        a=<span class="number">9</span>;</span><br><span class="line">        b=-<span class="number">10</span>;</span><br><span class="line">        System.out.println(Math.abs(b));</span><br><span class="line">        <span class="comment">//计算乘方</span></span><br><span class="line">        System.out.println(Math.pow(a,b));</span><br><span class="line">        <span class="comment">//计算自然对数</span></span><br><span class="line">        System.out.println(Math.log(a));</span><br><span class="line">        <span class="comment">//找出最大值</span></span><br><span class="line">        System.out.println(Math.max(<span class="number">7</span>,<span class="number">12</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">//输出90度的正弦值</span></span><br><span class="line">        <span class="comment">//调用Math中的静态变量PI</span></span><br><span class="line">        System.out.println(<span class="string">"90度的正弦值为："</span>+Math.sin(Math.PI/<span class="number">2</span>));</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Random类"><a href="#Random类" class="headerlink" title="Random类"></a>Random类</h2><blockquote><p>Random类专门用于生成一个随机数<br>它有两个构造器，一个是使用默认的种子（以当前时间为种子），另一个是显式传入一个long整型的种子<br>使用相同的种子可以产生相同的随机数<br>为了避免产生相同的随机数常推荐使用当前时间作为 Random对象的种子<br>Random  rand  = new  Random (System.currentTimeMills()) ;</p><blockquote><p>相比于Math的random()方法，Random类提供了更多的方式来生成各种伪随机数<br>既可以生成浮点类型的伪随机数，也可以生成整数类型的伪随机数，还可以指定生成随机数的范围<br>ThreadLocalRandom类是Random的增强版<br>在并发访问的环境下，使用ThreadLocalRandom来代替Random可以减少多线程资源竞争，保证线程安全<br>它提供了一个静态方法current( )方法来获取对象，然后调用各种nextXxx( ) 方法来获取各种基本类型的随机数</p></blockquote></blockquote><hr><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RandomTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span> <span class="params">(String[] args)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        Random rand = <span class="keyword">new</span> Random();</span><br><span class="line">        <span class="comment">//随机产生布尔类型的随机数</span></span><br><span class="line">        System.out.println(rand.nextBoolean());</span><br><span class="line">        <span class="comment">// 生成0.0~1.0之间的伪随机double数</span></span><br><span class="line">        System.out.println(rand.nextDouble());</span><br><span class="line">        <span class="comment">// 生成一个处于int整数取值范围的伪随机整数</span></span><br><span class="line">        System.out.println(rand.nextInt());</span><br><span class="line">        <span class="comment">// 生成0~26之间的伪随机整数</span></span><br><span class="line">        System.out.println(rand.nextInt(<span class="number">26</span>));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">//使用相同的种子产生相同的随机数</span></span><br><span class="line">        Random rand1 = <span class="keyword">new</span> Random(<span class="number">50</span>);</span><br><span class="line">        Random rand2 = <span class="keyword">new</span> Random(<span class="number">50</span>);</span><br><span class="line">        System.out.println(rand1.nextInt());</span><br><span class="line">        System.out.println(rand2.nextInt());</span><br><span class="line"></span><br><span class="line">        <span class="comment">//使用当前时间作为种子产生随机数</span></span><br><span class="line">        Random rand3 = <span class="keyword">new</span> Random(System.currentTimeMillis());</span><br><span class="line">        Random rand4 = <span class="keyword">new</span> Random(System.currentTimeMillis()+<span class="number">1000</span>);</span><br><span class="line">        System.out.println(rand3.nextInt());</span><br><span class="line">        System.out.println(rand4.nextInt());</span><br><span class="line"></span><br><span class="line">        <span class="comment">//通过ThreadLocalRandom类来生成随机数</span></span><br><span class="line">        ThreadLocalRandom rand5 = ThreadLocalRandom.current();</span><br><span class="line">        ThreadLocalRandom rand6 = ThreadLocalRandom.current();</span><br><span class="line">        <span class="keyword">int</span>  val  = rand5.nextInt(<span class="number">10</span>);</span><br><span class="line">        <span class="keyword">long</span> va2 = (<span class="keyword">long</span>) rand6.nextDouble(<span class="number">10.00</span>);</span><br><span class="line">        System.out.println(val);+</span><br><span class="line">        System.out.println(va2);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Runtime类"><a href="#Runtime类" class="headerlink" title="Runtime类"></a>Runtime类</h2><blockquote><p>Runtime类描述Java程序的运行时环境<br>每个Java程序都有一个与之对应的Runtime实例<br>该类会被自动创建，我们可以通过Runtime.getRuntime() 方法来获取当前程序的Runtime实例。<br>应用程序通过该对象与其运行的环境相连接 可以访问JVM的相关信息，如处理器数量、内存信息等  </p></blockquote><h3 id="Runtime类方法"><a href="#Runtime类方法" class="headerlink" title="Runtime类方法"></a>Runtime类方法</h3><ul><li>public static Runtime getRuntime（）： 此方法返回与当前Java应用程序关联的实例或Runtime对象。  </li><li>public long freeMemory（）：此方法返回JVM（Java虚拟机）中的可用内存量  </li><li>public long totalMemory（）：此方法返回JVM（Java虚拟机）中的总内存量  </li><li>public long maxMemory（）：此方法返回Java虚拟机将尝试使用的最大内存量  </li><li>public Process exec（String command）抛出IOException：此方法在单独的进程中执行给定的命令  </li><li>public void gc（）：此方法运行垃圾收集器。调用此方法表明Java虚拟机花费了大量精力来回收未使用的对象，以使其当前占用的内存可用于快速重用  </li></ul><hr><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RuntimeTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span> <span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">//创建一个实例化对象</span></span><br><span class="line">        Runtime run = Runtime.getRuntime();</span><br><span class="line">        <span class="comment">//调用Runtime中的方法获取jvm的相关信息</span></span><br><span class="line">        System.out.println(<span class="string">"jvm中可用的内存数："</span>+run.freeMemory());</span><br><span class="line">        System.out.println(<span class="string">"jvm中总内存数："</span>+run.totalMemory());</span><br><span class="line">        System.out.println(<span class="string">"jvm尝试使用最大的内存数："</span>+run.maxMemory());</span><br><span class="line"></span><br><span class="line">        <span class="comment">//通过exec方放来调用jvm单独启用一个进程来执行操作命令</span></span><br><span class="line">        run.exec(<span class="string">"notepad.exe"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//调用Runtime中gc()方法进行垃圾回收</span></span><br><span class="line">        run.gc();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Date类"><a href="#Date类" class="headerlink" title="Date类"></a>Date类</h2><blockquote><p>Data类共有两种构造器分别是无参和有参数的构造器  </p><blockquote><p>Date()   生成一个代表当前日期时间的对象<br>Date(long date) 根据指定的long型整数来生成一个Date对象  </p></blockquote></blockquote><h3 id="Date类方法"><a href="#Date类方法" class="headerlink" title="Date类方法"></a>Date类方法</h3><ul><li>boolean after(Date date)：判断当前日期是否在date之后  </li><li>boolean before(Date date)：判断当前日期是否在date之前  </li><li>long  getTime()：返回该时间对应的long型整数，即从1970年1月1日00:00:00到当前对象之间的时间差  </li><li>int compareTo(Date date)<br>比较当调用此方法的Date对象和指定日期<br>两者相等时候返回0，调用对象在指定日期之前则返回负数。调用对象在指定日期之后则返回正数  </li></ul><hr><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DateTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        Date date =<span class="keyword">new</span> Date();</span><br><span class="line">        System.out.println(date.toString());</span><br><span class="line">        Date date1 =<span class="keyword">new</span> Date(System.currentTimeMillis());</span><br><span class="line">        <span class="comment">//注意参数的设置：  Date类的年份是以1900开头，以0月开头的；</span></span><br><span class="line">        Date date2 = <span class="keyword">new</span> Date(<span class="number">2020</span>-<span class="number">1900</span>,<span class="number">6</span>-<span class="number">1</span>,<span class="number">12</span>);</span><br><span class="line">        System.out.println(date1);</span><br><span class="line">        System.out.println(date2);</span><br><span class="line">        <span class="comment">//返回当前时间对应的long型整数</span></span><br><span class="line">        System.out.println(date.getTime());</span><br><span class="line">        System.out.println(date.before(date2));</span><br><span class="line">        System.out.println(date.after(date2));</span><br><span class="line">        System.out.println(date.compareTo(date2));</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Calendar类"><a href="#Calendar类" class="headerlink" title="Calendar类"></a>Calendar类</h2><blockquote><p>Calendar类是一个抽象类，因此不能用构造器来创建对象，必须通过静态方法getInstance( )方法来获取Calendar对象<br>Calendar类可以直接对date的年份，月份或者日期进行更改</p><blockquote><p>roll以及add的区别<br>add方法的月份增加年份会进行递增</p><h2 id="roll方法月份的增加只会自身进行循环"><a href="#roll方法月份的增加只会自身进行循环" class="headerlink" title="roll方法月份的增加只会自身进行循环"></a>roll方法月份的增加只会自身进行循环</h2></blockquote></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CalendarTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建一个代表系统当前日期的Calendar对象</span></span><br><span class="line">        Calendar c1 = Calendar.getInstance();</span><br><span class="line">        Date date = c1.getTime();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建一个指定时间的Calendar对象</span></span><br><span class="line">        Calendar c2 =Calendar.getInstance();</span><br><span class="line">        c2.set(<span class="number">2008</span>,<span class="number">9</span>,<span class="number">3</span>);</span><br><span class="line">        System.out.println(date);</span><br><span class="line">        System.out.println(c2.getTime());</span><br><span class="line"></span><br><span class="line">        <span class="comment">//取出某个时间对象的具体年份月份以及日</span></span><br><span class="line">        System.out.println(c2.get(Calendar.YEAR));</span><br><span class="line">        System.out.println(c2.get(Calendar.MONTH));</span><br><span class="line">        System.out.println(c2.get(Calendar.DATE));</span><br><span class="line"></span><br><span class="line">        <span class="comment">//更改年月日</span></span><br><span class="line">         c1.add(Calendar.YEAR,<span class="number">2</span>);</span><br><span class="line">        <span class="comment">//添加的月份数满12个月后年份会自动增加一位</span></span><br><span class="line">         c1.add(Calendar.MONTH,<span class="number">10</span>);</span><br><span class="line">        <span class="comment">// roll方法的月份增加只会改变月份，如果满12则会进行迭代</span></span><br><span class="line">         c2.roll(Calendar.MONTH,<span class="number">10</span>);</span><br><span class="line">         c1.add(Calendar.DATE,<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(c1.get(Calendar.YEAR));</span><br><span class="line">        System.out.println(c1.get(Calendar.MONTH));</span><br><span class="line">        System.out.println(c1.get(Calendar.DATE));</span><br><span class="line">        System.out.println(c2.get(Calendar.MONTH));</span><br><span class="line">        System.out.println(c1.get(Calendar.DATE));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">//Date类与Calendar类的相互转换 </span></span><br><span class="line">        <span class="comment">//Date类转Calendar类</span></span><br><span class="line">        Calendar cal1 = Calendar.getInstance();</span><br><span class="line">        Date  date1 = cal1.getTime();</span><br><span class="line">        <span class="comment">//Calendar类转Date类</span></span><br><span class="line">        Date date2 = <span class="keyword">new</span> Date();</span><br><span class="line">        Calendar cal2 =Calendar.getInstance();</span><br><span class="line">        cal2.setTime(date2);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="BigDecimal类"><a href="#BigDecimal类" class="headerlink" title="BigDecimal类"></a>BigDecimal类</h2><blockquote><p>float和double类型的主要设计目标是为了科学计算和工程计算<br>因在于我们的计算机是二进制的 浮点数没有办法是用二进制进行精确表示<br>商业计算往往要求结果精确，这时候BigDecimal就派上大用场  </p></blockquote><h3 id="BigDecimal类的常用构造方法"><a href="#BigDecimal类的常用构造方法" class="headerlink" title="BigDecimal类的常用构造方法"></a>BigDecimal类的常用构造方法</h3><ul><li>1.public BigDecimal(double val)    将double表示形式转换为BigDecimal 不建议使用  </li><li>2.public BigDecimal(int val)　　将int表示形式转换成BigDecimal  </li><li>3.public BigDecimal(String val)　　将String表示形式转换成BigDecimal  <blockquote><blockquote><p>注意：参数类型为double的构造方法的结果有一定的不可预知性 String 构造方法是完全可预知的<br>所以BigDecimal类最好使用String类的构造器  </p></blockquote></blockquote></li></ul><h3 id="BigDecimal类的常用方法"><a href="#BigDecimal类的常用方法" class="headerlink" title="BigDecimal类的常用方法"></a>BigDecimal类的常用方法</h3><ul><li>public BigDecimal add(BigDecimal value);                加法  </li><li>public BigDecimal subtract(BigDecimal value);           减法</li><li>public BigDecimal multiply(BigDecimal value);           乘法  </li><li>public BigDecimal divide(BigDecimal value);             除法  </li></ul><hr><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BigDecimalTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//BigDecimal类的基础对象的构建</span></span><br><span class="line">        BigDecimal doubleTest1 = <span class="keyword">new</span> BigDecimal(<span class="string">"0.01"</span>);</span><br><span class="line">        BigDecimal doubleTest2 = <span class="keyword">new</span> BigDecimal(<span class="number">0.01</span>);</span><br><span class="line">        BigDecimal intTest1 = <span class="keyword">new</span> BigDecimal(<span class="number">178</span>);</span><br><span class="line">        <span class="comment">//string 的构造器是完全预知的所以可以精确的表示0.01</span></span><br><span class="line">        System.out.println(doubleTest1);</span><br><span class="line">        <span class="comment">//0.01无法精确的表示double所以系统会默认随机补位</span></span><br><span class="line">        System.out.println(doubleTest2);</span><br><span class="line">        System.out.println(intTest1);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">//BigDecimal类的基础方法的使用</span></span><br><span class="line">        BigDecimal testNumber1 = <span class="keyword">new</span> BigDecimal(<span class="string">"0.15"</span>);</span><br><span class="line">        BigDecimal testNumber2 = <span class="keyword">new</span> BigDecimal(<span class="string">"0.03"</span>);</span><br><span class="line">        System.out.println(testNumber1.add(testNumber2));</span><br><span class="line">        System.out.println(testNumber1.subtract(testNumber2));</span><br><span class="line">        System.out.println(testNumber1.multiply(testNumber2));</span><br><span class="line">        System.out.println(testNumber1.divide(testNumber2));</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h2><blockquote><p>正则表达式定义了字符串的模式，相当于构建了一个java字符串的自定义模板<br>java.util.regex 包主要包括以下两个类：<br>attern 类：<br>pattern 对象是一个正则表达式的编译表示<br>Pattern 类没有公共构造方法 要创建一个 Pattern 对象，你必须首先调用其公共静态编译方法<br>它返回一个 Pattern 对象。该方法接受一个正则表达式作为它的第一个参数<br>Matcher 类：<br>Matcher 对象是对输入字符串进行解释和匹配操作的引擎<br>与Pattern 类一样，Matcher 也没有公共构造方法<br>需要调用 Pattern 对象的 matcher 方法来获得一个 Matcher 对象  </p></blockquote><h3 id="Matcher-类的方法"><a href="#Matcher-类的方法" class="headerlink" title="Matcher 类的方法"></a>Matcher 类的方法</h3><ul><li>public int start()  返回以前匹配的初始索引  </li><li>public int end() 返回最后匹配字符之后的偏移量  </li><li>public boolean find()  尝试查找与该模式匹配的输入序列的下一个子序列  </li></ul><hr><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RegexTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        String str = <span class="keyword">new</span> String(<span class="string">"请尽快联系我17824852705,我的电话是15143385727出售二手书籍16824852705"</span>);</span><br><span class="line">        <span class="comment">// 创建一个pattern字符串模板</span></span><br><span class="line">        Pattern pat = Pattern.compile(<span class="string">"((17\\d)|(15\\d))\\d&#123;8&#125;"</span>);</span><br><span class="line">        <span class="comment">//调用Pattern类的matcher方法创建一个Matcher对象</span></span><br><span class="line">        Matcher m =pat.matcher(str);</span><br><span class="line">        <span class="comment">//将给定字符串与模板字符串进行比较</span></span><br><span class="line">        <span class="keyword">while</span> (m.find())&#123;</span><br><span class="line">            <span class="comment">//输出所有与模板字符串相匹配的字符串</span></span><br><span class="line">            System.out.println(m.group());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//描述正则表达式的特殊字符</span></span><br><span class="line">        Pattern pat2 =Pattern.compile(<span class="string">"a*b"</span>);</span><br><span class="line">        Matcher m2 = pat2.matcher(<span class="string">"aab"</span>);</span><br><span class="line">        <span class="keyword">boolean</span> boo = m2.matches();</span><br><span class="line">        System.out.println(boo);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">         <span class="comment">//Matcher类end()和start()方法</span></span><br><span class="line">         String str2 =<span class="keyword">new</span> String(<span class="string">"java is very good "</span>);</span><br><span class="line">         System.out.println(<span class="string">"目标字符串："</span>+str2);</span><br><span class="line">         Matcher m3 = Pattern.compile(<span class="string">"\\w+"</span>).matcher(str2);</span><br><span class="line">         <span class="keyword">while</span>(m3.find())&#123;</span><br><span class="line">             System.out.println(m3.group()+<span class="string">"起始字符位置："</span>+m3.start()+<span class="string">"结尾字符位置："</span>+ m3.end());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">         <span class="comment">//通过正则表达式输出字符串数组</span></span><br><span class="line">         String[] mails = &#123;<span class="string">"kongyeeku@163.com"</span>, <span class="string">"kongyeeku@gmail.com"</span>, <span class="string">"ligang@crazyit.org"</span>, <span class="string">"wawa@abc.xx"</span>&#125;;</span><br><span class="line">         String mailRegEx = <span class="string">"\\w&#123;3,20&#125;@\\w+\\.(com|org|cn|net|gov)"</span>;</span><br><span class="line"></span><br><span class="line">         Pattern mailPattern =Pattern.compile(mailRegEx);</span><br><span class="line"></span><br><span class="line">         <span class="comment">//用for循环for（：）方法对数组进行遍历输出</span></span><br><span class="line">         Matcher matcher =<span class="keyword">null</span>;</span><br><span class="line">         <span class="keyword">for</span>(String mail :mails)&#123;</span><br><span class="line">            <span class="keyword">if</span> (matcher == <span class="keyword">null</span>)</span><br><span class="line">                <span class="comment">//第一次匹配时创建matcher对象</span></span><br><span class="line">                matcher = mailPattern.matcher(mail);</span><br><span class="line">                <span class="comment">//先重置目标字符串-避免后面重置时第一个数组会输出两次；</span></span><br><span class="line">                matcher.reset(mail);</span><br><span class="line">                <span class="keyword">while</span> (matcher.find()) &#123;</span><br><span class="line">                    System.out.println(matcher.group());</span><br><span class="line">                &#125;</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;Main类&quot;&gt;&lt;a href=&quot;#Main类&quot; class=&quot;headerlink&quot; title=&quot;Main类&quot;&gt;&lt;/a&gt;Main类&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt; JVM运行Java应用程序的时候，首先会调用main方法&lt;br&gt;  调用时不实例化这个类的对象,而是通过类名直接调用&lt;br&gt;  因此需要是限制为public static&lt;br&gt; main()方法定义：“public static void main(String[]  字符串数组参数名)”  &lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;jvm有限制，不能有返回值，因此返回值类型为void&quot;&gt;&lt;a href=&quot;#jvm有限制，不能有返回值，因此返回值类型为void&quot; class=&quot;headerlink&quot; title=&quot;jvm有限制，不能有返回值，因此返回值类型为void&quot;&gt;&lt;/a&gt;jvm有限制，不能有返回值，因此返回值类型为void&lt;/h2&gt;</summary>
    
    
    
    
    <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>Windows如何重做系统</title>
    <link href="http://yoursite.com/2020/09/01/window10/"/>
    <id>http://yoursite.com/2020/09/01/window10/</id>
    <published>2020-09-01T05:06:33.000Z</published>
    <updated>2021-06-09T00:34:15.624Z</updated>
    
    <content type="html"><![CDATA[<h2 id="为什么要重做系统"><a href="#为什么要重做系统" class="headerlink" title="为什么要重做系统"></a>为什么要重做系统</h2><p>1.提高系统稳定性<br>2.清理系统垃圾<br>3.修复缺失的系统文件<br>4.杀死病毒<br>5.系统崩溃——没招  </p><a id="more"></a><h2 id="重置系统与重装系统的区别"><a href="#重置系统与重装系统的区别" class="headerlink" title="重置系统与重装系统的区别"></a>重置系统与重装系统的区别</h2><p>1.重置利用系统现有的资源重新组成可用的系统，重装把全新的系统写入电脑<br>2.重置可以主动保留必要的文件（电脑可以开机），重装系统则需要手动备份<br>3.重置可能不会解决系统所有的问题，重装一定会<br>4.重置不需要借助工具，重装需要借助光盘或者U盘做介质下载系统镜像<br>5.重置系统后联网自动激活重装系统后可能存在系统激活问题<br>6.若系统损坏严重则只能进行系统重装</p><h2 id="重做系统的注意事项"><a href="#重做系统的注意事项" class="headerlink" title="重做系统的注意事项"></a>重做系统的注意事项</h2><p>1.重装系统和重置系统都会格式化系统盘<br>2.数字权利—包括一些激活码和正版软件的激活可能失效（注意保留激活工具）  </p><h2 id="重置系统"><a href="#重置系统" class="headerlink" title="重置系统"></a>重置系统</h2><p>windows&gt;设置&gt;更新和安全&gt;恢复</p><p><img src="/2020/09/01/window10/1.png" alt="alt"></p><h2 id="重装系统"><a href="#重装系统" class="headerlink" title="重装系统"></a>重装系统</h2><h3 id="前期准备"><a href="#前期准备" class="headerlink" title="前期准备"></a>前期准备</h3><p>工具：8G以上的U盘  </p><h4 id="下载镜像源："><a href="#下载镜像源：" class="headerlink" title="下载镜像源："></a>下载镜像源：</h4><p>旧版本的系统镜像源（非官方授权）<br>[msdn I tell you]  (<a href="https://msdn.itellyou.cn/" target="_blank" rel="noopener">https://msdn.itellyou.cn/</a>)   </p><p><img src="/2020/09/01/window10/2.png" alt="alt"><br>Window10<br>[微软官网]  (<a href="https://www.microsoft.com/zh-cn/software-download/windows10/" target="_blank" rel="noopener">https://www.microsoft.com/zh-cn/software-download/windows10/</a>)    </p><p><img src="/2020/09/01/window10/3.png" alt="alt"><br>下载安装工具后运行插入U盘选择为另一台电脑安装介质  </p><p><img src="/2020/09/01/window10/4.png" alt="alt">  </p><p>（注意: U盘插入后微软会自动格式化U盘）  </p><h3 id="开始重装"><a href="#开始重装" class="headerlink" title="开始重装"></a>开始重装</h3><p>1.插入U盘  </p><p>2.通过bios设置U盘为第一启动项  </p><p>3.进入系统安装界面进行逐步安装  </p><p><img src="/2020/09/01/window10/5.png" alt="alt">    </p><p>(注：在安装成功后系统重新启动时要拔出U盘)</p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;为什么要重做系统&quot;&gt;&lt;a href=&quot;#为什么要重做系统&quot; class=&quot;headerlink&quot; title=&quot;为什么要重做系统&quot;&gt;&lt;/a&gt;为什么要重做系统&lt;/h2&gt;&lt;p&gt;1.提高系统稳定性&lt;br&gt;2.清理系统垃圾&lt;br&gt;3.修复缺失的系统文件&lt;br&gt;4.杀死病毒&lt;br&gt;5.系统崩溃——没招  &lt;/p&gt;</summary>
    
    
    
    
    <category term="windows" scheme="http://yoursite.com/tags/windows/"/>
    
  </entry>
  
  <entry>
    <title>uni--app 接入高德地图</title>
    <link href="http://yoursite.com/2020/08/24/uni-app%E5%BC%80%E5%8F%91-%E5%89%8D%E7%AB%AF%E5%9C%B0%E5%9B%BE%E7%9A%84%E5%AE%9E%E7%8E%B0/"/>
    <id>http://yoursite.com/2020/08/24/uni-app%E5%BC%80%E5%8F%91-%E5%89%8D%E7%AB%AF%E5%9C%B0%E5%9B%BE%E7%9A%84%E5%AE%9E%E7%8E%B0/</id>
    <published>2020-08-24T05:06:33.000Z</published>
    <updated>2021-05-23T07:10:36.999Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、搭建Android开发环境"><a href="#一、搭建Android开发环境" class="headerlink" title="一、搭建Android开发环境"></a>一、搭建Android开发环境</h1><p>[开发工具：HBuilder X ]  (<a href="https://www.cnblogs.com/qisi007/p/10489176.html" target="_blank" rel="noopener">https://www.cnblogs.com/qisi007/p/10489176.html</a>)  </p><p>[ Android SDK 安装及配置]  ( <a href="https://www.cnblogs.com/nebie/p/9145627.html" target="_blank" rel="noopener">https://www.cnblogs.com/nebie/p/9145627.html</a>) </p><p>[JDK的安装及配置]  (<a href="https://zhuanlan.zhihu.com/p/105478993" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/105478993</a>)  </p><a id="more"></a><h2 id="二、-地图实现"><a href="#二、-地图实现" class="headerlink" title="二、    地图实现"></a>二、    地图实现</h2><h3 id="注册高德地图开发者账号"><a href="#注册高德地图开发者账号" class="headerlink" title="注册高德地图开发者账号"></a>注册高德地图开发者账号</h3><ul><li><p>[注册账号]  (<a href="https://lbs.amap.com/" target="_blank" rel="noopener">https://lbs.amap.com/</a>)    </p><h3 id="创建应用获取key（Android平台）"><a href="#创建应用获取key（Android平台）" class="headerlink" title="创建应用获取key（Android平台）"></a>创建应用获取key（Android平台）</h3></li><li><p>[创建Android平台签名证书 获取发布版SHA1值 ]  (<a href="https://ask.dcloud.net.cn/article/35777" target="_blank" rel="noopener">https://ask.dcloud.net.cn/article/35777</a>) </p></li><li><p>[获取调试版SHA1值]  ( <a href="https://blog.csdn.net/qq_21402513/article/details/51982234" target="_blank" rel="noopener">https://blog.csdn.net/qq_21402513/article/details/51982234</a>)  </p></li></ul><h3 id="获取PackageName"><a href="#获取PackageName" class="headerlink" title="获取PackageName"></a>获取PackageName</h3><ul><li>在HBuilder X中创建工程在发行云打包上获取Android包名即可    </li></ul><h3 id="创建应用获取key（小程序平台）"><a href="#创建应用获取key（小程序平台）" class="headerlink" title="创建应用获取key（小程序平台）"></a>创建应用获取key（小程序平台）</h3><ul><li>直接可得到key   </li></ul><h3 id="下载相应的sdk文件导入项目"><a href="#下载相应的sdk文件导入项目" class="headerlink" title="下载相应的sdk文件导入项目"></a>下载相应的sdk文件导入项目</h3><ul><li>[ Android sdk] ( <a href="https://lbs.amap.com/api/android-sdk/summary/" target="_blank" rel="noopener">https://lbs.amap.com/api/android-sdk/summary/</a>)  </li><li>[小程序 sdk ]  ( <a href="https://lbs.amap.com/api/wx/summary/" target="_blank" rel="noopener">https://lbs.amap.com/api/wx/summary/</a>)  <h3 id="在项目中创建Amap对象"><a href="#在项目中创建Amap对象" class="headerlink" title="在项目中创建Amap对象"></a>在项目中创建Amap对象</h3></li><li>[创建对象]  (<a href="https://ask.dcloud.net.cn/article/35070" target="_blank" rel="noopener">https://ask.dcloud.net.cn/article/35070</a>)  <h2 id="三、-运行"><a href="#三、-运行" class="headerlink" title="三、    运行"></a>三、    运行</h2><h3 id="运行到小程序模拟器"><a href="#运行到小程序模拟器" class="headerlink" title="运行到小程序模拟器"></a>运行到小程序模拟器</h3></li><li>[安装微信开发者工具]<br> (<a href="https://jingyan.baidu.com/article/f0e83a2558580022e591018b.html" target="_blank" rel="noopener">https://jingyan.baidu.com/article/f0e83a2558580022e591018b.html</a> )  </li><li>[获取小程序App Id]<br> (<a href="https://mp.weixin.qq.com/wxamp/home/guide?lang=zh_CN&amp;token=371280001" target="_blank" rel="noopener">https://mp.weixin.qq.com/wxamp/home/guide?lang=zh_CN&amp;token=371280001</a>)  </li></ul><h3 id="运行到手机模拟器（Android平台）"><a href="#运行到手机模拟器（Android平台）" class="headerlink" title="运行到手机模拟器（Android平台）"></a>运行到手机模拟器（Android平台）</h3><ul><li>[配置手机模拟器]  (<a href="https://ask.dcloud.net.cn/article/151" target="_blank" rel="noopener">https://ask.dcloud.net.cn/article/151</a>)   </li></ul><h2 id="附加、-git及github使用"><a href="#附加、-git及github使用" class="headerlink" title="附加、 git及github使用"></a>附加、 git及github使用</h2><ul><li>[ Git安装及配置]  (<a href="https://my.oschina.net/u/2933229/blog/1818671" target="_blank" rel="noopener">https://my.oschina.net/u/2933229/blog/1818671</a>)   </li><li>[TortoiseGIT 安装及配置]  (<a href="https://www.cnblogs.com/xiuxingzhe/p/9312929.html" target="_blank" rel="noopener">https://www.cnblogs.com/xiuxingzhe/p/9312929.html</a>)  </li></ul><hr><blockquote><p>我的第一篇博客   谢谢！</p></blockquote>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;一、搭建Android开发环境&quot;&gt;&lt;a href=&quot;#一、搭建Android开发环境&quot; class=&quot;headerlink&quot; title=&quot;一、搭建Android开发环境&quot;&gt;&lt;/a&gt;一、搭建Android开发环境&lt;/h1&gt;&lt;p&gt;[开发工具：HBuilder X ]  (&lt;a href=&quot;https://www.cnblogs.com/qisi007/p/10489176.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://www.cnblogs.com/qisi007/p/10489176.html&lt;/a&gt;)  &lt;/p&gt;
&lt;p&gt;[ Android SDK 安装及配置]  ( &lt;a href=&quot;https://www.cnblogs.com/nebie/p/9145627.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://www.cnblogs.com/nebie/p/9145627.html&lt;/a&gt;) &lt;/p&gt;
&lt;p&gt;[JDK的安装及配置]  (&lt;a href=&quot;https://zhuanlan.zhihu.com/p/105478993&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://zhuanlan.zhihu.com/p/105478993&lt;/a&gt;)  &lt;/p&gt;</summary>
    
    
    
    
    <category term="uni-app" scheme="http://yoursite.com/tags/uni-app/"/>
    
  </entry>
  
</feed>
